var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b ||= {})
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "node_modules/ws/lib/constants.js"(exports, module2) {
    "use strict";
    var BINARY_TYPES = ["nodebuffer", "arraybuffer", "fragments"];
    var hasBlob = typeof Blob !== "undefined";
    if (hasBlob)
      BINARY_TYPES.push("blob");
    module2.exports = {
      BINARY_TYPES,
      CLOSE_TIMEOUT: 3e4,
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      hasBlob,
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/ws/lib/buffer-util.js"(exports, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength) {
        return new FastBuffer(target.buffer, target.byteOffset, offset);
      }
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.length === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = new FastBuffer(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    module2.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = require("bufferutil");
        module2.exports.mask = function(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bufferUtil.mask(source, mask, output, offset, length);
        };
        module2.exports.unmask = function(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bufferUtil.unmask(buffer, mask);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/ws/lib/limiter.js"(exports, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/ws/lib/permessage-deflate.js"(exports, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) {
            data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      if (this[kError]) {
        this[kCallback](this[kError]);
        return;
      }
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/ws/lib/validation.js"(exports, module2) {
    "use strict";
    var { isUtf8 } = require("buffer");
    var { hasBlob } = require_constants();
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong
          buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong
          buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    function isBlob(value) {
      return hasBlob && typeof value === "object" && typeof value.arrayBuffer === "function" && typeof value.type === "string" && typeof value.stream === "function" && (value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File");
    }
    module2.exports = {
      isBlob,
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars
    };
    if (isUtf8) {
      module2.exports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = require("utf-8-validate");
        module2.exports.isValidUTF8 = function(buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/ws/lib/receiver.js"(exports, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var FastBuffer = Buffer[Symbol.species];
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var DEFER_EVENT = 6;
    var Receiver2 = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options = {}) {
        super();
        this._allowSynchronousEvents = options.allowSynchronousEvents !== void 0 ? options.allowSynchronousEvents : true;
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._errored = false;
        this._loop = false;
        this._state = GET_INFO;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(
            buf.buffer,
            buf.byteOffset + n,
            buf.length - n
          );
          return new FastBuffer(buf.buffer, buf.byteOffset, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = new FastBuffer(
              buf.buffer,
              buf.byteOffset + n,
              buf.length - n
            );
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              this.getInfo(cb);
              break;
            case GET_PAYLOAD_LENGTH_16:
              this.getPayloadLength16(cb);
              break;
            case GET_PAYLOAD_LENGTH_64:
              this.getPayloadLength64(cb);
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              this.getData(cb);
              break;
            case INFLATING:
            case DEFER_EVENT:
              this._loop = false;
              return;
          }
        } while (this._loop);
        if (!this._errored)
          cb();
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @param {Function} cb Callback
       * @private
       */
      getInfo(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          const error = this.createError(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
          cb(error);
          return;
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          const error = this.createError(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
          cb(error);
          return;
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (!this._fragmented) {
            const error = this.createError(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            const error = this.createError(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            const error = this.createError(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
            cb(error);
            return;
          }
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
            const error = this.createError(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
            cb(error);
            return;
          }
        } else {
          const error = this.createError(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
          cb(error);
          return;
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            const error = this.createError(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
            cb(error);
            return;
          }
        } else if (this._masked) {
          const error = this.createError(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
          cb(error);
          return;
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength16(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength64(cb) {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          const error = this.createError(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
          cb(error);
          return;
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        this.haveLength(cb);
      }
      /**
       * Payload length has been read.
       *
       * @param {Function} cb Callback
       * @private
       */
      haveLength(cb) {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
            cb(error);
            return;
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7) {
          this.controlMessage(data, cb);
          return;
        }
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        this.dataMessage(cb);
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              const error = this.createError(
                RangeError,
                "Max payload size exceeded",
                false,
                1009,
                "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
              );
              cb(error);
              return;
            }
            this._fragments.push(buf);
          }
          this.dataMessage(cb);
          if (this._state === GET_INFO)
            this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @param {Function} cb Callback
       * @private
       */
      dataMessage(cb) {
        if (!this._fin) {
          this._state = GET_INFO;
          return;
        }
        const messageLength = this._messageLength;
        const fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          let data;
          if (this._binaryType === "nodebuffer") {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === "arraybuffer") {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else if (this._binaryType === "blob") {
            data = new Blob(fragments);
          } else {
            data = fragments;
          }
          if (this._allowSynchronousEvents) {
            this.emit("message", data, true);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", data, true);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        } else {
          const buf = concat(fragments, messageLength);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(
              Error,
              "invalid UTF-8 sequence",
              true,
              1007,
              "WS_ERR_INVALID_UTF8"
            );
            cb(error);
            return;
          }
          if (this._state === INFLATING || this._allowSynchronousEvents) {
            this.emit("message", buf, false);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", buf, false);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        }
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data, cb) {
        if (this._opcode === 8) {
          if (data.length === 0) {
            this._loop = false;
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              const error = this.createError(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
              cb(error);
              return;
            }
            const buf = new FastBuffer(
              data.buffer,
              data.byteOffset + 2,
              data.length - 2
            );
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              const error = this.createError(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
              cb(error);
              return;
            }
            this._loop = false;
            this.emit("conclude", code, buf);
            this.end();
          }
          this._state = GET_INFO;
          return;
        }
        if (this._allowSynchronousEvents) {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit(this._opcode === 9 ? "ping" : "pong", data);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
      /**
       * Builds an error object.
       *
       * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
       * @param {String} message The error message
       * @param {Boolean} prefix Specifies whether or not to add a default prefix to
       *     `message`
       * @param {Number} statusCode The status code
       * @param {String} errorCode The exposed error code
       * @return {(Error|RangeError)} The error
       * @private
       */
      createError(ErrorCtor, message, prefix, statusCode, errorCode) {
        this._loop = false;
        this._errored = true;
        const err = new ErrorCtor(
          prefix ? `Invalid WebSocket frame: ${message}` : message
        );
        Error.captureStackTrace(err, this.createError);
        err.code = errorCode;
        err[kStatusCode] = statusCode;
        return err;
      }
    };
    module2.exports = Receiver2;
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/ws/lib/sender.js"(exports, module2) {
    "use strict";
    var { Duplex } = require("stream");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER, kWebSocket, NOOP } = require_constants();
    var { isBlob, isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var RANDOM_POOL_SIZE = 8 * 1024;
    var randomPool;
    var randomPoolPointer = RANDOM_POOL_SIZE;
    var DEFAULT = 0;
    var DEFLATING = 1;
    var GET_BLOB_DATA = 2;
    var Sender2 = class {
      /**
       * Creates a Sender instance.
       *
       * @param {Duplex} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._queue = [];
        this._state = DEFAULT;
        this.onerror = NOOP;
        this[kWebSocket] = void 0;
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options) {
        let mask;
        let merge = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            if (randomPoolPointer === RANDOM_POOL_SIZE) {
              if (randomPool === void 0) {
                randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
              }
              randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
              randomPoolPointer = 0;
            }
            mask[0] = randomPool[randomPoolPointer++];
            mask[1] = randomPool[randomPoolPointer++];
            mask[2] = randomPool[randomPoolPointer++];
            mask[3] = randomPool[randomPoolPointer++];
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask)
          return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking)
          return [target, data];
        if (merge) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(Sender2.frame(buf, options), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(Sender2.frame(data, options), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(Sender2.frame(data, options), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        const opts = {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
          } else {
            this.getBlobData(data, this._compress, opts, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, this._compress, opts, cb]);
        } else {
          this.dispatch(data, this._compress, opts, cb);
        }
      }
      /**
       * Gets the contents of a blob as binary data.
       *
       * @param {Blob} blob The blob
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     the data
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      getBlobData(blob, compress, options, cb) {
        this._bufferedBytes += options[kByteLength];
        this._state = GET_BLOB_DATA;
        blob.arrayBuffer().then((arrayBuffer) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while the blob was being read"
            );
            process.nextTick(callCallbacks, this, err, cb);
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          const data = toBuffer(arrayBuffer);
          if (!compress) {
            this._state = DEFAULT;
            this.sendFrame(Sender2.frame(data, options), cb);
            this.dequeue();
          } else {
            this.dispatch(data, compress, options, cb);
          }
        }).catch((err) => {
          process.nextTick(onError, this, err, cb);
        });
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(Sender2.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._state = DEFLATING;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            callCallbacks(this, err, cb);
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._state = DEFAULT;
          options.readOnly = false;
          this.sendFrame(Sender2.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (this._state === DEFAULT && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {(Buffer | String)[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender2;
    function callCallbacks(sender, err, cb) {
      if (typeof cb === "function")
        cb(err);
      for (let i = 0; i < sender._queue.length; i++) {
        const params = sender._queue[i];
        const callback = params[params.length - 1];
        if (typeof callback === "function")
          callback(err);
      }
    }
    function onError(sender, err, cb) {
      callCallbacks(sender, err, cb);
      sender.onerror(err);
    }
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/ws/lib/event-target.js"(exports, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event.prototype, "target", { enumerable: true });
    Object.defineProperty(Event.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, handler, options = {}) {
        for (const listener of this.listeners(type)) {
          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data : data.toString()
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error) {
            const event = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event("open");
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent,
      Event,
      EventTarget,
      MessageEvent
    };
    function callListener(listener, thisArg, event) {
      if (typeof listener === "object" && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
      } else {
        listener.call(thisArg, event);
      }
    }
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/ws/lib/extension.js"(exports, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (i !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values))
                values = [values];
              return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse };
  }
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/ws/lib/websocket.js"(exports, module2) {
    "use strict";
    var EventEmitter = require("events");
    var https = require("https");
    var http = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash: createHash3 } = require("crypto");
    var { Duplex, Readable } = require("stream");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver2 = require_receiver();
    var Sender2 = require_sender();
    var { isBlob } = require_validation();
    var {
      BINARY_TYPES,
      CLOSE_TIMEOUT,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target();
    var { format, parse } = require_extension();
    var { toBuffer } = require_buffer_util();
    var kAborted = Symbol("kAborted");
    var protocolVersions = [8, 13];
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket2 = class extends EventEmitter {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._errorEmitted = false;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = WebSocket2.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._autoPong = options.autoPong;
          this._closeTimeout = options.closeTimeout;
          this._isServer = true;
        }
      }
      /**
       * For historical reasons, the custom "nodebuffer" type is used by the default
       * instead of "blob".
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options) {
        const receiver = new Receiver2({
          allowSynchronousEvents: options.allowSynchronousEvents,
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        const sender = new Sender2(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._sender = sender;
        this._socket = socket;
        receiver[kWebSocket] = this;
        sender[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        sender.onerror = senderOnError;
        if (socket.setTimeout)
          socket.setTimeout(0);
        if (socket.setNoDelay)
          socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = WebSocket2.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket2.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket2.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code, data) {
        if (this.readyState === WebSocket2.CLOSED)
          return;
        if (this.readyState === WebSocket2.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this.readyState === WebSocket2.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket2.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        setCloseTimer(this);
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === WebSocket2.CONNECTING || this.readyState === WebSocket2.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain)
          this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options, cb) {
        if (this.readyState === WebSocket2.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket2.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === WebSocket2.CLOSED)
          return;
        if (this.readyState === WebSocket2.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = WebSocket2.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket2, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket2.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute])
              return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function")
            return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket2.prototype.addEventListener = addEventListener;
    WebSocket2.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket2;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        allowSynchronousEvents: true,
        autoPong: true,
        closeTimeout: CLOSE_TIMEOUT,
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0
      };
      websocket._autoPong = opts.autoPong;
      websocket._closeTimeout = opts.closeTimeout;
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
      } else {
        try {
          parsedUrl = new URL2(address);
        } catch (e) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
      }
      if (parsedUrl.protocol === "http:") {
        parsedUrl.protocol = "ws:";
      } else if (parsedUrl.protocol === "https:") {
        parsedUrl.protocol = "wss:";
      }
      websocket._url = parsedUrl.href;
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", "http:", "https:", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const request = isSecure ? https.request : http.request;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError(
              "An invalid or duplicated subprotocol was specified"
            );
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost)
              delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted])
          return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location, address);
          } catch (e) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket2.CONNECTING)
          return;
        req = websocket._req = null;
        const upgrade = res.headers.upgrade;
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash3("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          allowSynchronousEvents: opts.allowSynchronousEvents,
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
      if (opts.finishRequest) {
        opts.finishRequest(req, websocket);
      } else {
        req.end();
      }
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket2.CLOSING;
      websocket._errorEmitted = true;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket2.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream[kAborted] = true;
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = isBlob(data) ? data.size : toBuffer(data).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length;
        else
          websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        process.nextTick(cb, err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0)
        return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused)
        websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit("error", err);
      }
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary) {
      this[kWebSocket].emit("message", data, isBinary);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      if (websocket._autoPong)
        websocket.pong(data, !this._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function senderOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket.readyState === WebSocket2.CLOSED)
        return;
      if (websocket.readyState === WebSocket2.OPEN) {
        websocket._readyState = WebSocket2.CLOSING;
        setCloseTimer(websocket);
      }
      this._socket.end();
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit("error", err);
      }
    }
    function setCloseTimer(websocket) {
      websocket._closeTimer = setTimeout(
        websocket._socket.destroy.bind(websocket._socket),
        websocket._closeTimeout
      );
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket2.CLOSING;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && this._readableState.length !== 0) {
        const chunk = this.read(this._readableState.length);
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket2.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket2.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "node_modules/ws/lib/stream.js"(exports, module2) {
    "use strict";
    var WebSocket2 = require_websocket();
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream2(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary) {
        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data))
          ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed)
          return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called)
            callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy)
          ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null)
          return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused)
          ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream2;
  }
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "node_modules/ws/lib/subprotocol.js"(exports, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function parse(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i = 0;
      for (i; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = { parse };
  }
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/ws/lib/websocket-server.js"(exports, module2) {
    "use strict";
    var EventEmitter = require("events");
    var http = require("http");
    var { Duplex } = require("stream");
    var { createHash: createHash3 } = require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket2 = require_websocket();
    var { CLOSE_TIMEOUT, GUID, kWebSocket } = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer2 = class extends EventEmitter {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Boolean} [options.autoPong=true] Specifies whether or not to
       *     automatically send a pong in response to a ping
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Number} [options.closeTimeout=30000] Duration in milliseconds to
       *     wait for the closing handshake to finish after `websocket.close()` is
       *     called
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = {
          allowSynchronousEvents: true,
          autoPong: true,
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          closeTimeout: CLOSE_TIMEOUT,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket2,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"];
        const upgrade = req.headers.upgrade;
        const version = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (key === void 0 || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version !== 13 && version !== 8) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message, {
            "Sec-WebSocket-Version": "13, 8"
          });
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(
                extensions,
                key,
                protocols,
                req,
                socket,
                head,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash3("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null, void 0, this.options);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          allowSynchronousEvents: this.options.allowSynchronousEvents,
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer2;
    function addListeners(server, map) {
      for (const event of Object.keys(map))
        server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      message = message || http.STATUS_CODES[code];
      headers = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message),
        ...headers
      };
      socket.once("finish", socket.destroy);
      socket.end(
        `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
      );
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message, headers) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code, message, headers);
      }
    }
  }
});

// node_modules/ws/wrapper.mjs
var import_stream, import_receiver, import_sender, import_websocket, import_websocket_server;
var init_wrapper = __esm({
  "node_modules/ws/wrapper.mjs"() {
    import_stream = __toESM(require_stream(), 1);
    import_receiver = __toESM(require_receiver(), 1);
    import_sender = __toESM(require_sender(), 1);
    import_websocket = __toESM(require_websocket(), 1);
    import_websocket_server = __toESM(require_websocket_server(), 1);
  }
});

// src/core/websocket/websocket-types.ts
var init_websocket_types = __esm({
  "src/core/websocket/websocket-types.ts"() {
  }
});

// src/core/websocket/websocket-client.ts
var websocket_client_exports = {};
__export(websocket_client_exports, {
  WebSocketClient: () => WebSocketClient
});
var WebSocketClient;
var init_websocket_client = __esm({
  "src/core/websocket/websocket-client.ts"() {
    init_wrapper();
    init_websocket_types();
    WebSocketClient = class {
      constructor(config) {
        this.ws = null;
        this.state = "disconnected" /* DISCONNECTED */;
        this.messageCallbacks = /* @__PURE__ */ new Set();
        this.errorCallbacks = /* @__PURE__ */ new Set();
        this.stateChangeCallbacks = /* @__PURE__ */ new Set();
        this.reconnectTimer = null;
        this.reconnectAttempts = 0;
        this.isManualDisconnect = false;
        this.config = __spreadValues({
          autoReconnect: true,
          reconnectInterval: 5e3,
          maxRetries: 10,
          connectTimeout: 1e4
        }, config);
      }
      /**
       * Connect to WebSocket server
       */
      connect() {
        return __async(this, null, function* () {
          if (this.state === "connected" /* CONNECTED */ || this.state === "connecting" /* CONNECTING */) {
            return;
          }
          this.isManualDisconnect = false;
          this.setState("connecting" /* CONNECTING */);
          const url = new URL(this.config.url);
          url.searchParams.set("conversationId", this.config.conversationId);
          return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
              reject(new Error(`Connection timeout after ${this.config.connectTimeout}ms`));
            }, this.config.connectTimeout);
            try {
              this.ws = new import_websocket.default(url.toString());
              this.ws.on("open", () => {
                clearTimeout(timeout);
                this.reconnectAttempts = 0;
                this.setState("connected" /* CONNECTED */);
                console.log(`\u2705 WebSocket connected to ${this.config.url}`);
                resolve();
              });
              this.ws.on("message", (data) => {
                this.handleMessage(data);
              });
              this.ws.on("error", (error) => {
                clearTimeout(timeout);
                this.handleError(error);
                reject(error);
              });
              this.ws.on("close", (code, reason) => {
                clearTimeout(timeout);
                this.handleClose(code, reason.toString());
              });
            } catch (error) {
              clearTimeout(timeout);
              this.handleError(error);
              reject(error);
            }
          });
        });
      }
      /**
       * Disconnect from server
       */
      disconnect() {
        this.isManualDisconnect = true;
        if (this.reconnectTimer) {
          clearTimeout(this.reconnectTimer);
          this.reconnectTimer = null;
        }
        if (this.ws) {
          this.ws.close();
          this.ws = null;
        }
        this.setState("disconnected" /* DISCONNECTED */);
        console.log("\u{1F50C} WebSocket disconnected");
      }
      /**
       * Send message to server
       */
      send(message) {
        if (!this.isConnected()) {
          throw new Error("Cannot send message: not connected");
        }
        try {
          const messageStr = JSON.stringify(message);
          this.ws.send(messageStr);
          console.log(`\u{1F4E4} Sent: ${message.type}`);
        } catch (error) {
          console.error("\u274C Failed to send message:", error);
          throw error;
        }
      }
      /**
       * Check if connected
       */
      isConnected() {
        return this.state === "connected" /* CONNECTED */ && this.ws !== null && this.ws.readyState === import_websocket.default.OPEN;
      }
      /**
       * Get current connection state
       */
      getConnectionState() {
        return this.state;
      }
      /**
       * Get current connection state (alias for compatibility)
       */
      getState() {
        return this.state;
      }
      /**
       * Register message callback
       */
      onMessage(callback) {
        this.messageCallbacks.add(callback);
        return () => this.messageCallbacks.delete(callback);
      }
      /**
       * Register error callback
       */
      onError(callback) {
        this.errorCallbacks.add(callback);
        return () => this.errorCallbacks.delete(callback);
      }
      /**
       * Register state change callback
       */
      onStateChange(callback) {
        this.stateChangeCallbacks.add(callback);
        callback(this.state);
        return () => this.stateChangeCallbacks.delete(callback);
      }
      /**
       * Handle incoming message
       */
      handleMessage(data) {
        try {
          const message = JSON.parse(data.toString());
          console.log(`\u{1F4E5} Received: ${message.type}`);
          this.messageCallbacks.forEach((callback) => {
            try {
              callback(message);
            } catch (error) {
              console.error("\u274C Error in message callback:", error);
            }
          });
        } catch (error) {
          console.error("\u274C Failed to parse message:", error);
        }
      }
      /**
       * Handle connection error
       */
      handleError(error) {
        console.error("\u274C WebSocket error:", error);
        this.setState("error" /* ERROR */);
        this.errorCallbacks.forEach((callback) => {
          try {
            callback(error);
          } catch (err) {
            console.error("\u274C Error in error callback:", err);
          }
        });
      }
      /**
       * Handle connection close
       */
      handleClose(code, reason) {
        console.log(`\u{1F50C} WebSocket closed: ${code} - ${reason}`);
        if (this.isManualDisconnect) {
          this.setState("disconnected" /* DISCONNECTED */);
          return;
        }
        this.setState("disconnected" /* DISCONNECTED */);
        if (this.config.autoReconnect && this.reconnectAttempts < (this.config.maxRetries || 10)) {
          this.scheduleReconnect();
        }
      }
      /**
       * Schedule reconnection
       */
      scheduleReconnect() {
        if (this.reconnectTimer) {
          return;
        }
        const delay = (this.config.reconnectInterval || 5e3) * Math.pow(2, this.reconnectAttempts);
        console.log(`\u{1F504} Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts + 1})`);
        this.setState("reconnecting" /* RECONNECTING */);
        this.reconnectTimer = setTimeout(() => {
          this.reconnectTimer = null;
          this.reconnectAttempts++;
          this.connect().catch((error) => {
            console.error("\u274C Reconnect failed:", error.message);
          });
        }, delay);
      }
      /**
       * Set connection state and notify listeners
       */
      setState(newState) {
        if (this.state !== newState) {
          this.state = newState;
          console.log(`\u{1F4E1} State changed: ${newState}`);
          this.stateChangeCallbacks.forEach((callback) => {
            try {
              callback(newState);
            } catch (error) {
              console.error("\u274C Error in state change callback:", error);
            }
          });
        }
      }
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ClaudeCodePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/ui/view.ts
var import_obsidian3 = require("obsidian");

// src/core/types.ts
var VIEW_TYPE_CLAUDE_CODE = "claude-code-view";

// src/i18n/locales/en.ts
var en = {
  // Header
  "header.title": "Claude Code assistant",
  "header.noNoteSelected": "no note selected",
  // Input Section
  "input.label": "Your instructions:",
  "input.placeholder": 'e.g., "Add more examples to this section" or "Reorganize with better headers" (Enter to send, Ctrl+Enter for new line)',
  "input.conversationalMode": "conversational mode (no file edits)",
  "input.conversationalModeTooltip": "Chat with Claude without modifying any files",
  "input.selectedTextOnly": "Edit selected text only",
  "input.autoAccept": "Auto-accept changes",
  "input.modelLabel": "Model:",
  "input.modelDefault": "Default",
  "input.runButton": "Run Claude Code",
  "input.runningButton": "Running...",
  "input.cancelButton": "Cancel",
  // Result Section
  "result.title": "Result",
  // Output Section
  "output.title": "Output",
  // Preview Section
  "preview.title": "Preview",
  "preview.tabRaw": "Raw",
  "preview.tabDiff": "Diff",
  "preview.tabRendered": "Rendered",
  "preview.originalChars": "Original:",
  "preview.modifiedChars": "Modified:",
  "preview.chars": "chars",
  "preview.applyButton": "apply changes",
  "preview.rejectButton": "reject",
  // History Section
  "history.title": "History",
  "history.clearButton": "Clear",
  // Agent Section
  "agent.planTitle": "plan",
  "agent.activityTitle": "Activity",
  "agent.noPlan": "No plan created yet",
  // Todo Status
  "todo.pending": "pending",
  "todo.inProgress": "in progress",
  "todo.completed": "completed",
  // Interactive Prompt
  "interactive.header": "Claude is asking for confirmation",
  "interactive.yesButton": "yes",
  "interactive.noButton": "no",
  "interactive.customPlaceholder": "Or type a custom response...",
  // Permission Approval
  "permission.header": "permission required",
  "permission.message": "Claude is requesting permission to execute actions.",
  "permission.approveButton": "approve & continue",
  "permission.denyButton": "deny",
  // Status Messages
  "status.processing": "Claude is processing",
  "status.autoApplying": "Auto-applying changes...",
  "status.runningAuthorized": "Running authorized tasks",
  "status.runningInBackground": "Running in background...",
  "status.failed": "Failed - see error below",
  // Notifications
  "notice.alreadyProcessing": "Already processing a request. Please wait.",
  "notice.enterPrompt": "Please enter a prompt",
  "notice.noActiveNote": "No active note found, please open a Markdown note first",
  "notice.noEditor": "No Markdown editor found, please make sure you have a note open",
  "notice.noVaultPath": "Could not determine vault path",
  "notice.completed": "Claude Code completed",
  "notice.completedNoChanges": "Claude Code completed (no file changes)",
  "notice.changesApplied": "changes applied automatically",
  "notice.changesAppliedSuccess": "changes applied successfully",
  "notice.failedApplyChanges": "failed to apply changes",
  "notice.changesRejected": "Changes rejected",
  "notice.cancelled": "Cancelled",
  "notice.permissionRequest": "Claude is requesting permission - please approve or deny",
  "notice.permissionDenied": "Permission denied - Claude will not proceed",
  "notice.noChangesToApply": "no changes to apply",
  "notice.noActiveFile": "no active file",
  "notice.historyRestored": "History item restored",
  "notice.historyRestoredWithChanges": "History item restored with proposed changes",
  "notice.historyCleared": "History cleared",
  // Diff View
  "diff.original": "Original",
  "diff.modified": "Modified",
  // Result Renderer
  "result.directAnswer": "Direct answer",
  "result.additionalContext": "Additional Context",
  "result.tokens": "tokens",
  "result.tokensIn": "in",
  "result.tokensOut": "out",
  // Preview Stats
  "preview.originalLabel": "Original:",
  "preview.modifiedLabel": "Modified:",
  "preview.charsLabel": "chars",
  // Misc
  "misc.noPendingRequest": "No pending request found",
  "misc.languageChanged": "Language changed. Some UI elements will update on reload.",
  "misc.testFailed": "Claude Code test failed",
  // Settings
  "settings.autoDetectPath": "Auto-detect Claude Code path",
  "settings.autoDetectPathDesc": "Automatically detect the Claude Code executable location",
  "settings.executablePath": "Claude Code executable path",
  "settings.executablePathDesc": "Full path to the Claude Code executable (e.g., /usr/local/bin/claude)",
  "settings.testInstallation": "Test Claude Code installation",
  "settings.testInstallationDesc": "Verify that Claude Code is accessible and working",
  "settings.testButton": "Test",
  "settings.testWorking": "working!",
  "settings.testFailed": "failed",
  "settings.customPrompt": "Custom system prompt",
  "settings.customPromptDesc": "Optional custom system prompt to prepend to all requests",
  "settings.customPromptPlaceholder": "You are helping edit markdown notes...",
  "settings.preserveCursor": "Preserve cursor position",
  "settings.preserveCursorDesc": "Try to maintain cursor position after applying changes",
  "settings.autoAcceptChanges": "Auto-accept changes",
  "settings.autoAcceptChangesDesc": "Automatically apply changes without showing preview (use with caution!)",
  "settings.model": "Model",
  "settings.modelDesc": "Select the Claude model to use: Sonnet (balanced), Opus (most capable), or Haiku (fastest). Leave empty to use the default subagent model.",
  "settings.modelDefault": "Default (subagent model)",
  "settings.modelSonnet": "Sonnet (balanced)",
  "settings.modelOpus": "Opus (most capable)",
  "settings.modelHaiku": "Haiku (fastest)",
  "settings.vaultAccess": "Allow vault-wide access",
  "settings.vaultAccessDesc": "Allow Claude to read/search other files in your vault (not just the current note)",
  "settings.permissionlessMode": "Enable permissionless mode",
  "settings.permissionlessModeDesc": "Allow Claude to execute actions without asking for permission each time (use with caution! Claude will have full control)",
  "settings.timeout": "Timeout (seconds)",
  "settings.timeoutDesc": "Maximum time to wait for Claude Code response (0 = no timeout)",
  "settings.customApiConfig": "Custom API configuration",
  "settings.customApiConfigDesc": "Configure custom API endpoints for regions where Claude is not directly available. Leave empty to use default settings.",
  "settings.apiBaseUrl": "API base URL",
  "settings.apiBaseUrlDesc": "Custom API endpoint URL (e.g., https://api.kimi.com/coding/)",
  "settings.apiAuthToken": "API auth token",
  "settings.apiAuthTokenDesc": "Custom authentication token for the API endpoint",
  "settings.apiAuthTokenPlaceholder": "Enter your API token",
  "settings.customModel": "Custom model",
  "settings.customModelDesc": "Custom model name to use (e.g., kimi-for-coding). Overrides the model dropdown above.",
  "settings.customSmallModel": "Custom small/fast model",
  "settings.customSmallModelDesc": "Custom model name for fast operations (e.g., kimi-for-coding)",
  "settings.language": "Language",
  "settings.languageDesc": "Select interface language"
};

// src/i18n/locales/zh.ts
var zh = {
  // Header
  "header.title": "Claude Code \u52A9\u624B",
  "header.noNoteSelected": "\u672A\u9009\u62E9\u7B14\u8BB0",
  // Input Section
  "input.label": "\u8F93\u5165\u6307\u4EE4\uFF1A",
  "input.placeholder": '\u4F8B\u5982\uFF1A"\u4E3A\u8FD9\u4E2A\u90E8\u5206\u6DFB\u52A0\u66F4\u591A\u793A\u4F8B" \u6216 "\u7528\u66F4\u597D\u7684\u6807\u9898\u91CD\u65B0\u7EC4\u7EC7"\uFF08\u56DE\u8F66\u53D1\u9001\uFF0CCtrl+\u56DE\u8F66\u6362\u884C\uFF09',
  "input.conversationalMode": "\u5BF9\u8BDD\u6A21\u5F0F\uFF08\u4E0D\u4FEE\u6539\u6587\u4EF6\uFF09",
  "input.conversationalModeTooltip": "\u4E0E Claude \u5BF9\u8BDD\u4F46\u4E0D\u4FEE\u6539\u4EFB\u4F55\u6587\u4EF6",
  "input.selectedTextOnly": "\u4EC5\u7F16\u8F91\u9009\u4E2D\u6587\u672C",
  "input.autoAccept": "\u81EA\u52A8\u5E94\u7528\u66F4\u6539",
  "input.modelLabel": "\u6A21\u578B\uFF1A",
  "input.modelDefault": "\u9ED8\u8BA4",
  "input.runButton": "\u8FD0\u884C Claude Code",
  "input.runningButton": "\u8FD0\u884C\u4E2D...",
  "input.cancelButton": "\u53D6\u6D88",
  // Result Section
  "result.title": "\u7ED3\u679C",
  // Output Section
  "output.title": "\u8F93\u51FA",
  // Preview Section
  "preview.title": "\u9884\u89C8",
  "preview.tabRaw": "\u539F\u59CB",
  "preview.tabDiff": "\u5DEE\u5F02",
  "preview.tabRendered": "\u6E32\u67D3",
  "preview.originalChars": "\u539F\u59CB\uFF1A",
  "preview.modifiedChars": "\u4FEE\u6539\u540E\uFF1A",
  "preview.chars": "\u5B57\u7B26",
  "preview.applyButton": "\u5E94\u7528\u66F4\u6539",
  "preview.rejectButton": "\u62D2\u7EDD",
  // History Section
  "history.title": "\u5386\u53F2\u8BB0\u5F55",
  "history.clearButton": "\u6E05\u9664",
  // Agent Section
  "agent.planTitle": "\u8BA1\u5212",
  "agent.activityTitle": "\u6D3B\u52A8",
  "agent.noPlan": "\u5C1A\u672A\u521B\u5EFA\u8BA1\u5212",
  // Todo Status
  "todo.pending": "\u5F85\u5904\u7406",
  "todo.inProgress": "\u8FDB\u884C\u4E2D",
  "todo.completed": "\u5DF2\u5B8C\u6210",
  // Interactive Prompt
  "interactive.header": "Claude \u6B63\u5728\u8BF7\u6C42\u786E\u8BA4",
  "interactive.yesButton": "\u662F",
  "interactive.noButton": "\u5426",
  "interactive.customPlaceholder": "\u6216\u8F93\u5165\u81EA\u5B9A\u4E49\u56DE\u590D...",
  // Permission Approval
  "permission.header": "\u9700\u8981\u6743\u9650",
  "permission.message": "Claude \u6B63\u5728\u8BF7\u6C42\u6267\u884C\u64CD\u4F5C\u7684\u6743\u9650\u3002",
  "permission.approveButton": "\u6279\u51C6\u5E76\u7EE7\u7EED",
  "permission.denyButton": "\u62D2\u7EDD",
  // Status Messages
  "status.processing": "Claude \u6B63\u5728\u5904\u7406",
  "status.autoApplying": "\u6B63\u5728\u81EA\u52A8\u5E94\u7528\u66F4\u6539...",
  "status.runningAuthorized": "\u6B63\u5728\u6267\u884C\u6388\u6743\u4EFB\u52A1",
  "status.runningInBackground": "\u540E\u53F0\u8FD0\u884C\u4E2D...",
  "status.failed": "\u5931\u8D25 - \u8BF7\u67E5\u770B\u4E0B\u65B9\u9519\u8BEF\u4FE1\u606F",
  // Notifications
  "notice.alreadyProcessing": "\u6B63\u5728\u5904\u7406\u8BF7\u6C42\uFF0C\u8BF7\u7A0D\u5019\u3002",
  "notice.enterPrompt": "\u8BF7\u8F93\u5165\u6307\u4EE4",
  "notice.noActiveNote": "\u672A\u627E\u5230\u6D3B\u52A8\u7B14\u8BB0\uFF0C\u8BF7\u5148\u6253\u5F00\u4E00\u4E2A Markdown \u7B14\u8BB0",
  "notice.noEditor": "\u672A\u627E\u5230 Markdown \u7F16\u8F91\u5668\uFF0C\u8BF7\u786E\u4FDD\u5DF2\u6253\u5F00\u7B14\u8BB0",
  "notice.noVaultPath": "\u65E0\u6CD5\u786E\u5B9A\u4ED3\u5E93\u8DEF\u5F84",
  "notice.completed": "Claude Code \u5DF2\u5B8C\u6210",
  "notice.completedNoChanges": "Claude Code \u5DF2\u5B8C\u6210\uFF08\u65E0\u6587\u4EF6\u66F4\u6539\uFF09",
  "notice.changesApplied": "\u66F4\u6539\u5DF2\u81EA\u52A8\u5E94\u7528",
  "notice.changesAppliedSuccess": "\u66F4\u6539\u5DF2\u6210\u529F\u5E94\u7528",
  "notice.failedApplyChanges": "\u5E94\u7528\u66F4\u6539\u5931\u8D25",
  "notice.changesRejected": "\u66F4\u6539\u5DF2\u62D2\u7EDD",
  "notice.cancelled": "\u5DF2\u53D6\u6D88",
  "notice.permissionRequest": "Claude \u6B63\u5728\u8BF7\u6C42\u6743\u9650 - \u8BF7\u6279\u51C6\u6216\u62D2\u7EDD",
  "notice.permissionDenied": "\u6743\u9650\u88AB\u62D2\u7EDD - Claude \u5C06\u4E0D\u4F1A\u7EE7\u7EED",
  "notice.noChangesToApply": "\u6CA1\u6709\u53EF\u5E94\u7528\u7684\u66F4\u6539",
  "notice.noActiveFile": "\u6CA1\u6709\u6D3B\u52A8\u6587\u4EF6",
  "notice.historyRestored": "\u5386\u53F2\u8BB0\u5F55\u9879\u5DF2\u6062\u590D",
  "notice.historyRestoredWithChanges": "\u5386\u53F2\u8BB0\u5F55\u9879\u5DF2\u6062\u590D\uFF08\u5305\u542B\u5EFA\u8BAE\u7684\u66F4\u6539\uFF09",
  "notice.historyCleared": "\u5386\u53F2\u8BB0\u5F55\u5DF2\u6E05\u9664",
  // Diff View
  "diff.original": "\u539F\u59CB",
  "diff.modified": "\u4FEE\u6539\u540E",
  // Result Renderer
  "result.directAnswer": "\u76F4\u63A5\u56DE\u7B54",
  "result.additionalContext": "\u9644\u52A0\u5185\u5BB9",
  "result.tokens": "\u4EE4\u724C",
  "result.tokensIn": "\u8F93\u5165",
  "result.tokensOut": "\u8F93\u51FA",
  // Preview Stats
  "preview.originalLabel": "\u539F\u59CB\uFF1A",
  "preview.modifiedLabel": "\u4FEE\u6539\u540E\uFF1A",
  "preview.charsLabel": "\u5B57\u7B26",
  // Misc
  "misc.noPendingRequest": "\u672A\u627E\u5230\u5F85\u5904\u7406\u7684\u8BF7\u6C42",
  "misc.languageChanged": "\u8BED\u8A00\u5DF2\u66F4\u6539\u3002\u90E8\u5206\u754C\u9762\u5143\u7D20\u5C06\u5728\u91CD\u65B0\u52A0\u8F7D\u540E\u66F4\u65B0\u3002",
  "misc.testFailed": "Claude Code \u6D4B\u8BD5\u5931\u8D25",
  // Settings
  "settings.autoDetectPath": "\u81EA\u52A8\u68C0\u6D4B Claude Code \u8DEF\u5F84",
  "settings.autoDetectPathDesc": "\u81EA\u52A8\u68C0\u6D4B Claude Code \u53EF\u6267\u884C\u6587\u4EF6\u7684\u4F4D\u7F6E",
  "settings.executablePath": "Claude Code \u53EF\u6267\u884C\u6587\u4EF6\u8DEF\u5F84",
  "settings.executablePathDesc": "Claude Code \u53EF\u6267\u884C\u6587\u4EF6\u7684\u5B8C\u6574\u8DEF\u5F84\uFF08\u4F8B\u5982\uFF1A/usr/local/bin/claude\uFF09",
  "settings.testInstallation": "\u6D4B\u8BD5 Claude Code \u5B89\u88C5",
  "settings.testInstallationDesc": "\u9A8C\u8BC1 Claude Code \u662F\u5426\u53EF\u8BBF\u95EE\u5E76\u6B63\u5E38\u5DE5\u4F5C",
  "settings.testButton": "\u6D4B\u8BD5",
  "settings.testWorking": "\u6B63\u5E38\u5DE5\u4F5C\uFF01",
  "settings.testFailed": "\u5931\u8D25",
  "settings.customPrompt": "\u81EA\u5B9A\u4E49\u7CFB\u7EDF\u63D0\u793A",
  "settings.customPromptDesc": "\u53EF\u9009\u7684\u81EA\u5B9A\u4E49\u7CFB\u7EDF\u63D0\u793A\uFF0C\u5C06\u6DFB\u52A0\u5230\u6240\u6709\u8BF7\u6C42\u524D",
  "settings.customPromptPlaceholder": "\u4F60\u6B63\u5728\u5E2E\u52A9\u7F16\u8F91 Markdown \u7B14\u8BB0...",
  "settings.preserveCursor": "\u4FDD\u6301\u5149\u6807\u4F4D\u7F6E",
  "settings.preserveCursorDesc": "\u5E94\u7528\u66F4\u6539\u540E\u5C1D\u8BD5\u4FDD\u6301\u5149\u6807\u4F4D\u7F6E",
  "settings.autoAcceptChanges": "\u81EA\u52A8\u63A5\u53D7\u66F4\u6539",
  "settings.autoAcceptChangesDesc": "\u81EA\u52A8\u5E94\u7528\u66F4\u6539\u800C\u4E0D\u663E\u793A\u9884\u89C8\uFF08\u8BF7\u8C28\u614E\u4F7F\u7528\uFF01\uFF09",
  "settings.model": "\u6A21\u578B",
  "settings.modelDesc": "\u9009\u62E9\u8981\u4F7F\u7528\u7684 Claude \u6A21\u578B\uFF1ASonnet\uFF08\u5E73\u8861\uFF09\u3001Opus\uFF08\u6700\u5F3A\u5927\uFF09\u6216 Haiku\uFF08\u6700\u5FEB\uFF09\u3002\u7559\u7A7A\u4F7F\u7528\u9ED8\u8BA4\u5B50\u4EE3\u7406\u6A21\u578B\u3002",
  "settings.modelDefault": "\u9ED8\u8BA4\uFF08\u5B50\u4EE3\u7406\u6A21\u578B\uFF09",
  "settings.modelSonnet": "Sonnet\uFF08\u5E73\u8861\uFF09",
  "settings.modelOpus": "Opus\uFF08\u6700\u5F3A\u5927\uFF09",
  "settings.modelHaiku": "Haiku\uFF08\u6700\u5FEB\uFF09",
  "settings.vaultAccess": "\u5141\u8BB8\u4ED3\u5E93\u8303\u56F4\u8BBF\u95EE",
  "settings.vaultAccessDesc": "\u5141\u8BB8 Claude \u8BFB\u53D6/\u641C\u7D22\u4ED3\u5E93\u4E2D\u7684\u5176\u4ED6\u6587\u4EF6\uFF08\u4E0D\u4EC5\u4EC5\u662F\u5F53\u524D\u7B14\u8BB0\uFF09",
  "settings.permissionlessMode": "\u542F\u7528\u65E0\u6743\u9650\u6A21\u5F0F",
  "settings.permissionlessModeDesc": "\u5141\u8BB8 Claude \u6267\u884C\u64CD\u4F5C\u800C\u65E0\u9700\u6BCF\u6B21\u8BF7\u6C42\u6743\u9650\uFF08\u8BF7\u8C28\u614E\u4F7F\u7528\uFF01Claude \u5C06\u62E5\u6709\u5B8C\u5168\u63A7\u5236\u6743\uFF09",
  "settings.timeout": "\u8D85\u65F6\u65F6\u95F4\uFF08\u79D2\uFF09",
  "settings.timeoutDesc": "\u7B49\u5F85 Claude Code \u54CD\u5E94\u7684\u6700\u957F\u65F6\u95F4\uFF080 = \u65E0\u8D85\u65F6\uFF09",
  "settings.customApiConfig": "\u81EA\u5B9A\u4E49 API \u914D\u7F6E",
  "settings.customApiConfigDesc": "\u4E3A Claude \u4E0D\u53EF\u76F4\u63A5\u8BBF\u95EE\u7684\u5730\u533A\u914D\u7F6E\u81EA\u5B9A\u4E49 API \u7AEF\u70B9\u3002\u7559\u7A7A\u4F7F\u7528\u9ED8\u8BA4\u8BBE\u7F6E\u3002",
  "settings.apiBaseUrl": "API \u57FA\u7840 URL",
  "settings.apiBaseUrlDesc": "\u81EA\u5B9A\u4E49 API \u7AEF\u70B9 URL\uFF08\u4F8B\u5982\uFF1Ahttps://api.kimi.com/coding/\uFF09",
  "settings.apiAuthToken": "API \u8BA4\u8BC1\u4EE4\u724C",
  "settings.apiAuthTokenDesc": "API \u7AEF\u70B9\u7684\u81EA\u5B9A\u4E49\u8BA4\u8BC1\u4EE4\u724C",
  "settings.apiAuthTokenPlaceholder": "\u8F93\u5165\u60A8\u7684 API \u4EE4\u724C",
  "settings.customModel": "\u81EA\u5B9A\u4E49\u6A21\u578B",
  "settings.customModelDesc": "\u8981\u4F7F\u7528\u7684\u81EA\u5B9A\u4E49\u6A21\u578B\u540D\u79F0\uFF08\u4F8B\u5982\uFF1Akimi-for-coding\uFF09\u3002\u5C06\u8986\u76D6\u4E0A\u9762\u7684\u6A21\u578B\u4E0B\u62C9\u9009\u9879\u3002",
  "settings.customSmallModel": "\u81EA\u5B9A\u4E49\u5C0F\u578B/\u5FEB\u901F\u6A21\u578B",
  "settings.customSmallModelDesc": "\u7528\u4E8E\u5FEB\u901F\u64CD\u4F5C\u7684\u81EA\u5B9A\u4E49\u6A21\u578B\u540D\u79F0\uFF08\u4F8B\u5982\uFF1Akimi-for-coding\uFF09",
  "settings.language": "\u8BED\u8A00",
  "settings.languageDesc": "\u9009\u62E9\u754C\u9762\u8BED\u8A00"
};

// src/i18n/locales/es.ts
var es = {
  // Header
  "header.title": "Asistente Claude Code",
  "header.noNoteSelected": "ninguna nota seleccionada",
  // Input Section
  "input.label": "Tus instrucciones:",
  "input.placeholder": 'ej., "Agregar m\xE1s ejemplos a esta secci\xF3n" o "Reorganizar con mejores encabezados" (Enter para enviar, Ctrl+Enter para nueva l\xEDnea)',
  "input.conversationalMode": "modo conversacional (sin edici\xF3n de archivos)",
  "input.conversationalModeTooltip": "Chatea con Claude sin modificar ning\xFAn archivo",
  "input.selectedTextOnly": "Editar solo texto seleccionado",
  "input.autoAccept": "Aceptar cambios autom\xE1ticamente",
  "input.modelLabel": "Modelo:",
  "input.modelDefault": "Predeterminado",
  "input.runButton": "Ejecutar Claude Code",
  "input.runningButton": "Ejecutando...",
  "input.cancelButton": "Cancelar",
  // Result Section
  "result.title": "Resultado",
  // Output Section
  "output.title": "Salida",
  // Preview Section
  "preview.title": "Vista previa",
  "preview.tabRaw": "Sin formato",
  "preview.tabDiff": "Diferencias",
  "preview.tabRendered": "Renderizado",
  "preview.originalChars": "Original:",
  "preview.modifiedChars": "Modificado:",
  "preview.chars": "caracteres",
  "preview.applyButton": "aplicar cambios",
  "preview.rejectButton": "rechazar",
  // History Section
  "history.title": "Historial",
  "history.clearButton": "Limpiar",
  // Agent Section
  "agent.planTitle": "plan",
  "agent.activityTitle": "Actividad",
  "agent.noPlan": "A\xFAn no se ha creado un plan",
  // Todo Status
  "todo.pending": "pendiente",
  "todo.inProgress": "en progreso",
  "todo.completed": "completado",
  // Interactive Prompt
  "interactive.header": "Claude est\xE1 solicitando confirmaci\xF3n",
  "interactive.yesButton": "s\xED",
  "interactive.noButton": "no",
  "interactive.customPlaceholder": "O escribe una respuesta personalizada...",
  // Permission Approval
  "permission.header": "permiso requerido",
  "permission.message": "Claude est\xE1 solicitando permiso para ejecutar acciones.",
  "permission.approveButton": "aprobar y continuar",
  "permission.denyButton": "denegar",
  // Status Messages
  "status.processing": "Claude est\xE1 procesando",
  "status.autoApplying": "Aplicando cambios autom\xE1ticamente...",
  "status.runningAuthorized": "Ejecutando tareas autorizadas",
  "status.runningInBackground": "Ejecutando en segundo plano...",
  "status.failed": "Fall\xF3 - ver error abajo",
  // Notifications
  "notice.alreadyProcessing": "Ya se est\xE1 procesando una solicitud. Por favor espera.",
  "notice.enterPrompt": "Por favor ingresa una instrucci\xF3n",
  "notice.noActiveNote": "No se encontr\xF3 una nota activa, por favor abre una nota Markdown primero",
  "notice.noEditor": "No se encontr\xF3 un editor Markdown, aseg\xFArate de tener una nota abierta",
  "notice.noVaultPath": "No se pudo determinar la ruta de la b\xF3veda",
  "notice.completed": "Claude Code completado",
  "notice.completedNoChanges": "Claude Code completado (sin cambios en archivos)",
  "notice.changesApplied": "cambios aplicados autom\xE1ticamente",
  "notice.changesAppliedSuccess": "cambios aplicados exitosamente",
  "notice.failedApplyChanges": "fall\xF3 al aplicar cambios",
  "notice.changesRejected": "Cambios rechazados",
  "notice.cancelled": "Cancelado",
  "notice.permissionRequest": "Claude est\xE1 solicitando permiso - por favor aprueba o deniega",
  "notice.permissionDenied": "Permiso denegado - Claude no proceder\xE1",
  "notice.noChangesToApply": "no hay cambios para aplicar",
  "notice.noActiveFile": "no hay archivo activo",
  "notice.historyRestored": "Elemento del historial restaurado",
  "notice.historyRestoredWithChanges": "Elemento del historial restaurado con cambios propuestos",
  "notice.historyCleared": "Historial limpiado",
  // Diff View
  "diff.original": "Original",
  "diff.modified": "Modificado",
  // Result Renderer
  "result.directAnswer": "Respuesta directa",
  "result.additionalContext": "Contexto adicional",
  "result.tokens": "tokens",
  "result.tokensIn": "entrada",
  "result.tokensOut": "salida",
  // Preview Stats
  "preview.originalLabel": "Original:",
  "preview.modifiedLabel": "Modificado:",
  "preview.charsLabel": "caracteres",
  // Misc
  "misc.noPendingRequest": "No se encontr\xF3 solicitud pendiente",
  "misc.languageChanged": "Idioma cambiado. Algunos elementos de la interfaz se actualizar\xE1n al recargar.",
  "misc.testFailed": "Prueba de Claude Code fallida",
  // Settings
  "settings.autoDetectPath": "Auto-detectar ruta de Claude Code",
  "settings.autoDetectPathDesc": "Detectar autom\xE1ticamente la ubicaci\xF3n del ejecutable de Claude Code",
  "settings.executablePath": "Ruta del ejecutable de Claude Code",
  "settings.executablePathDesc": "Ruta completa al ejecutable de Claude Code (ej., /usr/local/bin/claude)",
  "settings.testInstallation": "Probar instalaci\xF3n de Claude Code",
  "settings.testInstallationDesc": "Verificar que Claude Code sea accesible y funcione",
  "settings.testButton": "Probar",
  "settings.testWorking": "\xA1funcionando!",
  "settings.testFailed": "fall\xF3",
  "settings.customPrompt": "Prompt de sistema personalizado",
  "settings.customPromptDesc": "Prompt de sistema personalizado opcional para agregar a todas las solicitudes",
  "settings.customPromptPlaceholder": "Est\xE1s ayudando a editar notas markdown...",
  "settings.preserveCursor": "Preservar posici\xF3n del cursor",
  "settings.preserveCursorDesc": "Intentar mantener la posici\xF3n del cursor despu\xE9s de aplicar cambios",
  "settings.autoAcceptChanges": "Aceptar cambios autom\xE1ticamente",
  "settings.autoAcceptChangesDesc": "Aplicar cambios autom\xE1ticamente sin mostrar vista previa (\xA1usar con precauci\xF3n!)",
  "settings.model": "Modelo",
  "settings.modelDesc": "Selecciona el modelo de Claude a usar: Sonnet (equilibrado), Opus (m\xE1s capaz), o Haiku (m\xE1s r\xE1pido). Dejar vac\xEDo para usar el modelo de subagente predeterminado.",
  "settings.modelDefault": "Predeterminado (modelo subagente)",
  "settings.modelSonnet": "Sonnet (equilibrado)",
  "settings.modelOpus": "Opus (m\xE1s capaz)",
  "settings.modelHaiku": "Haiku (m\xE1s r\xE1pido)",
  "settings.vaultAccess": "Permitir acceso a toda la b\xF3veda",
  "settings.vaultAccessDesc": "Permitir a Claude leer/buscar otros archivos en tu b\xF3veda (no solo la nota actual)",
  "settings.permissionlessMode": "Habilitar modo sin permisos",
  "settings.permissionlessModeDesc": "Permitir a Claude ejecutar acciones sin pedir permiso cada vez (\xA1usar con precauci\xF3n! Claude tendr\xE1 control total)",
  "settings.timeout": "Tiempo de espera (segundos)",
  "settings.timeoutDesc": "Tiempo m\xE1ximo de espera para la respuesta de Claude Code (0 = sin l\xEDmite)",
  "settings.customApiConfig": "Configuraci\xF3n de API personalizada",
  "settings.customApiConfigDesc": "Configurar endpoints de API personalizados para regiones donde Claude no est\xE1 disponible directamente. Dejar vac\xEDo para usar la configuraci\xF3n predeterminada.",
  "settings.apiBaseUrl": "URL base de API",
  "settings.apiBaseUrlDesc": "URL del endpoint de API personalizado (ej., https://api.kimi.com/coding/)",
  "settings.apiAuthToken": "Token de autenticaci\xF3n de API",
  "settings.apiAuthTokenDesc": "Token de autenticaci\xF3n personalizado para el endpoint de API",
  "settings.apiAuthTokenPlaceholder": "Ingresa tu token de API",
  "settings.customModel": "Modelo personalizado",
  "settings.customModelDesc": "Nombre del modelo personalizado a usar (ej., kimi-for-coding). Sobrescribe el selector de modelo anterior.",
  "settings.customSmallModel": "Modelo peque\xF1o/r\xE1pido personalizado",
  "settings.customSmallModelDesc": "Nombre del modelo personalizado para operaciones r\xE1pidas (ej., kimi-for-coding)",
  "settings.language": "Idioma",
  "settings.languageDesc": "Seleccionar idioma de la interfaz"
};

// src/i18n/locales/de.ts
var de = {
  // Header
  "header.title": "Claude Code Assistent",
  "header.noNoteSelected": "keine Notiz ausgew\xE4hlt",
  // Input Section
  "input.label": "Deine Anweisungen:",
  "input.placeholder": 'z.B. "F\xFCge mehr Beispiele zu diesem Abschnitt hinzu" oder "Reorganisiere mit besseren \xDCberschriften" (Enter zum Senden, Strg+Enter f\xFCr neue Zeile)',
  "input.conversationalMode": "Konversationsmodus (keine Datei\xE4nderungen)",
  "input.conversationalModeTooltip": "Mit Claude chatten, ohne Dateien zu \xE4ndern",
  "input.selectedTextOnly": "Nur markierten Text bearbeiten",
  "input.autoAccept": "\xC4nderungen automatisch \xFCbernehmen",
  "input.modelLabel": "Modell:",
  "input.modelDefault": "Standard",
  "input.runButton": "Claude Code ausf\xFChren",
  "input.runningButton": "L\xE4uft...",
  "input.cancelButton": "Abbrechen",
  // Result Section
  "result.title": "Ergebnis",
  // Output Section
  "output.title": "Ausgabe",
  // Preview Section
  "preview.title": "Vorschau",
  "preview.tabRaw": "Roh",
  "preview.tabDiff": "Diff",
  "preview.tabRendered": "Gerendert",
  "preview.originalChars": "Original:",
  "preview.modifiedChars": "Ge\xE4ndert:",
  "preview.chars": "Zeichen",
  "preview.applyButton": "\xC4nderungen \xFCbernehmen",
  "preview.rejectButton": "Ablehnen",
  // History Section
  "history.title": "Verlauf",
  "history.clearButton": "L\xF6schen",
  // Agent Section
  "agent.planTitle": "Plan",
  "agent.activityTitle": "Aktivit\xE4t",
  "agent.noPlan": "Noch kein Plan erstellt",
  // Todo Status
  "todo.pending": "Ausstehend",
  "todo.inProgress": "In Bearbeitung",
  "todo.completed": "Abgeschlossen",
  // Interactive Prompt
  "interactive.header": "Claude bittet um Best\xE4tigung",
  "interactive.yesButton": "Ja",
  "interactive.noButton": "Nein",
  "interactive.customPlaceholder": "Oder eine eigene Antwort eingeben...",
  // Permission Approval
  "permission.header": "Berechtigung erforderlich",
  "permission.message": "Claude bittet um Erlaubnis, Aktionen auszuf\xFChren.",
  "permission.approveButton": "Genehmigen & fortfahren",
  "permission.denyButton": "Ablehnen",
  // Status Messages
  "status.processing": "Claude verarbeitet",
  "status.autoApplying": "\xC4nderungen werden automatisch \xFCbernommen...",
  "status.runningAuthorized": "F\xFChre autorisierte Aufgaben aus",
  "status.runningInBackground": "L\xE4uft im Hintergrund...",
  "status.failed": "Fehlgeschlagen - siehe Fehler unten",
  // Notifications
  "notice.alreadyProcessing": "Eine Anfrage wird bereits verarbeitet. Bitte warten.",
  "notice.enterPrompt": "Bitte gib eine Anweisung ein",
  "notice.noActiveNote": "Keine aktive Notiz gefunden, bitte \xF6ffne zuerst eine Markdown-Notiz",
  "notice.noEditor": "Kein Markdown-Editor gefunden, bitte stelle sicher, dass eine Notiz ge\xF6ffnet ist",
  "notice.noVaultPath": "Vault-Pfad konnte nicht ermittelt werden",
  "notice.completed": "Claude Code abgeschlossen",
  "notice.completedNoChanges": "Claude Code abgeschlossen (keine Datei\xE4nderungen)",
  "notice.changesApplied": "\xC4nderungen automatisch \xFCbernommen",
  "notice.changesAppliedSuccess": "\xC4nderungen erfolgreich \xFCbernommen",
  "notice.failedApplyChanges": "\xC4nderungen konnten nicht \xFCbernommen werden",
  "notice.changesRejected": "\xC4nderungen abgelehnt",
  "notice.cancelled": "Abgebrochen",
  "notice.permissionRequest": "Claude bittet um Berechtigung - bitte genehmigen oder ablehnen",
  "notice.permissionDenied": "Berechtigung verweigert - Claude wird nicht fortfahren",
  "notice.noChangesToApply": "Keine \xC4nderungen zum \xDCbernehmen",
  "notice.noActiveFile": "Keine aktive Datei",
  "notice.historyRestored": "Verlaufseintrag wiederhergestellt",
  "notice.historyRestoredWithChanges": "Verlaufseintrag mit vorgeschlagenen \xC4nderungen wiederhergestellt",
  "notice.historyCleared": "Verlauf gel\xF6scht",
  // Diff View
  "diff.original": "Original",
  "diff.modified": "Ge\xE4ndert",
  // Result Renderer
  "result.directAnswer": "Direkte Antwort",
  "result.additionalContext": "Zus\xE4tzlicher Kontext",
  "result.tokens": "Tokens",
  "result.tokensIn": "Eingabe",
  "result.tokensOut": "Ausgabe",
  // Preview Stats
  "preview.originalLabel": "Original:",
  "preview.modifiedLabel": "Ge\xE4ndert:",
  "preview.charsLabel": "Zeichen",
  // Misc
  "misc.noPendingRequest": "Keine ausstehende Anfrage gefunden",
  "misc.languageChanged": "Sprache ge\xE4ndert. Einige UI-Elemente werden nach dem Neuladen aktualisiert.",
  "misc.testFailed": "Claude Code Test fehlgeschlagen",
  // Settings
  "settings.autoDetectPath": "Claude Code Pfad automatisch erkennen",
  "settings.autoDetectPathDesc": "Den Speicherort der Claude Code Anwendung automatisch erkennen",
  "settings.executablePath": "Claude Code Anwendungspfad",
  "settings.executablePathDesc": "Vollst\xE4ndiger Pfad zur Claude Code Anwendung (z.B. /usr/local/bin/claude)",
  "settings.testInstallation": "Claude Code Installation testen",
  "settings.testInstallationDesc": "\xDCberpr\xFCfen, ob Claude Code erreichbar ist und funktioniert",
  "settings.testButton": "Testen",
  "settings.testWorking": "Funktioniert!",
  "settings.testFailed": "Fehlgeschlagen",
  "settings.customPrompt": "Benutzerdefinierte Systemanweisung",
  "settings.customPromptDesc": "Optionale benutzerdefinierte Systemanweisung, die allen Anfragen vorangestellt wird",
  "settings.customPromptPlaceholder": "Du hilfst beim Bearbeiten von Markdown-Notizen...",
  "settings.preserveCursor": "Cursorposition beibehalten",
  "settings.preserveCursorDesc": "Versuchen, die Cursorposition nach dem \xDCbernehmen von \xC4nderungen beizubehalten",
  "settings.autoAcceptChanges": "\xC4nderungen automatisch \xFCbernehmen",
  "settings.autoAcceptChangesDesc": "\xC4nderungen automatisch \xFCbernehmen, ohne Vorschau anzuzeigen (mit Vorsicht verwenden!)",
  "settings.model": "Modell",
  "settings.modelDesc": "W\xE4hle das Claude-Modell: Sonnet (ausgewogen), Opus (leistungsf\xE4higste), oder Haiku (schnellste). Leer lassen f\xFCr Standard-Subagent-Modell.",
  "settings.modelDefault": "Standard (Subagent-Modell)",
  "settings.modelSonnet": "Sonnet (ausgewogen)",
  "settings.modelOpus": "Opus (leistungsf\xE4higste)",
  "settings.modelHaiku": "Haiku (schnellste)",
  "settings.vaultAccess": "Vault-weiten Zugriff erlauben",
  "settings.vaultAccessDesc": "Claude erlauben, andere Dateien im Vault zu lesen/durchsuchen (nicht nur die aktuelle Notiz)",
  "settings.permissionlessMode": "Berechtigungsfreien Modus aktivieren",
  "settings.permissionlessModeDesc": "Claude erlauben, Aktionen auszuf\xFChren, ohne jedes Mal um Erlaubnis zu fragen (mit Vorsicht verwenden! Claude hat volle Kontrolle)",
  "settings.timeout": "Zeitlimit (Sekunden)",
  "settings.timeoutDesc": "Maximale Wartezeit auf Claude Code Antwort (0 = kein Zeitlimit)",
  "settings.customApiConfig": "Benutzerdefinierte API-Konfiguration",
  "settings.customApiConfigDesc": "Benutzerdefinierte API-Endpunkte f\xFCr Regionen konfigurieren, in denen Claude nicht direkt verf\xFCgbar ist. Leer lassen f\xFCr Standardeinstellungen.",
  "settings.apiBaseUrl": "API Basis-URL",
  "settings.apiBaseUrlDesc": "Benutzerdefinierte API-Endpunkt-URL (z.B. https://api.kimi.com/coding/)",
  "settings.apiAuthToken": "API Auth-Token",
  "settings.apiAuthTokenDesc": "Benutzerdefiniertes Authentifizierungstoken f\xFCr den API-Endpunkt",
  "settings.apiAuthTokenPlaceholder": "Gib dein API-Token ein",
  "settings.customModel": "Benutzerdefiniertes Modell",
  "settings.customModelDesc": "Benutzerdefinierter Modellname (z.B. kimi-for-coding). \xDCberschreibt die Modellauswahl oben.",
  "settings.customSmallModel": "Benutzerdefiniertes kleines/schnelles Modell",
  "settings.customSmallModelDesc": "Benutzerdefinierter Modellname f\xFCr schnelle Operationen (z.B. kimi-for-coding)",
  "settings.language": "Sprache",
  "settings.languageDesc": "Oberfl\xE4chensprache ausw\xE4hlen"
};

// src/i18n/locales/pt.ts
var pt = {
  // Header
  "header.title": "Assistente Claude Code",
  "header.noNoteSelected": "nenhuma nota selecionada",
  // Input Section
  "input.label": "Suas instru\xE7\xF5es:",
  "input.placeholder": 'ex., "Adicione mais exemplos a esta se\xE7\xE3o" ou "Reorganize com melhores t\xEDtulos" (Enter para enviar, Ctrl+Enter para nova linha)',
  "input.conversationalMode": "modo conversacional (sem edi\xE7\xE3o de arquivos)",
  "input.conversationalModeTooltip": "Converse com Claude sem modificar arquivos",
  "input.selectedTextOnly": "Editar apenas texto selecionado",
  "input.autoAccept": "Aceitar altera\xE7\xF5es automaticamente",
  "input.modelLabel": "Modelo:",
  "input.modelDefault": "Padr\xE3o",
  "input.runButton": "Executar Claude Code",
  "input.runningButton": "Executando...",
  "input.cancelButton": "Cancelar",
  // Result Section
  "result.title": "Resultado",
  // Output Section
  "output.title": "Sa\xEDda",
  // Preview Section
  "preview.title": "Visualiza\xE7\xE3o",
  "preview.tabRaw": "Bruto",
  "preview.tabDiff": "Diferen\xE7as",
  "preview.tabRendered": "Renderizado",
  "preview.originalChars": "Original:",
  "preview.modifiedChars": "Modificado:",
  "preview.chars": "caracteres",
  "preview.applyButton": "aplicar altera\xE7\xF5es",
  "preview.rejectButton": "rejeitar",
  // History Section
  "history.title": "Hist\xF3rico",
  "history.clearButton": "Limpar",
  // Agent Section
  "agent.planTitle": "plano",
  "agent.activityTitle": "Atividade",
  "agent.noPlan": "Nenhum plano criado ainda",
  // Todo Status
  "todo.pending": "pendente",
  "todo.inProgress": "em progresso",
  "todo.completed": "conclu\xEDdo",
  // Interactive Prompt
  "interactive.header": "Claude est\xE1 pedindo confirma\xE7\xE3o",
  "interactive.yesButton": "sim",
  "interactive.noButton": "n\xE3o",
  "interactive.customPlaceholder": "Ou digite uma resposta personalizada...",
  // Permission Approval
  "permission.header": "permiss\xE3o necess\xE1ria",
  "permission.message": "Claude est\xE1 solicitando permiss\xE3o para executar a\xE7\xF5es.",
  "permission.approveButton": "aprovar e continuar",
  "permission.denyButton": "negar",
  // Status Messages
  "status.processing": "Claude est\xE1 processando",
  "status.autoApplying": "Aplicando altera\xE7\xF5es automaticamente...",
  "status.runningAuthorized": "Executando tarefas autorizadas",
  "status.runningInBackground": "Executando em segundo plano...",
  "status.failed": "Falhou - veja o erro abaixo",
  // Notifications
  "notice.alreadyProcessing": "J\xE1 est\xE1 processando uma solicita\xE7\xE3o. Por favor, aguarde.",
  "notice.enterPrompt": "Por favor, insira um prompt",
  "notice.noActiveNote": "Nenhuma nota ativa encontrada, por favor abra uma nota Markdown primeiro",
  "notice.noEditor": "Nenhum editor Markdown encontrado, certifique-se de que voc\xEA tem uma nota aberta",
  "notice.noVaultPath": "N\xE3o foi poss\xEDvel determinar o caminho do vault",
  "notice.completed": "Claude Code conclu\xEDdo",
  "notice.completedNoChanges": "Claude Code conclu\xEDdo (sem altera\xE7\xF5es de arquivo)",
  "notice.changesApplied": "altera\xE7\xF5es aplicadas automaticamente",
  "notice.changesAppliedSuccess": "altera\xE7\xF5es aplicadas com sucesso",
  "notice.failedApplyChanges": "falha ao aplicar altera\xE7\xF5es",
  "notice.changesRejected": "Altera\xE7\xF5es rejeitadas",
  "notice.cancelled": "Cancelado",
  "notice.permissionRequest": "Claude est\xE1 solicitando permiss\xE3o - por favor aprove ou negue",
  "notice.permissionDenied": "Permiss\xE3o negada - Claude n\xE3o prosseguir\xE1",
  "notice.noChangesToApply": "nenhuma altera\xE7\xE3o para aplicar",
  "notice.noActiveFile": "nenhum arquivo ativo",
  "notice.historyRestored": "Item do hist\xF3rico restaurado",
  "notice.historyRestoredWithChanges": "Item do hist\xF3rico restaurado com altera\xE7\xF5es propostas",
  "notice.historyCleared": "Hist\xF3rico limpo",
  // Diff View
  "diff.original": "Original",
  "diff.modified": "Modificado",
  // Result Renderer
  "result.directAnswer": "Resposta direta",
  "result.additionalContext": "Contexto adicional",
  "result.tokens": "tokens",
  "result.tokensIn": "entrada",
  "result.tokensOut": "sa\xEDda",
  // Preview Stats
  "preview.originalLabel": "Original:",
  "preview.modifiedLabel": "Modificado:",
  "preview.charsLabel": "caracteres",
  // Misc
  "misc.noPendingRequest": "Nenhuma solicita\xE7\xE3o pendente encontrada",
  "misc.languageChanged": "Idioma alterado. Alguns elementos da interface ser\xE3o atualizados ao recarregar.",
  "misc.testFailed": "Teste do Claude Code falhou",
  // Settings
  "settings.autoDetectPath": "Detectar caminho do Claude Code automaticamente",
  "settings.autoDetectPathDesc": "Detectar automaticamente a localiza\xE7\xE3o do execut\xE1vel do Claude Code",
  "settings.executablePath": "Caminho do execut\xE1vel do Claude Code",
  "settings.executablePathDesc": "Caminho completo para o execut\xE1vel do Claude Code (ex., /usr/local/bin/claude)",
  "settings.testInstallation": "Testar instala\xE7\xE3o do Claude Code",
  "settings.testInstallationDesc": "Verificar se o Claude Code est\xE1 acess\xEDvel e funcionando",
  "settings.testButton": "Testar",
  "settings.testWorking": "funcionando!",
  "settings.testFailed": "falhou",
  "settings.customPrompt": "Prompt de sistema personalizado",
  "settings.customPromptDesc": "Prompt de sistema personalizado opcional para adicionar a todas as solicita\xE7\xF5es",
  "settings.customPromptPlaceholder": "Voc\xEA est\xE1 ajudando a editar notas markdown...",
  "settings.preserveCursor": "Preservar posi\xE7\xE3o do cursor",
  "settings.preserveCursorDesc": "Tentar manter a posi\xE7\xE3o do cursor ap\xF3s aplicar altera\xE7\xF5es",
  "settings.autoAcceptChanges": "Aceitar altera\xE7\xF5es automaticamente",
  "settings.autoAcceptChangesDesc": "Aplicar altera\xE7\xF5es automaticamente sem mostrar visualiza\xE7\xE3o (use com cautela!)",
  "settings.model": "Modelo",
  "settings.modelDesc": "Selecione o modelo Claude a usar: Sonnet (equilibrado), Opus (mais capaz), ou Haiku (mais r\xE1pido). Deixe vazio para usar o modelo subagent padr\xE3o.",
  "settings.modelDefault": "Padr\xE3o (modelo subagent)",
  "settings.modelSonnet": "Sonnet (equilibrado)",
  "settings.modelOpus": "Opus (mais capaz)",
  "settings.modelHaiku": "Haiku (mais r\xE1pido)",
  "settings.vaultAccess": "Permitir acesso ao vault completo",
  "settings.vaultAccessDesc": "Permitir que Claude leia/pesquise outros arquivos no seu vault (n\xE3o apenas a nota atual)",
  "settings.permissionlessMode": "Habilitar modo sem permiss\xF5es",
  "settings.permissionlessModeDesc": "Permitir que Claude execute a\xE7\xF5es sem pedir permiss\xE3o a cada vez (use com cautela! Claude ter\xE1 controle total)",
  "settings.timeout": "Tempo limite (segundos)",
  "settings.timeoutDesc": "Tempo m\xE1ximo para aguardar resposta do Claude Code (0 = sem limite)",
  "settings.customApiConfig": "Configura\xE7\xE3o de API personalizada",
  "settings.customApiConfigDesc": "Configure endpoints de API personalizados para regi\xF5es onde Claude n\xE3o est\xE1 dispon\xEDvel diretamente. Deixe vazio para usar configura\xE7\xF5es padr\xE3o.",
  "settings.apiBaseUrl": "URL base da API",
  "settings.apiBaseUrlDesc": "URL do endpoint de API personalizado (ex., https://api.kimi.com/coding/)",
  "settings.apiAuthToken": "Token de autentica\xE7\xE3o da API",
  "settings.apiAuthTokenDesc": "Token de autentica\xE7\xE3o personalizado para o endpoint da API",
  "settings.apiAuthTokenPlaceholder": "Insira seu token de API",
  "settings.customModel": "Modelo personalizado",
  "settings.customModelDesc": "Nome do modelo personalizado a usar (ex., kimi-for-coding). Substitui a sele\xE7\xE3o de modelo acima.",
  "settings.customSmallModel": "Modelo pequeno/r\xE1pido personalizado",
  "settings.customSmallModelDesc": "Nome do modelo personalizado para opera\xE7\xF5es r\xE1pidas (ex., kimi-for-coding)",
  "settings.language": "Idioma",
  "settings.languageDesc": "Selecione o idioma da interface"
};

// src/i18n/index.ts
var translations = {
  en,
  zh,
  es,
  de,
  pt
};
var currentLocale = "en";
function setLocale(locale) {
  if (translations[locale]) {
    currentLocale = locale;
  } else {
    console.warn(`[i18n] Unknown locale: ${locale}, falling back to 'en'`);
    currentLocale = "en";
  }
}
function getLocale() {
  return currentLocale;
}
function getAvailableLocales() {
  return [
    { code: "en", name: "English" },
    { code: "zh", name: "\u4E2D\u6587 (\u7B80\u4F53)" },
    { code: "es", name: "Espa\xF1ol" },
    { code: "de", name: "Deutsch" },
    { code: "pt", name: "Portugu\xEAs" }
  ];
}
function t(key, params) {
  var _a;
  let text = ((_a = translations[currentLocale]) == null ? void 0 : _a[key]) || translations["en"][key] || key;
  if (params) {
    Object.entries(params).forEach(([paramKey, value]) => {
      text = text.replace(new RegExp(`\\{${paramKey}\\}`, "g"), String(value));
    });
  }
  return text;
}
function initI18n(preferredLocale) {
  var _a;
  if (preferredLocale && translations[preferredLocale]) {
    setLocale(preferredLocale);
    return;
  }
  const systemLocale = ((_a = navigator.language) == null ? void 0 : _a.toLowerCase()) || "";
  if (systemLocale.startsWith("zh")) {
    setLocale("zh");
  } else if (systemLocale.startsWith("es")) {
    setLocale("es");
  } else if (systemLocale.startsWith("de")) {
    setLocale("de");
  } else if (systemLocale.startsWith("pt")) {
    setLocale("pt");
  } else {
    setLocale("en");
  }
}

// src/ui/ui-builder.ts
var UIBuilder = class {
  /**
   * Build the header section
   */
  static buildHeader(container) {
    const header = container.createEl("div", { cls: "claude-code-header" });
    const headerTitle = header.createEl("div", { cls: "claude-code-header-title" });
    headerTitle.createEl("h4", { text: t("header.title") });
    const currentNoteLabel = header.createEl("div", { cls: "claude-code-current-note" });
    return currentNoteLabel;
  }
  /**
   * Build the input section with prompt textarea and options
   */
  static buildInputSection(container, autoAcceptDefault, onRun, onCancel) {
    const inputSection = container.createEl("div", { cls: "claude-code-input-section" });
    inputSection.createEl("label", { text: t("input.label") });
    const promptInput = inputSection.createEl("textarea", {
      cls: "claude-code-prompt-input",
      attr: {
        placeholder: t("input.placeholder")
      }
    });
    promptInput.rows = 4;
    const optionsDiv = inputSection.createEl("div", { cls: "claude-code-options" });
    const conversationalLabel = optionsDiv.createEl("label", { cls: "claude-code-checkbox-label" });
    const conversationalModeCheckbox = conversationalLabel.createEl("input", { type: "checkbox" });
    conversationalLabel.appendText(" " + t("input.conversationalMode"));
    conversationalLabel.title = t("input.conversationalModeTooltip");
    const selectedTextLabel = optionsDiv.createEl("label", { cls: "claude-code-checkbox-label" });
    const selectedTextOnlyCheckbox = selectedTextLabel.createEl("input", { type: "checkbox" });
    selectedTextLabel.appendText(" " + t("input.selectedTextOnly"));
    const autoAcceptLabel = optionsDiv.createEl("label", { cls: "claude-code-checkbox-label" });
    const autoAcceptCheckbox = autoAcceptLabel.createEl("input", { type: "checkbox" });
    autoAcceptCheckbox.checked = autoAcceptDefault;
    autoAcceptLabel.appendText(" " + t("input.autoAccept"));
    const modelSelectContainer = optionsDiv.createEl("div", { cls: "claude-code-model-select" });
    modelSelectContainer.createEl("label", { text: t("input.modelLabel") + " ", cls: "claude-code-model-label" });
    const modelSelect = modelSelectContainer.createEl("select", { cls: "claude-code-model-dropdown" });
    modelSelect.createEl("option", { value: "", text: t("input.modelDefault") });
    modelSelect.createEl("option", { value: "sonnet", text: "Sonnet" });
    modelSelect.createEl("option", { value: "opus", text: "Opus" });
    modelSelect.createEl("option", { value: "haiku", text: "Haiku" });
    const buttonContainer = inputSection.createEl("div", { cls: "claude-code-button-container" });
    const runButton = buttonContainer.createEl("button", {
      cls: "mod-cta",
      text: t("input.runButton")
    });
    runButton.addEventListener("click", onRun);
    const cancelButton = buttonContainer.createEl("button", {
      text: t("input.cancelButton"),
      cls: "claude-code-cancel-button claude-code-hidden"
    });
    cancelButton.addEventListener("click", onCancel);
    return {
      promptInput,
      selectedTextOnlyCheckbox,
      autoAcceptCheckbox,
      conversationalModeCheckbox,
      modelSelect,
      runButton,
      cancelButton
    };
  }
  /**
   * Build the combined agent section (plan + activity in two columns)
   */
  static buildAgentSection(container) {
    const agentContainer = container.createEl("div", {
      cls: "claude-code-agent-container claude-code-hidden"
    });
    agentContainer.id = "claude-code-agent-container";
    const planColumn = agentContainer.createEl("div", { cls: "claude-code-agent-column claude-code-plan-column claude-code-hidden" });
    const planHeader = planColumn.createEl("div", { cls: "claude-code-agent-column-header" });
    planHeader.createEl("span", { text: "\u{1F4CB} " + t("agent.planTitle") });
    planColumn.createEl("div", {
      cls: "claude-code-todo-list claude-code-hidden",
      attr: { id: "claude-code-todo-list" }
    });
    const emptyPlanMessage = planColumn.createEl("div", {
      cls: "claude-code-empty-message claude-code-hidden",
      text: t("agent.noPlan")
    });
    emptyPlanMessage.id = "claude-code-empty-plan";
    const activityColumn = agentContainer.createEl("div", { cls: "claude-code-agent-column claude-code-activity-column claude-code-hidden" });
    const activityHeader = activityColumn.createEl("div", { cls: "claude-code-agent-column-header collapsible-header" });
    const activityTitle = activityHeader.createEl("span", { cls: "collapsible-title" });
    activityTitle.createEl("span", { cls: "collapse-indicator", text: "\u25BC " });
    activityTitle.appendText(t("agent.activityTitle"));
    const activitySteps = activityColumn.createEl("div", {
      cls: "claude-code-agent-steps collapsible-content",
      attr: { id: "claude-code-agent-steps" }
    });
    activityHeader.addEventListener("click", () => {
      const isCollapsed = activitySteps.hasClass("claude-code-hidden");
      activitySteps.toggleClass("claude-code-hidden", !isCollapsed);
      const indicator = activityHeader.querySelector(".collapse-indicator");
      if (indicator) {
        indicator.textContent = isCollapsed ? "\u25BC " : "\u25B6 ";
      }
      agentContainer.toggleClass("collapsed", !isCollapsed);
    });
  }
  /**
   * Build the interactive prompt section (for future use)
   */
  static buildInteractivePromptSection(container, onRespond) {
    const interactivePromptSection = container.createEl("div", {
      cls: "claude-code-interactive-prompt claude-code-hidden"
    });
    interactivePromptSection.id = "claude-code-interactive-prompt";
    interactivePromptSection.createEl("div", {
      cls: "interactive-prompt-header",
      text: "\u2753 " + t("interactive.header")
    });
    interactivePromptSection.createEl("div", {
      cls: "interactive-prompt-question",
      attr: { id: "interactive-prompt-question" }
    });
    const promptButtons = interactivePromptSection.createEl("div", {
      cls: "interactive-prompt-buttons"
    });
    const yesButton = promptButtons.createEl("button", {
      cls: "mod-cta",
      text: "\u2713 " + t("interactive.yesButton")
    });
    yesButton.addEventListener("click", () => onRespond("yes"));
    const noButton = promptButtons.createEl("button", {
      text: "\u2717 " + t("interactive.noButton")
    });
    noButton.addEventListener("click", () => onRespond("no"));
    const customResponseInput = interactivePromptSection.createEl("input", {
      cls: "interactive-prompt-input",
      attr: {
        placeholder: t("interactive.customPlaceholder"),
        id: "interactive-prompt-input"
      }
    });
    customResponseInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        onRespond(customResponseInput.value);
      }
    });
    return interactivePromptSection;
  }
  /**
   * Build the permission approval section
   */
  static buildPermissionApprovalSection(container, onApprove, onDeny) {
    const permissionApprovalSection = container.createEl("div", {
      cls: "claude-code-permission-approval claude-code-hidden"
    });
    permissionApprovalSection.id = "claude-code-permission-approval";
    permissionApprovalSection.createEl("div", {
      cls: "permission-approval-header",
      text: "\u{1F510} " + t("permission.header")
    });
    permissionApprovalSection.createEl("div", {
      cls: "permission-approval-message",
      text: t("permission.message")
    });
    const approvalButtons = permissionApprovalSection.createEl("div", {
      cls: "permission-approval-buttons"
    });
    const approvePermissionButton = approvalButtons.createEl("button", {
      cls: "mod-cta",
      text: "\u2713 " + t("permission.approveButton")
    });
    approvePermissionButton.addEventListener("click", onApprove);
    const denyPermissionButton = approvalButtons.createEl("button", {
      cls: "mod-warning",
      text: "\u2717 " + t("permission.denyButton")
    });
    denyPermissionButton.addEventListener("click", onDeny);
    return { permissionApprovalSection, approvePermissionButton, denyPermissionButton };
  }
  /**
   * Build the result section (for non-edit responses)
   */
  static buildResultSection(container) {
    const resultSection = container.createEl("div", { cls: "claude-code-result-section claude-code-hidden" });
    resultSection.id = "claude-code-result-section";
    const resultHeader = resultSection.createEl("div", { cls: "claude-code-result-header collapsible-header" });
    const headerTitle = resultHeader.createEl("span", { cls: "collapsible-title" });
    headerTitle.createEl("span", { cls: "collapse-indicator", text: "\u25BC " });
    headerTitle.appendText(t("result.title"));
    const contentWrapper = resultSection.createEl("div", { cls: "collapsible-content" });
    const lastPromptArea = contentWrapper.createEl("div", { cls: "claude-code-last-prompt claude-code-hidden" });
    lastPromptArea.id = "claude-code-last-prompt";
    const statusArea = contentWrapper.createEl("div", { cls: "claude-code-status-area claude-code-hidden" });
    const statusTextContainer = statusArea.createEl("div", { cls: "claude-code-status-text" });
    statusTextContainer.createEl("div", { cls: "claude-code-status-spinner" });
    const statusText = statusTextContainer.createEl("span");
    const progressBarContainer = statusArea.createEl("div", { cls: "claude-code-progress-bar-container" });
    progressBarContainer.createEl("div", { cls: "claude-code-progress-bar" });
    const resultArea = contentWrapper.createEl("div", {
      cls: "claude-code-result-area markdown-rendered claude-code-hidden"
    });
    resultHeader.addEventListener("click", () => {
      const isCollapsed = contentWrapper.hasClass("claude-code-hidden");
      contentWrapper.toggleClass("claude-code-hidden", !isCollapsed);
      const indicator = resultHeader.querySelector(".collapse-indicator");
      if (indicator) {
        indicator.textContent = isCollapsed ? "\u25BC " : "\u25B6 ";
      }
      resultSection.toggleClass("collapsed", !isCollapsed);
    });
    return { resultArea, statusArea, statusText, lastPromptArea };
  }
  /**
   * Build the output section
   */
  static buildOutputSection(container) {
    const outputSection = container.createEl("div", { cls: "claude-code-output-section claude-code-hidden" });
    const outputHeader = outputSection.createEl("div", { cls: "claude-code-output-header collapsible-header" });
    const headerTitle = outputHeader.createEl("span", { cls: "collapsible-title" });
    headerTitle.createEl("span", { cls: "collapse-indicator", text: "\u25B6 " });
    headerTitle.appendText(t("output.title"));
    const outputArea = outputSection.createEl("div", {
      cls: "claude-code-output-area collapsible-content claude-code-hidden"
    });
    outputSection.addClass("collapsed");
    outputHeader.addEventListener("click", () => {
      const isCollapsed = outputArea.hasClass("claude-code-hidden");
      outputArea.toggleClass("claude-code-hidden", !isCollapsed);
      const indicator = outputHeader.querySelector(".collapse-indicator");
      if (indicator) {
        indicator.textContent = isCollapsed ? "\u25BC " : "\u25B6 ";
      }
      outputSection.toggleClass("collapsed", !isCollapsed);
    });
    return { outputArea, outputSection };
  }
  /**
   * Build the preview section
   */
  static buildPreviewSection(container, onApply, onReject) {
    const previewSection = container.createEl("div", { cls: "claude-code-preview-section claude-code-hidden" });
    previewSection.id = "claude-code-preview-section";
    const previewHeader = previewSection.createEl("div", { cls: "claude-code-preview-header collapsible-header" });
    const headerTitle = previewHeader.createEl("span", { cls: "collapsible-title" });
    headerTitle.createEl("span", { cls: "collapse-indicator", text: "\u25BC " });
    headerTitle.appendText(t("preview.title"));
    const previewContent = previewSection.createEl("div", { cls: "claude-code-preview-content-wrapper collapsible-content" });
    const previewTabsContainer = previewContent.createEl("div", { cls: "claude-code-preview-tabs" });
    const rawTab = previewTabsContainer.createEl("div", { cls: "preview-tab", text: t("preview.tabRaw") });
    const diffTab = previewTabsContainer.createEl("div", { cls: "preview-tab active", text: t("preview.tabDiff") });
    const renderedTab = previewTabsContainer.createEl("div", { cls: "preview-tab", text: t("preview.tabRendered") });
    const previewContentContainer = previewContent.createEl("div", { cls: "claude-code-preview-content-container" });
    const previewArea = previewContentContainer.createEl("div", { cls: "claude-code-preview-area" });
    const previewButtons = previewContent.createEl("div", { cls: "claude-code-preview-buttons" });
    const applyButton = previewButtons.createEl("button", {
      cls: "mod-cta",
      text: "\u2713 " + t("preview.applyButton")
    });
    applyButton.addEventListener("click", onApply);
    const rejectButton = previewButtons.createEl("button", {
      cls: "mod-warning",
      text: "\u2717 " + t("preview.rejectButton")
    });
    rejectButton.addEventListener("click", onReject);
    rawTab.addEventListener("click", () => {
      rawTab.addClass("active");
      diffTab.removeClass("active");
      renderedTab.removeClass("active");
      previewArea.removeClass("claude-code-hidden");
      const diffArea = previewContentContainer.querySelector(".claude-code-preview-diff");
      const renderedArea = previewContentContainer.querySelector(".claude-code-preview-rendered");
      if (diffArea)
        diffArea.addClass("claude-code-hidden");
      if (renderedArea)
        renderedArea.addClass("claude-code-hidden");
    });
    diffTab.addEventListener("click", () => {
      diffTab.addClass("active");
      rawTab.removeClass("active");
      renderedTab.removeClass("active");
      previewArea.addClass("claude-code-hidden");
      const diffArea = previewContentContainer.querySelector(".claude-code-preview-diff");
      const renderedArea = previewContentContainer.querySelector(".claude-code-preview-rendered");
      if (diffArea)
        diffArea.removeClass("claude-code-hidden");
      if (renderedArea)
        renderedArea.addClass("claude-code-hidden");
    });
    renderedTab.addEventListener("click", () => {
      renderedTab.addClass("active");
      rawTab.removeClass("active");
      diffTab.removeClass("active");
      previewArea.addClass("claude-code-hidden");
      const diffArea = previewContentContainer.querySelector(".claude-code-preview-diff");
      const renderedArea = previewContentContainer.querySelector(".claude-code-preview-rendered");
      if (diffArea)
        diffArea.addClass("claude-code-hidden");
      if (renderedArea)
        renderedArea.removeClass("claude-code-hidden");
    });
    headerTitle.addEventListener("click", () => {
      const isCollapsed = previewContent.hasClass("claude-code-hidden");
      previewContent.toggleClass("claude-code-hidden", !isCollapsed);
      const indicator = previewHeader.querySelector(".collapse-indicator");
      if (indicator) {
        indicator.textContent = isCollapsed ? "\u25BC " : "\u25B6 ";
      }
      previewSection.toggleClass("collapsed", !isCollapsed);
    });
    return { previewArea, previewContentContainer, previewTabsContainer, applyButton, rejectButton };
  }
  /**
   * Build the history section
   */
  static buildHistorySection(container, onClearHistory) {
    const historySection = container.createEl("div", { cls: "claude-code-history-section claude-code-hidden" });
    historySection.id = "claude-code-history-section";
    const historyHeader = historySection.createEl("div", { cls: "claude-code-history-header collapsible-header" });
    const headerTitle = historyHeader.createEl("span", { cls: "collapsible-title" });
    headerTitle.createEl("span", { cls: "collapse-indicator", text: "\u25B6 " });
    headerTitle.appendText(t("history.title"));
    const clearHistoryBtn = historyHeader.createEl("button", {
      text: t("history.clearButton"),
      cls: "claude-code-clear-history"
    });
    clearHistoryBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      onClearHistory();
    });
    const historyList = historySection.createEl("ul", { cls: "claude-code-history-list collapsible-content claude-code-hidden" });
    historySection.addClass("collapsed");
    headerTitle.addEventListener("click", () => {
      const isCollapsed = historyList.hasClass("claude-code-hidden");
      historyList.toggleClass("claude-code-hidden", !isCollapsed);
      const indicator = historyHeader.querySelector(".collapse-indicator");
      if (indicator) {
        indicator.textContent = isCollapsed ? "\u25BC " : "\u25B6 ";
      }
      historySection.toggleClass("collapsed", !isCollapsed);
    });
    return historyList;
  }
  /**
   * Build WebSocket connection status bar
   */
  static buildConnectionStatusBar(container) {
    const statusBar = container.createEl("div", { cls: "claude-code-connection-status" });
    const statusIcon = statusBar.createEl("span", {
      cls: "claude-code-connection-icon disconnected"
    });
    const statusText = statusBar.createEl("span", {
      cls: "claude-code-connection-text",
      text: "Disconnected"
    });
    return { statusBar, statusIcon, statusText };
  }
  /**
   * Update connection status display
   */
  static updateConnectionStatus(statusIcon, statusText, state, connectionMode) {
    statusIcon.removeClass("disconnected", "connecting", "connected", "error");
    switch (state) {
      case "connected":
        statusIcon.addClass("connected");
        statusText.textContent = connectionMode === "websocket" ? "WebSocket Connected" : "Connected (stdio)";
        break;
      case "connecting":
      case "reconnecting":
        statusIcon.addClass("connecting");
        statusText.textContent = "Connecting...";
        break;
      case "error":
        statusIcon.addClass("error");
        statusText.textContent = "Connection Error";
        break;
      case "disconnected":
      default:
        statusIcon.addClass("disconnected");
        statusText.textContent = connectionMode === "websocket" ? "WebSocket Disconnected" : "Disconnected";
        break;
    }
  }
};

// src/ui/output-renderer.ts
var import_obsidian = require("obsidian");

// src/ui/parsers/agent-activity-parser.ts
var AgentActivityParser = class {
  /**
   * Parse and extract agent activity from output text
   *
   * @param text Output text to parse
   * @returns AgentStep object if activity detected, null otherwise
   */
  static parseAgentActivity(text) {
    if (text.includes("Resuming session:") || text.includes("\u2713 Resuming session:")) {
      return this.matchAndCreate(
        text,
        /(?: )?Resuming session: (.+)/,
        "\u{1F504}",
        "Resume",
        "resume",
        (match) => this.truncate(match[1], 8, false) + "..."
      );
    }
    if (text.includes("\u2192 Starting new session")) {
      return this.createStep("\u{1F195}", "New", "session started", "new-session");
    }
    if (text.includes("Vault access enabled:")) {
      return this.matchAndCreate(
        text,
        /Vault access enabled: (.+)/,
        "\u{1F5C2}\uFE0F",
        "Vault",
        "vault",
        (match) => this.extractFilename(match[1])
      );
    }
    if (text.includes("\u{1F527} Session initialized:")) {
      return this.matchAndCreate(
        text,
        / Session initialized: (.+)/,
        "\u{1F680}",
        "Initialize",
        "init"
      );
    }
    if (text.includes("\u{1F4BE} Session ID:")) {
      return this.matchAndCreate(
        text,
        / Session ID: (.+)/,
        "\u{1F4BE}",
        "Session",
        "session",
        (match) => this.truncate(match[1], 8, false) + "..."
      );
    }
    if (text.includes("\u{1F4E6} Available tools:")) {
      const match = text.match(/ Available tools: (.+)/);
      if (match) {
        const tools = match[1].split(", ");
        return this.createStep("\u{1F4E6}", "Tools", `${tools.length} available`, "tools");
      }
    }
    if (text.includes("\u{1F527} Using tool:")) {
      const match = text.match(/ Using tool: (\w+)/);
      if (match) {
        return this.createStep("\u{1F527}", match[1], "starting...", `tool-${match[1]}`);
      }
    }
    if (text.includes("$ ")) {
      return this.matchAndCreate(
        text,
        /\$ (.+)/,
        "\u26A1",
        "Bash",
        "bash",
        (match) => this.truncate(match[1], 60)
      );
    }
    if (text.includes("Query:") && (text.includes("\u{1F50D}") || text.includes("search"))) {
      return this.matchAndCreate(
        text,
        /(?: )?Query: "(.+?)"/,
        "\u{1F50D}",
        "Search",
        "search",
        (match) => this.truncate(match[1], 50)
      );
    }
    if (text.includes("\u{1F4E5} Tool result")) {
      return this.matchAndCreate(
        text,
        / Tool result \((.+?)\):/,
        "\u{1F4E5}",
        "Result",
        "result",
        (match) => this.truncate(match[1], 20)
      );
    }
    if (text.includes("\u{1F310} URL:")) {
      return this.matchAndCreate(
        text,
        / URL: (.+)/,
        "\u{1F310}",
        "Fetch",
        "fetch",
        (match) => this.truncate(match[1], 50)
      );
    }
    if (text.includes("\u{1F4D6}") && (text.includes("File:") || text.includes("Reading file:"))) {
      return this.matchAndCreate(
        text,
        /(?:File:|Reading file:)\s+(.+)/,
        "\u{1F4D6}",
        "Read",
        "read",
        (match) => this.extractFilename(match[1])
      );
    }
    if (text.includes("\u270D\uFE0F") && (text.includes("File:") || text.includes("Writing file:"))) {
      return this.matchAndCreate(
        text,
        /(?:File:|Writing file:)\s+(.+)/,
        "\u270D\uFE0F",
        "Write",
        "write",
        (match) => this.extractFilename(match[1])
      );
    }
    if (text.includes("\u270F\uFE0F") && (text.includes("File:") || text.includes("Editing file:"))) {
      return this.matchAndCreate(
        text,
        /(?:File:|Editing file:)\s+(.+)/,
        "\u270F\uFE0F",
        "Edit",
        "edit",
        (match) => this.extractFilename(match[1])
      );
    }
    if (text.includes("Pattern:")) {
      return this.matchAndCreate(
        text,
        /Pattern: (.+)/,
        "\u{1F50E}",
        "Search",
        "pattern",
        (match) => this.truncate(match[1], 40)
      );
    }
    if (text.includes("Agent:") || text.includes("Type:")) {
      return this.matchAndCreate(
        text,
        /(?:Agent:|Type:)\s+(.+)/,
        "\u{1F916}",
        "Agent",
        "agent"
      );
    }
    if (text.includes("\u2705 Complete!")) {
      return this.createStep("\u2705", "Complete", "Success", "complete");
    }
    if (text.includes("\u{1F4B0} Cost:")) {
      return this.matchAndCreate(
        text,
        / Cost: \$(\d+\.\d+)/,
        "\u{1F4B0}",
        "Cost",
        "cost",
        (match) => `$${match[1]}`
      );
    }
    if (text.includes("\u{1F4CA} Tokens:")) {
      const match = text.match(/ Tokens: (\d+) in, (\d+) out/);
      if (match) {
        return this.createStep("\u{1F4CA}", "Tokens", `${match[1]} \u2192 ${match[2]}`, "tokens");
      }
    }
    if (text.includes("\u23F1\uFE0F") && text.includes("Duration:")) {
      return this.matchAndCreate(
        text,
        /\s{2}Duration: (\d+)ms/,
        "\u23F1\uFE0F",
        "Duration",
        "duration",
        (match) => `${(parseInt(match[1]) / 1e3).toFixed(1)}s`
      );
    }
    if (text.includes("\u2713 Claude Code completed")) {
      return this.createStep("\u{1F389}", "Finished", "Successfully", "finished");
    }
    return null;
  }
  /**
   * Helper to create AgentStep from parameters
   */
  static createStep(icon, action, target, keyPrefix) {
    return {
      icon,
      action,
      target,
      key: `${keyPrefix}-${Date.now()}`
    };
  }
  /**
   * Helper to match pattern and create step with optional target transformation
   */
  static matchAndCreate(text, pattern, icon, action, keyPrefix, targetTransform) {
    const match = text.match(pattern);
    if (!match)
      return null;
    const target = targetTransform ? targetTransform(match) : match[1];
    return this.createStep(icon, action, target, keyPrefix);
  }
  /**
   * Helper to extract filename from path
   */
  static extractFilename(path7, maxLength = 40) {
    const filename = path7.split("/").pop() || path7;
    return filename.substring(0, maxLength);
  }
  /**
   * Helper to truncate text
   */
  static truncate(text, maxLength, addEllipsis = true) {
    if (text.length <= maxLength)
      return text;
    return addEllipsis ? text.substring(0, maxLength) + "..." : text.substring(0, maxLength);
  }
};

// src/ui/output-renderer.ts
var OutputRenderer = class {
  constructor(outputArea, component, app, notePath, outputSection) {
    this.outputSection = null;
    this.currentStreamingElement = null;
    this.outputArea = outputArea;
    this.component = component;
    this.app = app;
    this.notePath = notePath;
    this.currentStreamingElement = null;
    this.outputSection = outputSection || null;
  }
  /**
   * Update the note path for markdown rendering
   */
  setNotePath(notePath) {
    this.notePath = notePath;
  }
  /**
   * Append a line of output
   */
  appendLine(text, isMarkdown = false) {
    this.showOutputSection();
    const line = this.outputArea.createEl("div", { cls: "claude-code-output-line" });
    if (isMarkdown) {
      line.classList.add("markdown-rendered");
      try {
        void import_obsidian.MarkdownRenderer.render(this.app, text, line, this.notePath, this.component);
      } catch (error) {
        console.error("[MARKDOWN RENDER ERROR]", error);
        line.textContent = text;
      }
    } else {
      line.textContent = text;
    }
    this.outputArea.scrollTop = this.outputArea.scrollHeight;
  }
  /**
   * Append streaming text (accumulates in the same element)
   */
  appendStreamingText(text) {
    this.showOutputSection();
    if (!this.currentStreamingElement) {
      this.currentStreamingElement = this.outputArea.createEl("div", {
        cls: "claude-code-output-line claude-code-streaming"
      });
    }
    this.currentStreamingElement.createEl("span", {
      cls: "streaming-text-chunk",
      text
    });
    this.outputArea.scrollTop = this.outputArea.scrollHeight;
  }
  /**
   * Finish the current streaming block
   */
  finishStreamingBlock() {
    this.currentStreamingElement = null;
  }
  /**
   * Clear all output
   */
  clear() {
    this.outputArea.empty();
    this.hideOutputSection();
  }
  /**
   * Show the output section
   */
  showOutputSection() {
    if (this.outputSection) {
      this.outputSection.removeClass("claude-code-hidden");
    }
  }
  /**
   * Hide the output section
   */
  hideOutputSection() {
    if (this.outputSection) {
      this.outputSection.addClass("claude-code-hidden");
    }
  }
  /**
   * Parse and extract agent activity from output text
   */
  static parseAgentActivity(text) {
    return AgentActivityParser.parseAgentActivity(text);
  }
};

// src/ui/agent-activity-tracker.ts
var AgentActivityTracker = class {
  constructor() {
    this.agentSteps = /* @__PURE__ */ new Map();
    this.agentStepsContainer = null;
    this.agentActivitySection = null;
    this.agentContainer = null;
    this.stepTimers = /* @__PURE__ */ new Map();
    this.stepStartTimes = /* @__PURE__ */ new Map();
  }
  /**
   * Initialize the tracker with DOM elements
   */
  initialize(agentActivitySection) {
    this.agentActivitySection = agentActivitySection;
    this.agentStepsContainer = agentActivitySection.querySelector("#claude-code-agent-steps");
    this.agentContainer = document.getElementById("claude-code-agent-container");
  }
  /**
   * Add or update an agent step
   */
  addStep(step) {
    if (!this.agentStepsContainer || !this.agentActivitySection)
      return;
    this.agentActivitySection.removeClass("claude-code-hidden");
    if (this.agentContainer) {
      this.agentContainer.removeClass("claude-code-hidden");
    }
    if (this.agentSteps.has(step.key)) {
      const existingEl = this.agentSteps.get(step.key);
      if (step.duration !== void 0) {
        this.stopStepTimer(step.key);
        const oldDuration = existingEl.querySelector(".agent-step-duration");
        if (oldDuration) {
          oldDuration.remove();
        }
        const durationText = this.formatDuration(step.duration);
        existingEl.createEl("span", {
          cls: "agent-step-duration agent-step-duration-complete",
          text: durationText
        });
      }
      return;
    }
    const stepEl = this.agentStepsContainer.createEl("div", {
      cls: "claude-code-agent-step"
    });
    stepEl.createEl("span", {
      cls: "agent-step-icon",
      text: step.icon
    });
    stepEl.createEl("span", {
      cls: "agent-step-action",
      text: step.action
    });
    stepEl.createEl("span", {
      cls: "agent-step-target",
      text: step.target
    });
    if (step.duration !== void 0) {
      const durationText = this.formatDuration(step.duration);
      stepEl.createEl("span", {
        cls: "agent-step-duration agent-step-duration-complete",
        text: durationText
      });
    } else if (step.startTime !== void 0) {
      const durationEl = stepEl.createEl("span", {
        cls: "agent-step-duration agent-step-duration-live",
        text: "0.0s"
      });
      this.startStepTimer(step.key, step.startTime, durationEl);
    }
    this.agentSteps.set(step.key, stepEl);
    this.agentStepsContainer.scrollTop = this.agentStepsContainer.scrollHeight;
  }
  /**
   * Start a live timer for a step
   */
  startStepTimer(key, startTime, durationEl) {
    this.stepStartTimes.set(key, startTime);
    const timer = setInterval(() => {
      const elapsed = Date.now() - startTime;
      const formatted = this.formatDuration(elapsed);
      durationEl.textContent = formatted;
    }, 100);
    this.stepTimers.set(key, timer);
  }
  /**
   * Stop the live timer for a step
   */
  stopStepTimer(key) {
    const timer = this.stepTimers.get(key);
    if (timer) {
      clearInterval(timer);
      this.stepTimers.delete(key);
    }
    this.stepStartTimes.delete(key);
  }
  /**
   * Clear all agent steps
   */
  clear() {
    for (const timer of this.stepTimers.values()) {
      clearInterval(timer);
    }
    this.stepTimers.clear();
    this.stepStartTimes.clear();
    if (this.agentStepsContainer) {
      this.agentStepsContainer.empty();
    }
    this.agentSteps.clear();
    if (this.agentActivitySection) {
      this.agentActivitySection.addClass("claude-code-hidden");
    }
  }
  /**
   * Restore agent steps from an array
   */
  restore(steps) {
    this.clear();
    for (const step of steps) {
      this.addStep(step);
    }
  }
  /**
   * Get all current steps
   */
  getSteps() {
    return Array.from(this.agentSteps.keys()).map((key) => {
      var _a;
      const [action, target] = key.split("-");
      const stepEl = this.agentSteps.get(key);
      const icon = ((_a = stepEl.querySelector(".agent-step-icon")) == null ? void 0 : _a.textContent) || "\u{1F527}";
      return { icon, action, target, key };
    });
  }
  /**
   * Format duration in a human-readable way
   */
  formatDuration(ms) {
    if (ms < 1e3) {
      return `${ms}ms`;
    } else if (ms < 6e4) {
      return `${(ms / 1e3).toFixed(1)}s`;
    } else {
      const minutes = Math.floor(ms / 6e4);
      const seconds = Math.floor(ms % 6e4 / 1e3);
      return `${minutes}m ${seconds}s`;
    }
  }
};

// src/managers/note-context-manager.ts
var fs4 = __toESM(require("fs"));
var path5 = __toESM(require("path"));
var crypto2 = __toESM(require("crypto"));

// src/core/claude-code-runner.ts
var fs3 = __toESM(require("fs"));
var path4 = __toESM(require("path"));
var import_string_decoder = require("string_decoder");

// src/core/streaming/tool-output-formatter.ts
var ToolOutputFormatter = class {
  /**
   * Format tool usage information from tool_use event or message block
   *
   * @param toolName Name of the tool being used
   * @param toolInput Input parameters for the tool
   * @param format Format style: 'compact' for message blocks, 'verbose' for events
   * @returns Array of formatted output lines
   */
  static formatToolUsage(toolName, toolInput, format = "compact") {
    const lines = [];
    if (format === "verbose") {
      lines.push(...this.formatVerboseHeader(toolName));
    }
    lines.push(...this.formatToolSpecificParams(toolName, toolInput, format));
    return lines;
  }
  /**
   * Format verbose header for tool_use events
   */
  static formatVerboseHeader(toolName) {
    const headers = {
      "Bash": "\n\u{1F527} Bash executing:\n",
      "Glob": "\n\u{1F50D} Glob searching:\n",
      "Grep": "\n\u{1F50E} Grep searching:\n",
      "Read": "\n\u{1F4D6} Reading file:\n",
      "Write": "\n\u270D\uFE0F  Writing file:\n",
      "Edit": "\n\u270F\uFE0F  Editing file:\n",
      "WebFetch": "\n\u{1F310} Fetching webpage:\n",
      "WebSearch": "\n\u{1F50D} Web searching:\n",
      "Task": "\n\u{1F916} Launching agent:\n"
    };
    return [headers[toolName] || `
\u{1F6E0}\uFE0F  ${toolName}:
`];
  }
  /**
   * Format tool-specific parameters
   */
  static formatToolSpecificParams(toolName, toolInput, format) {
    var _a, _b, _c;
    const lines = [];
    if (!toolInput) {
      return lines;
    }
    switch (toolName) {
      case "Bash":
        if (toolInput.command) {
          lines.push(`   $ ${toolInput.command}
`);
          if (toolInput.description) {
            lines.push(`   \u{1F4DD} ${toolInput.description}
`);
          }
        }
        break;
      case "WebSearch":
        if (toolInput.query) {
          const prefix = format === "compact" ? "   \u{1F50D} Query:" : "   Query:";
          lines.push(`${prefix} "${toolInput.query}"
`);
          if ((_a = toolInput.allowed_domains) == null ? void 0 : _a.length) {
            const label = format === "compact" ? "   \u2713 Allowed:" : "   Allowed domains:";
            lines.push(`${label} ${toolInput.allowed_domains.join(", ")}
`);
          }
          if ((_b = toolInput.blocked_domains) == null ? void 0 : _b.length) {
            const label = format === "compact" ? "   \u2717 Blocked:" : "   Blocked domains:";
            lines.push(`${label} ${toolInput.blocked_domains.join(", ")}
`);
          }
        }
        break;
      case "WebFetch":
        if (toolInput.url) {
          const prefix = format === "compact" ? "   \u{1F310} URL:" : "   URL:";
          lines.push(`${prefix} ${toolInput.url}
`);
          if (toolInput.prompt) {
            const label = format === "compact" ? "   \u{1F4CB} Task:" : "   Task:";
            const truncated = toolInput.prompt.substring(0, format === "compact" ? 100 : 150);
            const ellipsis = toolInput.prompt.length > (format === "compact" ? 100 : 150) ? "..." : "";
            lines.push(`${label} ${truncated}${ellipsis}
`);
          }
        }
        break;
      case "Glob":
        if (toolInput.pattern) {
          const prefix = format === "compact" ? "   \u{1F50D} Pattern:" : "   Pattern:";
          lines.push(`${prefix} ${toolInput.pattern}
`);
          if (toolInput.path) {
            const searchPath = format === "verbose" ? toolInput.path : toolInput.path;
            lines.push(`   \u{1F4C1} Path: ${searchPath}
`);
          } else if (format === "verbose") {
            lines.push(`   Path: .
`);
          }
        }
        break;
      case "Grep":
        if (toolInput.pattern) {
          const prefix = format === "compact" ? "   \u{1F50E} Pattern:" : "   Pattern:";
          lines.push(`${prefix} "${toolInput.pattern}"
`);
          if (toolInput.path) {
            const searchPath = format === "verbose" ? toolInput.path : toolInput.path;
            lines.push(`   \u{1F4C1} Path: ${searchPath}
`);
          } else if (format === "verbose") {
            lines.push(`   Path: .
`);
          }
          if (toolInput.output_mode) {
            const label = format === "compact" ? "   \u{1F4CA} Mode:" : "   Mode:";
            lines.push(`${label} ${toolInput.output_mode}
`);
          }
        }
        break;
      case "Read":
        if (toolInput.file_path) {
          const prefix = format === "compact" ? "   \u{1F4D6} File:" : "   ";
          lines.push(`${prefix}${toolInput.file_path}
`);
          if (format === "verbose" && (toolInput.offset || toolInput.limit)) {
            const start = toolInput.offset || 0;
            const end = toolInput.limit ? start + toolInput.limit : "EOF";
            lines.push(`   Lines: ${start} to ${end}
`);
          }
        }
        break;
      case "Write":
        if (toolInput.file_path) {
          const prefix = format === "compact" ? "   \u270D\uFE0F  File:" : "   ";
          lines.push(`${prefix}${toolInput.file_path}
`);
          const contentLength = ((_c = toolInput.content) == null ? void 0 : _c.length) || 0;
          const label = format === "compact" ? "   \u{1F4CF} Size:" : "   Size:";
          lines.push(`${label} ${contentLength} char${contentLength === 1 ? "" : "s"}
`);
        }
        break;
      case "Edit":
        if (toolInput.file_path) {
          const prefix = format === "compact" ? "   \u270F\uFE0F  File:" : "   ";
          lines.push(`${prefix}${toolInput.file_path}
`);
          if (format === "verbose" && toolInput.replace_all) {
            lines.push(`   Mode: Replace all occurrences
`);
          }
        }
        break;
      case "Task":
        if (toolInput.subagent_type) {
          const prefix = format === "compact" ? "   \u{1F916} Agent:" : "   Type:";
          lines.push(`${prefix} ${toolInput.subagent_type}
`);
        }
        if (toolInput.description) {
          lines.push(`   \u{1F4CB} Task: ${toolInput.description}
`);
        }
        if (format === "verbose" && toolInput.prompt) {
          const shortPrompt = toolInput.prompt.substring(0, 150);
          lines.push(`   Prompt: ${shortPrompt}${toolInput.prompt.length > 150 ? "..." : ""}
`);
        }
        break;
      case "TodoWrite": {
        const todoInputStr = JSON.stringify(toolInput, null, 2);
        lines.push(`   ${todoInputStr}
`);
        break;
      }
      default: {
        const inputStr = JSON.stringify(toolInput, null, 2);
        if (format === "compact") {
          const linesArr = inputStr.split("\n");
          if (linesArr.length > 10) {
            lines.push(`   ${linesArr.slice(0, 10).join("\n")}
   ...
`);
          } else {
            lines.push(`   ${inputStr}
`);
          }
        } else {
          if (inputStr.length > 300) {
            lines.push(`   ${inputStr.substring(0, 300)}...
`);
          } else {
            lines.push(`   ${inputStr}
`);
          }
        }
        break;
      }
    }
    return lines;
  }
  /**
   * Format tool result output
   *
   * @param toolName Name of the tool
   * @param result Result object from the tool
   * @returns Array of formatted output lines
   */
  static formatToolResult(toolName, result) {
    const lines = [];
    if (toolName === "Bash" && result && typeof result === "object") {
      const stdout = result.stdout;
      if (typeof stdout === "string") {
        const output = stdout.trim();
        if (output) {
          const outputLines = output.split("\n");
          lines.push(`   \u2713 Output (${outputLines.length} lines):
`);
          const preview = outputLines.slice(0, 3).join("\n");
          lines.push(`   ${preview}${outputLines.length > 3 ? "\n   ..." : ""}
`);
        } else {
          lines.push(`   \u2713 ${toolName} complete
`);
        }
      } else {
        lines.push(`   \u2713 ${toolName} complete
`);
      }
    } else if (result) {
      lines.push(`   \u2713 ${toolName} complete
`);
    }
    return lines;
  }
};

// src/core/streaming/stream-event-processor.ts
var StreamEventProcessor = class {
  /**
   * Process a single stream event and generate output
   *
   * @param event The stream event to process
   * @param sendOutput Callback to send output text
   * @param setSessionId Optional callback to store session ID
   */
  static processEvent(event, sendOutput, setSessionId) {
    switch (event.type) {
      case "system":
        this.handleSystemEvent(event, sendOutput, setSessionId);
        break;
      case "assistant":
        this.handleAssistantEvent(event, sendOutput);
        break;
      case "tool_use":
        this.handleToolUseEvent(event, sendOutput);
        break;
      case "user":
        this.handleUserEvent(event, sendOutput);
        break;
      case "result":
        this.handleResultEvent(event, sendOutput);
        break;
      case "stream_event":
        this.handleStreamEvent(event, sendOutput);
        break;
      default:
        this.handleUnknownEvent(event, sendOutput);
        break;
    }
  }
  /**
   * Handle system initialization events
   */
  static handleSystemEvent(event, sendOutput, setSessionId) {
    var _a;
    if (event.subtype === "init") {
      sendOutput(`
\u{1F527} Session initialized: ${event.model}
`);
      sendOutput(`\u{1F4E6} Available tools: ${((_a = event.tools) == null ? void 0 : _a.join(", ")) || "none"}
`);
      if (event.session_id && setSessionId) {
        setSessionId(event.session_id);
        sendOutput(`\u{1F4BE} Session ID: ${event.session_id}
`);
      }
    }
  }
  /**
   * Handle assistant message events
   */
  static handleAssistantEvent(event, sendOutput) {
    var _a;
    if ((_a = event.message) == null ? void 0 : _a.content) {
      for (const block of event.message.content) {
        if (block.type === "text" && block.text) {
          sendOutput(block.text, true, false, true);
        } else if (block.type === "tool_use" && block.name) {
          const toolName = block.name;
          const toolInput = block.input || {};
          sendOutput(`
\u{1F527} Using tool: ${toolName}
`);
          const formatted = ToolOutputFormatter.formatToolUsage(toolName, toolInput, "compact");
          for (const line of formatted) {
            sendOutput(line);
          }
        }
      }
    }
  }
  /**
   * Handle tool use events
   */
  static handleToolUseEvent(event, sendOutput) {
    const toolName = event.tool_name || "unknown";
    if (event.subtype === "input" && event.input) {
      const formatted = ToolOutputFormatter.formatToolUsage(toolName, event.input, "verbose");
      for (const line of formatted) {
        sendOutput(line);
      }
    } else if (event.subtype === "result") {
      const resultLines = ToolOutputFormatter.formatToolResult(toolName, event.result);
      for (const line of resultLines) {
        sendOutput(line);
      }
      if ((toolName === "Glob" || toolName === "Grep") && event.result) {
        const resultStr = typeof event.result === "string" ? event.result : JSON.stringify(event.result);
        const lines = resultStr.split("\n").filter((l) => l.trim());
        sendOutput(`   \u2713 Found ${lines.length} results
`);
      }
    }
  }
  /**
   * Handle user/tool result events
   */
  static handleUserEvent(event, sendOutput) {
    var _a;
    if ((_a = event.message) == null ? void 0 : _a.content) {
      for (const block of event.message.content) {
        if (block.type === "tool_result") {
          sendOutput(`
\u{1F4E5} Tool result (${block.tool_use_id}):
`);
          const content = typeof block.content === "string" ? block.content : JSON.stringify(block.content);
          const lines = content.split("\n");
          if (lines.length > 10) {
            sendOutput(`   ${lines.slice(0, 10).join("\n")}
`);
            sendOutput(`   ... (${lines.length - 10} more lines)
`);
          } else if (content.length > 500) {
            sendOutput(`   ${content.substring(0, 500)}...
`);
            sendOutput(`   (${content.length - 500} more characters)
`);
          } else {
            sendOutput(`   ${content}
`);
          }
        }
      }
    }
  }
  /**
   * Handle final result events
   */
  static handleResultEvent(event, sendOutput) {
    var _a;
    sendOutput(`
\u2705 Complete!
`);
    sendOutput(`\u23F1\uFE0F  Duration: ${event.duration_ms}ms
`);
    sendOutput(`\u{1F4B0} Cost: $${((_a = event.total_cost_usd) == null ? void 0 : _a.toFixed(4)) || "0.0000"}
`);
    if (event.usage) {
      sendOutput(`\u{1F4CA} Tokens: ${event.usage.input_tokens} in, ${event.usage.output_tokens} out
`);
    }
  }
  /**
   * Handle real-time streaming events
   */
  static handleStreamEvent(event, sendOutput) {
    var _a, _b;
    const streamEvent = event.event;
    if (!streamEvent)
      return;
    if (streamEvent.type === "content_block_delta") {
      if (((_a = streamEvent.delta) == null ? void 0 : _a.type) === "text_delta" && streamEvent.delta.text) {
        console.debug("[Stream Processor] Sending text delta as assistant message");
        sendOutput(streamEvent.delta.text, false, true, true);
      }
    } else if (streamEvent.type === "content_block_start") {
      if (((_b = streamEvent.content_block) == null ? void 0 : _b.type) === "text") {
        sendOutput(`
\u{1F4AC} Claude: `, false, false);
      }
    } else if (streamEvent.type === "content_block_stop") {
      sendOutput(`
`, false, "finish", true);
    }
  }
  /**
   * Handle unknown event types (debugging)
   */
  static handleUnknownEvent(event, sendOutput) {
    sendOutput(`
\u{1F50D} [${event.type}${event.subtype ? " / " + event.subtype : ""}]
`);
    const displayFields = ["session_id", "uuid", "duration_ms", "model", "is_error"];
    for (const field of displayFields) {
      const value = event[field];
      if (value !== void 0) {
        sendOutput(`   ${field}: ${String(value)}
`);
      }
    }
    if (event.message) {
      sendOutput(`   message: ${JSON.stringify(event.message).substring(0, 200)}...
`);
    }
  }
};

// src/core/session-manager.ts
var fs = __toESM(require("fs"));
var path = __toESM(require("path"));
var crypto = __toESM(require("crypto"));
var SessionManager = class {
  /**
   * Get or create session directory for a note
   *
   * @param notePath Path to the note file
   * @param vaultPath Path to the vault root
   * @param configDir Config directory name from Vault.configDir
   * @returns Session information
   */
  static getSessionInfo(notePath, vaultPath, configDir) {
    const noteHash = crypto.createHash("md5").update(notePath).digest("hex");
    const sessionDir = path.join(vaultPath, configDir, "claude-code-sessions", noteHash);
    if (!fs.existsSync(sessionDir)) {
      fs.mkdirSync(sessionDir, { recursive: true });
    }
    const sessionIdFile = path.join(sessionDir, "session_id.txt");
    let sessionId = null;
    let isNewSession = true;
    if (fs.existsSync(sessionIdFile)) {
      try {
        sessionId = fs.readFileSync(sessionIdFile, "utf8").trim();
        isNewSession = false;
      } catch (error) {
        console.warn("Error loading session ID:", error);
      }
    }
    return {
      sessionDir,
      sessionId,
      isNewSession
    };
  }
  /**
   * Save session ID to disk
   *
   * @param sessionDir Directory where session data is stored
   * @param sessionId Session ID to save
   */
  static saveSessionId(sessionDir, sessionId) {
    try {
      const sessionIdFile = path.join(sessionDir, "session_id.txt");
      fs.writeFileSync(sessionIdFile, sessionId);
    } catch (error) {
      console.error("Error saving session ID:", error);
      throw error;
    }
  }
  /**
   * Save conversation history
   *
   * @param sessionDir Directory where session data is stored
   * @param userPrompt User's prompt
   * @param assistantResponse Assistant's response
   */
  static saveConversationHistory(sessionDir, userPrompt, assistantResponse) {
    const historyFile = path.join(sessionDir, "conversation_history.json");
    try {
      let history = [];
      if (fs.existsSync(historyFile)) {
        history = JSON.parse(fs.readFileSync(historyFile, "utf8"));
      }
      history.push({
        role: "user",
        content: userPrompt,
        timestamp: new Date().toISOString()
      });
      history.push({
        role: "assistant",
        content: assistantResponse,
        timestamp: new Date().toISOString()
      });
      if (history.length > 20) {
        history = history.slice(-20);
      }
      fs.writeFileSync(historyFile, JSON.stringify(history, null, 2));
    } catch (error) {
      console.error("Error saving conversation history:", error);
      throw error;
    }
  }
};

// src/core/prompt-builder.ts
var path2 = __toESM(require("path"));
var PromptBuilder = class {
  /**
   * Build a complete prompt for Claude Code
   *
   * @param request The request containing note content and user prompt
   * @param sessionDir Session directory path
   * @param customSystemPrompt Optional custom system prompt
   * @param allowVaultAccess Whether vault access is enabled
   * @param bypassPermissions Whether to bypass permission requests
   * @returns Complete prompt string
   */
  static buildPrompt(request, sessionDir, customSystemPrompt, allowVaultAccess, bypassPermissions) {
    let prompt = "";
    if (customSystemPrompt) {
      prompt += customSystemPrompt + "\n\n";
    }
    if (request.conversationalMode) {
      prompt += this.buildConversationalModeInstructions();
      prompt += `Current note content (for reference only - DO NOT MODIFY):
---
${request.noteContent}
---

`;
      prompt += `USER QUESTION: ${request.userPrompt}

`;
      return prompt;
    }
    prompt += this.buildPermissionModeInstructions(bypassPermissions);
    prompt += this.buildContextInstructions(request, sessionDir, allowVaultAccess);
    prompt += `EDITING INSTRUCTIONS:
`;
    prompt += `- The note content is in: ${path2.join(sessionDir, "note.md")}
`;
    prompt += `- Use the Edit or Write tool to modify the file
`;
    prompt += `- After you make changes, confirm what you did

`;
    prompt += `USER REQUEST: ${request.userPrompt}

`;
    return prompt;
  }
  /**
   * Build conversational mode instructions
   */
  static buildConversationalModeInstructions() {
    return `\u{1F4AC} CONVERSATIONAL MODE
You are in conversational mode. This means:
- DO NOT use file editing tools (Write, Edit, NotebookEdit)
- DO NOT modify any files
- You can use Read, Grep, Bash, WebSearch, and other read-only tools
- Focus on answering the user's question or providing information
- The note content is provided for context only
- Respond directly in your message - no file modifications needed

`;
  }
  /**
   * Build permission mode instructions
   */
  static buildPermissionModeInstructions(bypassPermissions) {
    if (bypassPermissions) {
      return `\u{1F513} PERMISSION MODE: AUTONOMOUS
You have FULL AUTONOMY to use ALL tools without asking for permission.
- You can read, write, edit, and execute any files or commands
- You can use web search, bash commands, and any other tools freely
- You do NOT need to ask for user approval before taking actions
- Proceed directly with your tasks using whatever tools are necessary

`;
    } else {
      return `\u{1F512} PERMISSION MODE: INTERACTIVE
- When you need permission (according your system prompt and configuration), your response MUST include the text "REQUIRED_APPROVAL"
`;
    }
  }
  /**
   * Build context instructions
   */
  static buildContextInstructions(request, sessionDir, allowVaultAccess) {
    let instructions = `You are an intelligent assistant helping to edit a markdown note in Obsidian vault. Your responses must be on the language of the user prompt

`;
    instructions += `CURRENT NOTE INFORMATION:
`;
    instructions += `- File path: ${request.notePath}
`;
    instructions += `- File name: ${path2.basename(request.notePath)}
`;
    instructions += `- Working directory: ${sessionDir}
`;
    instructions += `- Note file in session: note.md (local copy)
`;
    if (allowVaultAccess && request.vaultPath) {
      instructions += `- Obsidian vault root: ${request.vaultPath}
`;
      instructions += `- You can access ALL vault files using absolute paths: ${request.vaultPath}/filename.md
`;
      instructions += `- To search vault files, use tools with path: ${request.vaultPath}
`;
    }
    instructions += `
`;
    return instructions;
  }
  /**
   * Build agent mode instructions
   */
  static buildAgentInstructions() {
    return `You are a powerful AI assistant with access to tools. USE THEM ACTIVELY.

IMPORTANT - INTERPRET USER INTENT:
1. If the user is asking a QUESTION or requesting ANALYSIS, simply respond conversationally.
2. If the user wants to EDIT/MODIFY the note, use the Edit or Write tool to modify note.md, then explain what you changed.

`;
  }
};

// src/core/cli-args-builder.ts
var CliArgsBuilder = class {
  /**
   * Build CLI arguments array
   *
   * @param config Configuration for CLI arguments
   * @returns Array of CLI arguments
   */
  static buildArgs(config) {
    const args = [];
    args.push("--print");
    args.push("--verbose");
    args.push("--output-format", "stream-json");
    args.push("--input-format", "stream-json");
    args.push("--replay-user-messages");
    args.push("--include-partial-messages");
    if (config.sessionId) {
      args.push("--resume", config.sessionId);
    }
    if (config.settings.enablePermissionlessMode || config.bypassPermissions) {
      args.push("--permission-mode", "bypassPermissions");
    } else {
      args.push("--permission-mode", "acceptEdits");
    }
    if (config.settings.allowVaultAccess && config.vaultPath) {
      args.push("--add-dir", config.vaultPath);
    }
    const modelToUse = config.runtimeModelOverride || config.settings.modelAlias;
    if (modelToUse) {
      args.push("--model", modelToUse);
    }
    return args;
  }
};

// src/core/process-spawner.ts
var import_child_process = require("child_process");
var fs2 = __toESM(require("fs"));
var path3 = __toESM(require("path"));
var os = __toESM(require("os"));
var ProcessSpawner = class {
  /**
   * Check if running on Windows
   */
  static isWindows() {
    return process.platform === "win32";
  }
  /**
   * Get the default shell for the current platform
   */
  static getDefaultShell() {
    if (this.isWindows()) {
      if (process.env.COMSPEC) {
        return process.env.COMSPEC;
      }
      return "cmd.exe";
    }
    return process.env.SHELL || "/bin/sh";
  }
  /**
   * Get the PATH separator for the current platform
   */
  static getPathSeparator() {
    return this.isWindows() ? ";" : ":";
  }
  /**
   * Get the shell name from a shell path (e.g., "/bin/zsh" -> "zsh")
   */
  static getShellName(shellPath) {
    return path3.basename(shellPath);
  }
  /**
   * Get environment variables as if running in a login shell
   * This loads variables from .zshrc, .bash_profile, etc. on Unix
   * On Windows, it uses process.env directly as Windows doesn't have shell profiles
   */
  static getShellEnvironment(onDebugOutput) {
    if (this.isWindows()) {
      if (onDebugOutput) {
        onDebugOutput(`[DEBUG] Windows detected, using process.env directly
`);
      }
      return __spreadValues({}, process.env);
    }
    try {
      const shell = process.env.SHELL || "/bin/sh";
      const shellName = this.getShellName(shell);
      const homeDir = os.homedir();
      if (onDebugOutput) {
        onDebugOutput(`[DEBUG] Loading environment from shell: ${shell} (${shellName})
`);
        onDebugOutput(`[DEBUG] Home directory: ${homeDir}
`);
      }
      const startTime = Date.now();
      let sourceCommand;
      if (shellName === "zsh") {
        if (onDebugOutput) {
          onDebugOutput(`[DEBUG] Will source: ~/.zshenv, ~/.zprofile, ~/.zshrc
`);
        }
        sourceCommand = `${shell} -c 'source ~/.zshenv 2>/dev/null; source ~/.zprofile 2>/dev/null; source ~/.zshrc 2>/dev/null; env'`;
      } else if (shellName === "bash") {
        if (onDebugOutput) {
          onDebugOutput(`[DEBUG] Will source: ~/.profile, ~/.bash_profile, ~/.bashrc
`);
        }
        sourceCommand = `${shell} -c 'source ~/.profile 2>/dev/null; source ~/.bash_profile 2>/dev/null; source ~/.bashrc 2>/dev/null; env'`;
      } else if (shellName === "fish") {
        if (onDebugOutput) {
          onDebugOutput(`[DEBUG] Will source: fish config via login shell
`);
        }
        sourceCommand = `${shell} -l -c 'env'`;
      } else {
        if (onDebugOutput) {
          onDebugOutput(`[DEBUG] Using login shell fallback for: ${shellName}
`);
        }
        sourceCommand = `${shell} -l -c 'env'`;
      }
      const envOutput = (0, import_child_process.execSync)(sourceCommand, {
        encoding: "utf8",
        maxBuffer: 10 * 1024 * 1024,
        // 10MB buffer for large environments
        timeout: 5e3,
        // 5 second timeout
        env: __spreadProps(__spreadValues({}, process.env), { HOME: homeDir })
        // Ensure HOME is set
      });
      const duration = Date.now() - startTime;
      if (onDebugOutput) {
        onDebugOutput(`[DEBUG] Shell environment loaded in ${duration}ms
`);
        onDebugOutput(`[DEBUG] Raw output length: ${envOutput.length} bytes
`);
      }
      const env = {};
      const lines = envOutput.split("\n");
      if (onDebugOutput) {
        onDebugOutput(`[DEBUG] Parsing ${lines.length} lines of environment output
`);
      }
      lines.forEach((line) => {
        const idx = line.indexOf("=");
        if (idx > 0) {
          const key = line.substring(0, idx);
          const value = line.substring(idx + 1);
          env[key] = value;
        }
      });
      if (onDebugOutput) {
        onDebugOutput(`[DEBUG] Parsed ${Object.keys(env).length} environment variables
`);
        const processEnvKeys = Object.keys(process.env);
        const shellEnvKeys = Object.keys(env);
        const onlyInShell = shellEnvKeys.filter((k) => !processEnvKeys.includes(k));
        const onlyInProcess = processEnvKeys.filter((k) => !shellEnvKeys.includes(k));
        if (onlyInShell.length > 0) {
          onDebugOutput(`[DEBUG] Variables only in shell (${onlyInShell.length}): ${onlyInShell.slice(0, 10).join(", ")}${onlyInShell.length > 10 ? "..." : ""}
`);
        }
        if (onlyInProcess.length > 0) {
          onDebugOutput(`[DEBUG] Variables only in process.env (${onlyInProcess.length}): ${onlyInProcess.slice(0, 10).join(", ")}${onlyInProcess.length > 10 ? "..." : ""}
`);
        }
      }
      return env;
    } catch (error) {
      if (onDebugOutput) {
        onDebugOutput(`[DEBUG] \u26A0\uFE0F Failed to load shell environment: ${error}
`);
        onDebugOutput(`[DEBUG] Falling back to process.env
`);
      }
      return __spreadValues({}, process.env);
    }
  }
  /**
   * Spawn Claude Code process with enhanced environment
   *
   * @param config Spawn configuration
   * @returns Child process
   */
  static spawn(config) {
    const shellEnv = this.getShellEnvironment(config.onDebugOutput);
    if (config.customEnvVars) {
      const customVarCount = Object.keys(config.customEnvVars).filter((k) => config.customEnvVars[k]).length;
      if (customVarCount > 0 && config.onDebugOutput) {
        config.onDebugOutput(`[DEBUG] Applying ${customVarCount} custom environment variables:
`);
      }
      for (const [key, value] of Object.entries(config.customEnvVars)) {
        if (value) {
          shellEnv[key] = value;
          if (config.onDebugOutput) {
            const displayValue = key.includes("KEY") || key.includes("TOKEN") || key.includes("SECRET") ? `${value.substring(0, 8)}...` : value;
            config.onDebugOutput(`[DEBUG]   ${key}=${displayValue}
`);
          }
        }
      }
    }
    if (config.onDebugOutput) {
      config.onDebugOutput("[DEBUG] Shell environment variables loaded:\n");
      const sortedKeys = Object.keys(shellEnv).sort();
      const importantVars = ["PATH", "HOME", "SHELL", "USER", "ANTHROPIC_API_KEY", "NODE_ENV"];
      config.onDebugOutput("[DEBUG] Important variables:\n");
      for (const key of importantVars) {
        if (shellEnv[key]) {
          let value = shellEnv[key];
          if (key.includes("KEY") || key.includes("TOKEN") || key.includes("SECRET")) {
            value = value ? `${value.substring(0, 8)}...` : "";
          }
          config.onDebugOutput(`[DEBUG]   ${key}=${value}
`);
        }
      }
      config.onDebugOutput("[DEBUG] All environment variables:\n");
      for (const key of sortedKeys) {
        if (!importantVars.includes(key)) {
          let value = shellEnv[key];
          if (key.includes("KEY") || key.includes("TOKEN") || key.includes("SECRET") || key.includes("PASSWORD")) {
            value = value ? `${value.substring(0, 8)}...` : "";
          }
          config.onDebugOutput(`[DEBUG]   ${key}=${value}
`);
        }
      }
      config.onDebugOutput("\n");
    }
    let resolvedClaudePath = config.claudePath;
    if (resolvedClaudePath.startsWith("~")) {
      const homeDir = shellEnv.HOME || shellEnv.USERPROFILE || os.homedir();
      resolvedClaudePath = resolvedClaudePath.replace("~", homeDir);
    }
    if (!path3.isAbsolute(resolvedClaudePath)) {
      const pathSeparator = this.getPathSeparator();
      const pathDirs = (shellEnv.PATH || "").split(pathSeparator).filter((dir) => dir);
      const extensions = this.isWindows() ? ["", ".exe", ".cmd", ".bat"] : [""];
      for (const dir of pathDirs) {
        for (const ext of extensions) {
          const fullPath = path3.join(dir, resolvedClaudePath + ext);
          if (fs2.existsSync(fullPath)) {
            resolvedClaudePath = fullPath;
            break;
          }
        }
        if (path3.isAbsolute(resolvedClaudePath))
          break;
      }
    }
    if (config.onDebugOutput) {
      config.onDebugOutput(`[DEBUG] Resolved claude path: ${resolvedClaudePath}
`);
      config.onDebugOutput(`[DEBUG] Command: ${resolvedClaudePath} ${config.args.join(" ")}
`);
    }
    const shell = this.getDefaultShell();
    if (config.onDebugOutput) {
      config.onDebugOutput(`[DEBUG] Using shell: ${shell}
`);
      config.onDebugOutput(`[DEBUG] Platform: ${process.platform}
`);
    }
    const envWithUtf8 = __spreadProps(__spreadValues({}, shellEnv), {
      LANG: shellEnv.LANG || "en_US.UTF-8",
      LC_ALL: shellEnv.LC_ALL || "en_US.UTF-8",
      LC_CTYPE: shellEnv.LC_CTYPE || "en_US.UTF-8",
      PYTHONIOENCODING: "utf-8",
      // In case Claude CLI uses Python
      NODE_OPTIONS: shellEnv.NODE_OPTIONS ? `${shellEnv.NODE_OPTIONS} --input-type=module` : ""
    });
    const options = {
      cwd: config.workingDir,
      env: envWithUtf8,
      shell
    };
    const childProcess = (0, import_child_process.spawn)(resolvedClaudePath, config.args, options);
    if (childProcess.stdin) {
      childProcess.stdin.setDefaultEncoding("utf8");
    }
    return childProcess;
  }
  /**
   * Send stdin input to process
   *
   * @param process Child process
   * @param prompt Prompt to send
   */
  static sendInput(process2, prompt) {
    if (process2.stdin) {
      const inputMessage = {
        type: "user",
        message: {
          role: "user",
          content: prompt
        }
      };
      const jsonInput = JSON.stringify(inputMessage) + "\n";
      process2.stdin.write(jsonInput, "utf8");
      process2.stdin.end();
    }
  }
};

// src/core/response-parser.ts
var ResponseParser = class {
  /**
   * Parse JSON output lines from Claude Code
   *
   * @param outputLines Array of JSON output lines
   * @returns Parsed output with assistant text and token usage
   */
  static parseOutput(outputLines) {
    var _a, _b;
    let assistantText = "";
    let tokenUsage = void 0;
    for (const line of outputLines) {
      try {
        const event = JSON.parse(line);
        if (event.type === "stream_event") {
          if (event.event_type === "content_block_delta") {
            if (((_a = event.delta) == null ? void 0 : _a.type) === "text_delta" && event.delta.text) {
              assistantText += event.delta.text;
            }
          }
        }
        if (event.type === "assistant") {
          if ((_b = event.message) == null ? void 0 : _b.content) {
            for (const block of event.message.content) {
              if (block.type === "text") {
                assistantText += block.text + "\n";
              }
            }
          }
        }
        if (event.type === "result") {
          if (event.usage) {
            tokenUsage = {
              inputTokens: event.usage.input_tokens || 0,
              outputTokens: event.usage.output_tokens || 0,
              totalTokens: (event.usage.input_tokens || 0) + (event.usage.output_tokens || 0)
            };
          }
        }
      } catch (e) {
      }
    }
    return {
      assistantText: assistantText.trim(),
      tokenUsage
    };
  }
  /**
   * Build error response
   *
   * @param error Error message
   * @param outputLines Output lines (if any)
   * @returns Error response
   */
  static buildErrorResponse(error, outputLines = []) {
    return {
      success: false,
      error,
      output: outputLines
    };
  }
};

// src/core/streaming/response-content-extractor.ts
var ResponseContentExtractor = class {
  /**
   * Detect if Claude's response is asking for permission to perform an action
   *
   * @param text The text content to analyze
   * @returns True if the text contains a permission request pattern
   */
  static detectPermissionRequest(text) {
    return text.includes("REQUIRED_APPROVAL");
  }
};

// src/core/claude-code-runner.ts
var ClaudeCodeRunner = class {
  // Store session ID from init event
  constructor(settings) {
    this.currentProcess = null;
    this.outputCallback = null;
    this.currentSessionId = null;
    this.settings = settings;
  }
  /**
   * Run Claude Code with the given request
   */
  run(request, onOutput) {
    return __async(this, null, function* () {
      this.outputCallback = onOutput || null;
      let claudePath = this.settings.claudeCodePath || "claude";
      if (claudePath.startsWith("~")) {
        const homeDir = process.env.HOME || process.env.USERPROFILE || "";
        claudePath = claudePath.replace("~", homeDir);
      }
      if (!claudePath) {
        return {
          success: false,
          error: "Claude Code path not configured. Please set it in plugin settings.",
          output: []
        };
      }
      try {
        return yield this.executeClaudeCode(claudePath, request);
      } catch (error) {
        return {
          success: false,
          error: `Failed to execute Claude Code: ${error}`,
          output: []
        };
      }
    });
  }
  /**
   * Execute Claude Code process and capture output
   */
  executeClaudeCode(claudePath, request) {
    return __async(this, null, function* () {
      return new Promise((resolve) => {
        var _a, _b;
        const output = [];
        let errorOutput = "";
        const startTime = Date.now();
        const sessionInfo = SessionManager.getSessionInfo(
          request.notePath,
          request.vaultPath || "",
          request.configDir
        );
        this.sendOutput(
          sessionInfo.isNewSession ? `\u2192 Starting new session
` : `\u2713 Resuming session: ${sessionInfo.sessionId}
`
        );
        const noteFilePath = path4.join(sessionInfo.sessionDir, "note.md");
        const contentToEdit = request.selectedText || request.noteContent;
        try {
          fs3.writeFileSync(noteFilePath, contentToEdit, "utf8");
          this.sendOutput(`\u{1F4DD} Created note.md for editing
`);
        } catch (e) {
          this.sendOutput(`\u26A0\uFE0F Error creating note.md: ${e}
`);
        }
        const fullPrompt = PromptBuilder.buildPrompt(
          request,
          sessionInfo.sessionDir,
          this.settings.customSystemPrompt,
          this.settings.allowVaultAccess,
          this.settings.enablePermissionlessMode || request.bypassPermissions
        );
        const args = CliArgsBuilder.buildArgs({
          settings: this.settings,
          sessionId: sessionInfo.sessionId,
          vaultPath: request.vaultPath || null,
          bypassPermissions: request.bypassPermissions || false,
          runtimeModelOverride: request.runtimeModelOverride
        });
        if (this.settings.enablePermissionlessMode || request.bypassPermissions) {
          this.sendOutput(`\u{1F513} Permissionless mode enabled
`);
        } else {
          this.sendOutput(`\u{1F512} Permission mode: interactive (Claude will ask for permission)
`);
        }
        if (this.settings.allowVaultAccess && request.vaultPath) {
          this.sendOutput(`Vault access enabled: ${request.vaultPath}
`);
        }
        const workingDir = request.vaultPath || process.cwd();
        this.sendOutput(`Working dir: ${workingDir}
`);
        this.sendOutput(`Starting Claude Code...
`);
        this.sendOutput(`Session directory: ${sessionInfo.sessionDir}
`);
        this.sendOutput(`[DEBUG] Checking environment...
`);
        this.sendOutput(`[DEBUG] SHELL: ${process.env.SHELL}
`);
        this.sendOutput(`[DEBUG] HOME: ${process.env.HOME}
`);
        this.sendOutput(`[DEBUG] Claude path: ${claudePath}
`);
        const customEnvVars = {};
        if (this.settings.anthropicBaseUrl) {
          customEnvVars["ANTHROPIC_BASE_URL"] = this.settings.anthropicBaseUrl;
        }
        if (this.settings.anthropicAuthToken) {
          customEnvVars["ANTHROPIC_AUTH_TOKEN"] = this.settings.anthropicAuthToken;
        }
        if (this.settings.anthropicModel) {
          customEnvVars["ANTHROPIC_MODEL"] = this.settings.anthropicModel;
        }
        if (this.settings.anthropicSmallFastModel) {
          customEnvVars["ANTHROPIC_SMALL_FAST_MODEL"] = this.settings.anthropicSmallFastModel;
        }
        try {
          this.currentProcess = ProcessSpawner.spawn({
            claudePath,
            args,
            workingDir,
            onDebugOutput: (msg) => this.sendOutput(msg),
            customEnvVars: Object.keys(customEnvVars).length > 0 ? customEnvVars : void 0
          });
          this.sendOutput(`[DEBUG] Process spawned successfully, PID: ${this.currentProcess.pid}
`);
        } catch (spawnError) {
          this.sendOutput(`
\u274C Failed to spawn process: ${spawnError}`);
          throw spawnError;
        }
        ProcessSpawner.sendInput(this.currentProcess, fullPrompt);
        let timeoutId = null;
        if (this.settings.timeoutSeconds > 0) {
          timeoutId = setTimeout(() => {
            if (this.currentProcess) {
              this.sendOutput(`
Timeout after ${this.settings.timeoutSeconds} seconds, terminating...`);
              this.currentProcess.kill();
            }
          }, this.settings.timeoutSeconds * 1e3);
        }
        const stdoutDecoder = new import_string_decoder.StringDecoder("utf8");
        let buffer = "";
        (_a = this.currentProcess.stdout) == null ? void 0 : _a.on("data", (data) => {
          buffer += stdoutDecoder.write(data);
          const lines = buffer.split("\n");
          buffer = lines.pop() || "";
          for (const line of lines) {
            if (!line.trim())
              continue;
            try {
              const event = JSON.parse(line);
              output.push(line);
              this.handleStreamEvent(event);
            } catch (e) {
              this.sendOutput(`[raw] ${line}`);
            }
          }
        });
        const stderrDecoder = new import_string_decoder.StringDecoder("utf8");
        (_b = this.currentProcess.stderr) == null ? void 0 : _b.on("data", (data) => {
          const text = stderrDecoder.write(data);
          errorOutput += text;
          this.sendOutput(`[stderr] ${text}`);
        });
        this.sendOutput(`
[DEBUG] Process spawned, PID: ${this.currentProcess.pid}`);
        this.sendOutput(`[DEBUG] Working dir: ${workingDir}`);
        this.sendOutput(`[DEBUG] Session dir: ${sessionInfo.sessionDir}`);
        this.sendOutput(`[DEBUG] Waiting for output...
`);
        this.currentProcess.on("exit", (code, signal) => {
          this.sendOutput(`
[DEBUG] Process exited with code: ${code}, signal: ${signal}`);
        });
        this.currentProcess.on("close", (code) => {
          this.sendOutput(`
[DEBUG] Process closed with code: ${code}`);
          const claudeDir = path4.join(sessionInfo.sessionDir, ".claude");
          const claudeDirCreated = fs3.existsSync(claudeDir);
          this.sendOutput(`
[DEBUG] .claude directory after run: ${claudeDirCreated ? "EXISTS" : "NOT FOUND"}`);
          if (claudeDirCreated) {
            try {
              const contents = fs3.readdirSync(claudeDir);
              this.sendOutput(`
[DEBUG] .claude contents: ${contents.join(", ")}`);
            } catch (e) {
              this.sendOutput(`
[DEBUG] Error reading .claude: ${e}`);
            }
          }
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          this.currentProcess = null;
          if (code === 0) {
            this.sendOutput(`
[DEBUG] Processing ${output.length} output lines`);
            const parsed = ResponseParser.parseOutput(output);
            const isPermissionRequest = ResponseContentExtractor.detectPermissionRequest(parsed.assistantText);
            this.sendOutput(`
[DEBUG] Full response length: ${parsed.assistantText.length} chars`);
            let modifiedContent = void 0;
            try {
              if (fs3.existsSync(noteFilePath)) {
                const noteContent = fs3.readFileSync(noteFilePath, "utf8");
                if (noteContent !== contentToEdit && !request.conversationalMode) {
                  modifiedContent = noteContent;
                  this.sendOutput(`
\u2705 note.md was modified by Claude
`);
                } else {
                  this.sendOutput(`
 \u2139\uFE0F  note.md unchanged (likely a question/analysis)
`);
                }
              } else {
                this.sendOutput(`
\u26A0\uFE0F  note.md not found after execution
`);
              }
            } catch (e) {
              this.sendOutput(`
\u26A0\uFE0F  Error reading note.md: ${e}
`);
            }
            try {
              SessionManager.saveConversationHistory(
                sessionInfo.sessionDir,
                request.userPrompt,
                parsed.assistantText
              );
              this.sendOutput(`
\u{1F4BE} Conversation history saved
`);
              if (this.currentSessionId) {
                SessionManager.saveSessionId(sessionInfo.sessionDir, this.currentSessionId);
                this.sendOutput(`\u{1F4BE} Session ID saved: ${this.currentSessionId}
`);
              }
            } catch (e) {
              this.sendOutput(`
\u26A0 Error saving session data: ${e}
`);
            }
            const totalDuration = Date.now() - startTime;
            const response = {
              success: true,
              modifiedContent,
              assistantMessage: parsed.assistantText,
              output,
              tokenUsage: parsed.tokenUsage,
              isPermissionRequest
            };
            if (response.success) {
              if (modifiedContent) {
                this.sendOutput(`
\u2713 Claude Code completed successfully in ${(totalDuration / 1e3).toFixed(2)}s`);
              } else if (isPermissionRequest) {
                this.sendOutput(`
\u26A0\uFE0F Permission request detected - waiting for user approval`);
              } else {
                this.sendOutput(`
\u2713 Analysis completed (no file modifications) in ${(totalDuration / 1e3).toFixed(2)}s`);
              }
            }
            resolve(response);
          } else {
            this.sendOutput(`
\u2717 Claude Code failed with code ${code}`);
            if (errorOutput) {
              this.sendOutput(`Error output: ${errorOutput}`);
            }
            resolve(ResponseParser.buildErrorResponse(
              `Claude Code exited with code ${code}. ${errorOutput}`,
              output
            ));
          }
        });
        this.currentProcess.on("error", (err) => {
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          this.currentProcess = null;
          this.sendOutput(`
\u2717 Error: ${err.message}`);
          resolve(ResponseParser.buildErrorResponse(
            `Failed to spawn Claude Code: ${err.message}`,
            output
          ));
        });
      });
    });
  }
  /**
   * Send input to the current Claude Code process stdin
   */
  sendInput(input) {
    if (this.currentProcess && this.currentProcess.stdin) {
      try {
        this.currentProcess.stdin.write(input);
        this.sendOutput(`
[User input sent]: ${input.trim()}`);
        return true;
      } catch (error) {
        console.error("Failed to write to stdin:", error);
        this.sendOutput(`
\u2717 Failed to send input: ${error}`);
        return false;
      }
    }
    console.error("Cannot send input: no active process or stdin not available");
    return false;
  }
  /**
   * Terminate the current Claude Code process if running
   */
  terminate() {
    if (this.currentProcess) {
      this.currentProcess.kill();
      this.currentProcess = null;
      this.sendOutput("\n\u26A0 Process terminated by user");
    }
  }
  /**
   * Check if Claude Code is currently running
   */
  isRunning() {
    return this.currentProcess !== null;
  }
  /**
   * Handle stream-json events
   */
  handleStreamEvent(event) {
    StreamEventProcessor.processEvent(
      event,
      (text, isMarkdown, isStreaming, isAssistantMessage) => this.sendOutput(text, isMarkdown, isStreaming, isAssistantMessage),
      (sessionId) => {
        this.currentSessionId = sessionId;
      }
    );
  }
  /**
   * Send output to callback
   */
  sendOutput(text, isMarkdown = false, isStreaming, isAssistantMessage) {
    if (this.outputCallback) {
      this.outputCallback(text, isMarkdown, isStreaming, isAssistantMessage);
    }
  }
};

// src/managers/note-context-manager.ts
var NoteContextManager = class {
  constructor(settings, dataDir) {
    this.contexts = /* @__PURE__ */ new Map();
    this.settings = settings;
    this.dataDir = dataDir;
  }
  /**
   * Get or create context for a note
   */
  getContext(notePath) {
    if (!this.contexts.has(notePath)) {
      this.contexts.set(notePath, this.createNewContext());
    }
    return this.contexts.get(notePath);
  }
  /**
   * Create a new empty context
   */
  createNewContext() {
    return {
      history: [],
      sessionId: null,
      currentResponse: null,
      currentRequest: null,
      outputLines: [],
      agentSteps: [],
      runner: new ClaudeCodeRunner(this.settings),
      isRunning: false
    };
  }
  /**
   * Load all note contexts from disk
   */
  loadContexts(vaultPath) {
    var _a, _b, _c, _d;
    const contextsDir = path5.join(vaultPath, this.dataDir);
    if (!fs4.existsSync(contextsDir)) {
      return;
    }
    const noteDirs = fs4.readdirSync(contextsDir);
    for (const noteHash of noteDirs) {
      const contextFile = path5.join(contextsDir, noteHash, "context.json");
      if (fs4.existsSync(contextFile)) {
        try {
          const data = JSON.parse(fs4.readFileSync(contextFile, "utf8"));
          const context = {
            history: (_a = data.history) != null ? _a : [],
            sessionId: (_b = data.sessionId) != null ? _b : null,
            currentResponse: null,
            currentRequest: null,
            outputLines: (_c = data.outputLines) != null ? _c : [],
            agentSteps: (_d = data.agentSteps) != null ? _d : [],
            runner: new ClaudeCodeRunner(this.settings),
            isRunning: false,
            pendingPreviewContent: data.pendingPreviewContent,
            originalPreviewContent: data.originalPreviewContent
          };
          if (data.notePath) {
            this.contexts.set(data.notePath, context);
          }
        } catch (e) {
        }
      }
    }
  }
  /**
   * Save a note's context to disk
   */
  saveContext(notePath, vaultPath) {
    const context = this.contexts.get(notePath);
    if (!context)
      return;
    const noteHash = crypto2.createHash("md5").update(notePath).digest("hex");
    const contextDir = path5.join(vaultPath, this.dataDir, noteHash);
    if (!fs4.existsSync(contextDir)) {
      fs4.mkdirSync(contextDir, { recursive: true });
    }
    const contextFile = path5.join(contextDir, "context.json");
    const dataToSave = {
      notePath,
      sessionId: context.sessionId,
      history: context.history,
      outputLines: context.outputLines,
      agentSteps: context.agentSteps,
      pendingPreviewContent: context.pendingPreviewContent,
      originalPreviewContent: context.originalPreviewContent,
      savedAt: new Date().toISOString()
    };
    fs4.writeFileSync(contextFile, JSON.stringify(dataToSave, null, 2));
  }
  /**
   * Save all contexts
   */
  saveAllContexts(vaultPath) {
    for (const notePath of this.contexts.keys()) {
      this.saveContext(notePath, vaultPath);
    }
  }
  /**
   * Clear history for a note
   */
  clearHistory(notePath) {
    const context = this.contexts.get(notePath);
    if (context) {
      context.history = [];
      context.outputLines = [];
      context.agentSteps = [];
    }
  }
  /**
   * Get all contexts
   */
  getAllContexts() {
    return this.contexts;
  }
  /**
   * Check if a note has a context
   */
  hasContext(notePath) {
    return this.contexts.has(notePath);
  }
  /**
   * Get count of running processes
   */
  getRunningCount() {
    let count = 0;
    for (const context of this.contexts.values()) {
      if (context.isRunning) {
        count++;
      }
    }
    return count;
  }
  /**
   * Get list of note paths that are currently running
   */
  getRunningNotePaths() {
    const running = [];
    for (const [notePath, context] of this.contexts.entries()) {
      if (context.isRunning) {
        running.push(notePath);
      }
    }
    return running;
  }
};

// src/ui/parsers/output-status-manager.ts
var OutputStatusManager = class {
  /**
   * Parse an output line and extract status information
   *
   * @param line The output line to parse
   * @returns Status message to display, or null if no status should be shown
   */
  static extractStatus(line) {
    if (line.includes("\u{1F527} Using tool:")) {
      const toolMatch = line.match(/ Using tool: (\w+)/);
      if (toolMatch) {
        return `\u{1F527} Using ${toolMatch[1]} tool...`;
      }
    } else if (line.includes("$ ")) {
      const cmdMatch = line.match(/\$ (.+)/);
      if (cmdMatch) {
        const cmd = cmdMatch[1].substring(0, 50);
        return `\u26A1 Running: ${cmd}${cmdMatch[1].length > 50 ? "..." : ""}`;
      }
    } else if (line.includes("\u{1F50D} Query:") || line.includes("Query:")) {
      const queryMatch = line.match(/Query: "(.+?)"/);
      if (queryMatch) {
        const query = queryMatch[1].substring(0, 40);
        return `\u{1F50D} Searching: ${query}${queryMatch[1].length > 40 ? "..." : ""}`;
      }
    } else if (line.includes("\u{1F310} URL:") || line.includes("URL:")) {
      const urlMatch = line.match(/URL: (.+)/);
      if (urlMatch) {
        const url = urlMatch[1].substring(0, 40);
        return `\u{1F310} Fetching: ${url}${urlMatch[1].length > 40 ? "..." : ""}`;
      }
    } else if (line.includes("\u{1F4D6} Reading file:") || line.includes("\u{1F4D6} File:")) {
      const fileMatch = line.match(/(?:Reading file:|File:)\s+(.+)/);
      if (fileMatch) {
        const file = fileMatch[1].split("/").pop() || fileMatch[1];
        return `\u{1F4D6} Reading: ${file.substring(0, 40)}...`;
      }
    } else if (line.includes("\u270D\uFE0F  Writing file:") || line.includes("\u270D\uFE0F  File:")) {
      const fileMatch = line.match(/(?:Writing file:|File:)\s+(.+)/);
      if (fileMatch) {
        const file = fileMatch[1].split("/").pop() || fileMatch[1];
        return `\u270D\uFE0F Writing: ${file.substring(0, 40)}...`;
      }
    } else if (line.includes("\u270F\uFE0F  Editing file:") || line.includes("\u270F\uFE0F  File:")) {
      const fileMatch = line.match(/(?:Editing file:|File:)\s+(.+)/);
      if (fileMatch) {
        const file = fileMatch[1].split("/").pop() || fileMatch[1];
        return `\u270F\uFE0F Editing: ${file.substring(0, 40)}...`;
      }
    } else if (line.includes("\u{1F50D} Pattern:") || line.includes("Pattern:")) {
      const patternMatch = line.match(/Pattern: (.+)/);
      if (patternMatch) {
        const pattern = patternMatch[1].substring(0, 40);
        return `\u{1F50E} Searching pattern: ${pattern}${patternMatch[1].length > 40 ? "..." : ""}`;
      }
    } else if (line.includes("\u{1F916} Launching agent:") || line.includes("Agent:")) {
      const agentMatch = line.match(/(?:Agent:|Type:)\s+(.+)/);
      if (agentMatch) {
        return `\u{1F916} Launching ${agentMatch[1]} agent...`;
      }
    } else if (line.includes("\u{1F4AC}") && !line.includes("[raw]")) {
      return "\u{1F4AC} Claude is responding...";
    } else if (line.includes("\u2713") && line.includes("complete")) {
      return "\u2705 Processing results...";
    }
    return null;
  }
};

// src/ui/renderers/diff-generator.ts
var DiffGenerator = class {
  /**
   * Generate side-by-side diff view as a DOM element between original and modified content
   *
   * @param original Original content
   * @param modified Modified content
   * @returns HTMLElement representing the side-by-side diff
   */
  static generateDiffElement(original, modified) {
    const originalLines = original.split("\n");
    const modifiedLines = modified.split("\n");
    const diff = this.computeDiff(originalLines, modifiedLines);
    const container = document.createElement("div");
    container.className = "claude-code-diff-side-by-side";
    const header = document.createElement("div");
    header.className = "diff-header";
    const leftHeader = document.createElement("div");
    leftHeader.className = "diff-column diff-column-left";
    const leftTitle = document.createElement("span");
    leftTitle.className = "diff-header-title";
    leftTitle.textContent = t("diff.original");
    leftHeader.appendChild(leftTitle);
    const rightHeader = document.createElement("div");
    rightHeader.className = "diff-column diff-column-right";
    const rightTitle = document.createElement("span");
    rightTitle.className = "diff-header-title";
    rightTitle.textContent = t("diff.modified");
    rightHeader.appendChild(rightTitle);
    header.appendChild(leftHeader);
    header.appendChild(rightHeader);
    container.appendChild(header);
    const content = document.createElement("div");
    content.className = "diff-content";
    for (const change of diff) {
      const row = document.createElement("div");
      row.className = `diff-row diff-${change.type}`;
      if (change.type === "equal") {
        row.appendChild(this.createDiffColumn("left", change.oldLineNum, change.oldContent));
        row.appendChild(this.createDiffColumn("right", change.newLineNum, change.newContent));
      } else if (change.type === "delete") {
        row.appendChild(this.createDiffColumn("left", change.oldLineNum, change.oldContent));
        row.appendChild(this.createDiffColumn("right", void 0, void 0, true));
      } else if (change.type === "insert") {
        row.appendChild(this.createDiffColumn("left", void 0, void 0, true));
        row.appendChild(this.createDiffColumn("right", change.newLineNum, change.newContent));
      } else if (change.type === "modify") {
        row.appendChild(this.createDiffColumn("left", change.oldLineNum, change.oldContent));
        row.appendChild(this.createDiffColumn("right", change.newLineNum, change.newContent));
      }
      content.appendChild(row);
    }
    container.appendChild(content);
    return container;
  }
  /**
   * Create a diff column element
   */
  static createDiffColumn(side, lineNum, content, isEmpty = false) {
    const column = document.createElement("div");
    column.className = `diff-column diff-column-${side}${isEmpty ? " diff-empty" : ""}`;
    const lineNumSpan = document.createElement("span");
    lineNumSpan.className = "diff-line-number";
    lineNumSpan.textContent = lineNum !== void 0 ? String(lineNum) : "";
    const contentSpan = document.createElement("span");
    contentSpan.className = "diff-line-content";
    contentSpan.textContent = content || "";
    column.appendChild(lineNumSpan);
    column.appendChild(contentSpan);
    return column;
  }
  /**
   * Compute diff between two arrays of lines using a simple algorithm
   *
   * @param oldLines Original lines
   * @param newLines Modified lines
   * @returns Array of diff changes
   */
  static computeDiff(oldLines, newLines) {
    const result = [];
    let oldIndex = 0;
    let newIndex = 0;
    let oldLineNum = 1;
    let newLineNum = 1;
    while (oldIndex < oldLines.length || newIndex < newLines.length) {
      if (oldIndex >= oldLines.length) {
        result.push({
          type: "insert",
          newContent: newLines[newIndex],
          newLineNum
        });
        newIndex++;
        newLineNum++;
      } else if (newIndex >= newLines.length) {
        result.push({
          type: "delete",
          oldContent: oldLines[oldIndex],
          oldLineNum
        });
        oldIndex++;
        oldLineNum++;
      } else if (oldLines[oldIndex] === newLines[newIndex]) {
        result.push({
          type: "equal",
          oldContent: oldLines[oldIndex],
          newContent: newLines[newIndex],
          oldLineNum,
          newLineNum
        });
        oldIndex++;
        newIndex++;
        oldLineNum++;
        newLineNum++;
      } else {
        result.push({
          type: "modify",
          oldContent: oldLines[oldIndex],
          newContent: newLines[newIndex],
          oldLineNum,
          newLineNum
        });
        oldIndex++;
        newIndex++;
        oldLineNum++;
        newLineNum++;
      }
    }
    return result;
  }
};

// src/ui/tool-call-tracker.ts
var ToolCallTracker = class {
  constructor() {
    this.calls = /* @__PURE__ */ new Map();
    this.callbacks = /* @__PURE__ */ new Set();
  }
  /**
   * Start tracking a tool call
   */
  startCall(id, toolName, args) {
    const call = {
      id,
      toolName,
      arguments,
      status: "pending",
      startTime: Date.now()
    };
    this.calls.set(id, call);
    this.notifyCallbacks(call);
    return call;
  }
  /**
   * Update tool call status
   */
  updateStatus(id, status, result, error) {
    const call = this.calls.get(id);
    if (!call) {
      console.warn(`Tool call ${id} not found`);
      return;
    }
    call.status = status;
    if (status === "completed" || status === "failed") {
      call.endTime = Date.now();
    }
    if (result !== void 0) {
      call.result = result;
    }
    if (error !== void 0) {
      call.error = error;
    }
    this.notifyCallbacks(call);
  }
  /**
   * Get a tool call by ID
   */
  getCall(id) {
    return this.calls.get(id);
  }
  /**
   * Get all tool calls
   */
  getAllCalls() {
    return Array.from(this.calls.values());
  }
  /**
   * Get active (non-completed) tool calls
   */
  getActiveCalls() {
    return this.getAllCalls().filter(
      (call) => call.status !== "completed" && call.status !== "failed"
    );
  }
  /**
   * Clear completed calls
   */
  clearCompleted() {
    const activeCalls = this.getActiveCalls();
    this.calls.clear();
    for (const call of activeCalls) {
      this.calls.set(call.id, call);
    }
  }
  /**
   * Clear all calls
   */
  clearAll() {
    this.calls.clear();
  }
  /**
   * Subscribe to tool call updates
   */
  onToolCallUpdate(callback) {
    this.callbacks.add(callback);
    return () => this.callbacks.delete(callback);
  }
  /**
   * Notify all callbacks of a tool call update
   */
  notifyCallbacks(call) {
    this.callbacks.forEach((callback) => {
      try {
        callback(call);
      } catch (error) {
        console.error("Error in tool call callback:", error);
      }
    });
  }
  /**
   * Get duration of a tool call in milliseconds
   */
  getDuration(id) {
    const call = this.calls.get(id);
    if (!call) {
      return void 0;
    }
    const endTime = call.endTime || Date.now();
    return endTime - call.startTime;
  }
  /**
   * Get statistics
   */
  getStats() {
    const calls = this.getAllCalls();
    return {
      total: calls.length,
      pending: calls.filter((c) => c.status === "pending").length,
      running: calls.filter((c) => c.status === "running").length,
      completed: calls.filter((c) => c.status === "completed").length,
      failed: calls.filter((c) => c.status === "failed").length
    };
  }
};

// src/ui/components/tool-call-display.ts
var ToolCallDisplay = class {
  constructor(container, tracker) {
    this.toolCallElements = /* @__PURE__ */ new Map();
    this.container = container;
    this.tracker = tracker;
    this.unsubscribe = this.tracker.onToolCallUpdate((call) => {
      this.updateToolCallDisplay(call);
    });
    this.render();
  }
  /**
   * Destroy the component
   */
  destroy() {
    this.unsubscribe();
    this.toolCallElements.clear();
    this.container.empty();
  }
  /**
   * Render initial UI
   */
  render() {
    this.container.empty();
    const header = this.container.createEl("div", {
      cls: "claude-code-tool-call-header"
    });
    header.createEl("h3", {
      text: "Tool Calls",
      cls: "claude-code-tool-call-title"
    });
    const stats = this.container.createEl("div", {
      cls: "claude-code-tool-call-stats"
    });
    this.updateStats(stats);
    const callsContainer = this.container.createEl("div", {
      cls: "claude-code-tool-calls-container"
    });
    const calls = this.tracker.getAllCalls();
    for (const call of calls) {
      this.renderToolCall(call, callsContainer);
    }
    setInterval(() => {
      this.updateStats(stats);
    }, 1e3);
  }
  /**
   * Update statistics display
   */
  updateStats(statsEl) {
    const stats = this.tracker.getStats();
    statsEl.empty();
    statsEl.createEl("span", {
      text: `Total: ${stats.total}`,
      cls: "claude-code-stat-total"
    });
    if (stats.pending > 0) {
      statsEl.createEl("span", {
        text: `Pending: ${stats.pending}`,
        cls: "claude-code-stat-pending"
      });
    }
    if (stats.running > 0) {
      statsEl.createEl("span", {
        text: `Running: ${stats.running}`,
        cls: "claude-code-stat-running"
      });
    }
    if (stats.completed > 0) {
      statsEl.createEl("span", {
        text: `Completed: ${stats.completed}`,
        cls: "claude-code-stat-completed"
      });
    }
    if (stats.failed > 0) {
      statsEl.createEl("span", {
        text: `Failed: ${stats.failed}`,
        cls: "claude-code-stat-failed"
      });
    }
  }
  /**
   * Render a single tool call
   */
  renderToolCall(call, container) {
    const callEl = container.createEl("div", {
      cls: `claude-code-tool-call claude-code-tool-call-${call.status}`
    });
    const header = callEl.createEl("div", {
      cls: "claude-code-tool-call-header-section"
    });
    const statusIcon = header.createEl("span", {
      cls: `claude-code-tool-call-status-icon claude-code-status-${call.status}`
    });
    header.createEl("span", {
      text: call.toolName,
      cls: "claude-code-tool-call-name"
    });
    if (call.status !== "pending") {
      const duration = this.tracker.getDuration(call.id);
      if (duration !== void 0) {
        header.createEl("span", {
          text: this.formatDuration(duration),
          cls: "claude-code-tool-call-duration"
        });
      }
    }
    const details = callEl.createEl("div", {
      cls: "claude-code-tool-call-details"
    });
    if (call.arguments && Object.keys(call.arguments).length > 0) {
      const argsSection = details.createEl("div", {
        cls: "claude-code-tool-call-arguments"
      });
      argsSection.createEl("h4", { text: "Arguments" });
      argsSection.createEl("pre", {
        text: JSON.stringify(call.arguments, null, 2)
      });
    }
    if (call.status === "completed" && call.result !== void 0) {
      const resultSection = details.createEl("div", {
        cls: "claude-code-tool-call-result"
      });
      resultSection.createEl("h4", { text: "Result" });
      resultSection.createEl("pre", {
        text: JSON.stringify(call.result, null, 2)
      });
    }
    if (call.status === "failed" && call.error) {
      const errorSection = details.createEl("div", {
        cls: "claude-code-tool-call-error"
      });
      errorSection.createEl("h4", { text: "Error" });
      errorSection.createEl("pre", { text: call.error });
    }
    header.addClass("clickable");
    header.addEventListener("click", (_event) => {
      details.toggleClass("collapsed");
    });
    this.toolCallElements.set(call.id, callEl);
  }
  /**
   * Update tool call display when state changes
   */
  updateToolCallDisplay(call) {
    const existingEl = this.toolCallElements.get(call.id);
    if (!existingEl) {
      const container = this.container.querySelector(".claude-code-tool-calls-container");
      if (container) {
        this.renderToolCall(call, container);
      }
      return;
    }
    existingEl.className = `claude-code-tool-call claude-code-tool-call-${call.status}`;
    const statusIcon = existingEl.querySelector(".claude-code-tool-call-status-icon");
    if (statusIcon) {
      statusIcon.className = `claude-code-tool-call-status-icon claude-code-status-${call.status}`;
    }
    const durationEl = existingEl.querySelector(".claude-code-tool-call-duration");
    if (durationEl && call.status !== "pending") {
      const duration = this.tracker.getDuration(call.id);
      if (duration !== void 0) {
        durationEl.textContent = this.formatDuration(duration);
      }
    }
    const details = existingEl.querySelector(".claude-code-tool-call-details");
    if (details) {
      const oldResult = details.querySelector(".claude-code-tool-call-result");
      const oldError = details.querySelector(".claude-code-tool-call-error");
      if (oldResult)
        oldResult.remove();
      if (oldError)
        oldError.remove();
      if (call.status === "completed" && call.result !== void 0) {
        const resultSection = details.createEl("div", {
          cls: "claude-code-tool-call-result"
        });
        resultSection.createEl("h4", { text: "Result" });
        resultSection.createEl("pre", {
          text: JSON.stringify(call.result, null, 2)
        });
      }
      if (call.status === "failed" && call.error) {
        const errorSection = details.createEl("div", {
          cls: "claude-code-tool-call-error"
        });
        errorSection.createEl("h4", { text: "Error" });
        errorSection.createEl("pre", { text: call.error });
      }
    }
  }
  /**
   * Format duration in human-readable format
   */
  formatDuration(ms) {
    if (ms < 1e3) {
      return `${ms}ms`;
    } else if (ms < 6e4) {
      return `${(ms / 1e3).toFixed(1)}s`;
    } else {
      const minutes = Math.floor(ms / 6e4);
      const seconds = Math.floor(ms % 6e4 / 1e3);
      return `${minutes}m ${seconds}s`;
    }
  }
  /**
   * Clear completed calls from display
   */
  clearCompleted() {
    const container = this.container.querySelector(".claude-code-tool-calls-container");
    if (!container)
      return;
    const completedCalls = this.tracker.getAllCalls().filter(
      (call) => call.status === "completed" || call.status === "failed"
    );
    for (const call of completedCalls) {
      const el = this.toolCallElements.get(call.id);
      if (el) {
        el.remove();
        this.toolCallElements.delete(call.id);
      }
    }
    this.tracker.clearCompleted();
  }
  /**
   * Clear all calls from display
   */
  clearAll() {
    this.toolCallElements.clear();
    this.tracker.clearAll();
    this.render();
  }
};

// src/ui/streaming-renderer.ts
var import_obsidian2 = require("obsidian");
var StreamingRenderer = class {
  constructor(view, container) {
    this.currentStreamElement = null;
    this.accumulatedContent = "";
    this.isStreaming = false;
    this.view = view;
    this.container = container;
  }
  /**
   * Start a new stream
   */
  startStream() {
    this.isStreaming = true;
    this.accumulatedContent = "";
    this.currentStreamElement = this.container.createEl("div", {
      cls: "claude-code-streaming-response"
    });
    const header = this.currentStreamElement.createEl("div", {
      cls: "claude-code-stream-header"
    });
    header.createEl("span", {
      text: "AI Response",
      cls: "claude-code-stream-title"
    });
    const statusIndicator = header.createEl("span", {
      text: "Streaming...",
      cls: "claude-code-stream-status streaming"
    });
    const contentArea = this.currentStreamElement.createEl("div", {
      cls: "claude-code-stream-content"
    });
    this.currentStreamElement._statusIndicator = statusIndicator;
    this.currentStreamElement._contentArea = contentArea;
    this.scrollToBottom();
  }
  /**
   * Append a chunk of content to the stream
   */
  appendChunk(chunk) {
    return __async(this, null, function* () {
      if (!this.currentStreamElement || !this.isStreaming) {
        console.warn("No active stream to append to");
        return;
      }
      if (chunk.content) {
        this.accumulatedContent += chunk.content;
        const contentArea = this.currentStreamElement._contentArea;
        if (contentArea) {
          contentArea.empty();
          const markdownContainer = contentArea.createEl("div");
          yield import_obsidian2.MarkdownRenderer.renderMarkdown(
            this.accumulatedContent,
            markdownContainer,
            "",
            this.view
          );
        }
        this.scrollToBottom();
      }
      if (chunk.isComplete) {
        this.completeStream(chunk.metadata);
      }
    });
  }
  /**
   * Complete the current stream
   */
  completeStream(metadata) {
    if (!this.currentStreamElement) {
      return;
    }
    this.isStreaming = false;
    const statusIndicator = this.currentStreamElement._statusIndicator;
    if (statusIndicator) {
      statusIndicator.textContent = "Complete";
      statusIndicator.removeClass("streaming");
      statusIndicator.addClass("complete");
    }
    if (metadata) {
      this.addMetadata(metadata);
    }
    this.currentStreamElement.removeClass("claude-code-streaming-response");
    this.currentStreamElement.addClass("claude-code-response");
    this.currentStreamElement = null;
    this.accumulatedContent = "";
  }
  /**
   * Add metadata display (token usage, model, etc.)
   */
  addMetadata(metadata) {
    if (!this.currentStreamElement || !metadata) {
      return;
    }
    const metadataEl = this.currentStreamElement.createEl("div", {
      cls: "claude-code-stream-metadata"
    });
    if (metadata.model) {
      metadataEl.createEl("span", {
        text: `Model: ${metadata.model}`,
        cls: "claude-code-metadata-item"
      });
    }
    if (metadata.usage) {
      const tokensText = `Tokens: ${metadata.usage.promptTokens} + ${metadata.usage.completionTokens} = ${metadata.usage.totalTokens}`;
      metadataEl.createEl("span", {
        text: tokensText,
        cls: "claude-code-metadata-item"
      });
    }
    if (metadata.finishReason) {
      metadataEl.createEl("span", {
        text: `Finished: ${metadata.finishReason}`,
        cls: "claude-code-metadata-item"
      });
    }
  }
  /**
   * Cancel the current stream
   */
  cancelStream() {
    if (!this.currentStreamElement) {
      return;
    }
    this.isStreaming = false;
    const statusIndicator = this.currentStreamElement._statusIndicator;
    if (statusIndicator) {
      statusIndicator.textContent = "Cancelled";
      statusIndicator.removeClass("streaming");
      statusIndicator.addClass("cancelled");
    }
    this.currentStreamElement = null;
    this.accumulatedContent = "";
  }
  /**
   * Check if currently streaming
   */
  isActive() {
    return this.isStreaming && this.currentStreamElement !== null;
  }
  /**
   * Get the current stream element
   */
  getCurrentElement() {
    return this.currentStreamElement;
  }
  /**
   * Scroll the container to the bottom
   */
  scrollToBottom() {
    if (this.container) {
      this.container.scrollTop = this.container.scrollHeight;
    }
  }
  /**
   * Handle incoming stream message
   */
  handleStreamMessage(message) {
    return __async(this, null, function* () {
      if (!this.isActive()) {
        this.startStream();
      }
      yield this.appendChunk(message.chunk);
    });
  }
  /**
   * Clear all streams
   */
  clear() {
    this.isStreaming = false;
    this.currentStreamElement = null;
    this.accumulatedContent = "";
    this.container.empty();
  }
};

// src/ui/view.ts
var ClaudeCodeView = class extends import_obsidian3.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.currentResultStreamingElement = null;
    this.hitFinalContentMarker = false;
    this.userHasScrolled = false;
    this.lastRenderedText = "";
    this.toolCallDisplay = null;
    this.streamingRenderer = null;
    // State
    this.currentNotePath = "";
    // Tool timing tracking
    this.toolStartTimes = /* @__PURE__ */ new Map();
    this.lastToolKey = null;
    // Execution timing tracking (interval is view-level, but start time is per-note in context)
    this.elapsedTimeInterval = null;
    // Event listener cleanup tracking
    this.eventListeners = [];
    this.promptInputKeydownHandler = null;
    this.plugin = plugin;
    this.contextManager = new NoteContextManager(
      this.plugin.settings,
      `${this.app.vault.configDir}/claude-code-sessions`
    );
    this.agentTracker = new AgentActivityTracker();
    this.toolCallTracker = new ToolCallTracker();
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.onActiveNoteChange();
      })
    );
  }
  getViewType() {
    return VIEW_TYPE_CLAUDE_CODE;
  }
  getDisplayText() {
    return "Claude Code";
  }
  getIcon() {
    return "bot";
  }
  /**
   * Get the tool call tracker instance
   */
  getToolCallTracker() {
    return this.toolCallTracker;
  }
  /**
   * Get the streaming renderer instance
   */
  getStreamingRenderer() {
    return this.streamingRenderer;
  }
  onOpen() {
    return __async(this, null, function* () {
      const container = this.containerEl.children[1];
      container.empty();
      container.addClass("claude-code-view");
      const vaultPath = this.app.vault.adapter.getBasePath();
      if (vaultPath) {
        this.contextManager.loadContexts(vaultPath);
      }
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile) {
        this.currentNotePath = activeFile.path;
      }
      this.buildUI(container);
      this.outputRenderer = new OutputRenderer(this.outputArea, this, this.app, this.currentNotePath, this.outputSection);
      this.streamingRenderer = new StreamingRenderer(this, this.outputArea);
      if (this.currentNotePath) {
        this.loadNoteContext(this.currentNotePath);
      }
    });
  }
  /**
   * Build the entire UI using modular components
   */
  buildUI(container) {
    this.currentNoteLabel = UIBuilder.buildHeader(container);
    this.updateCurrentNoteLabel();
    const inputElements = UIBuilder.buildInputSection(
      container,
      this.plugin.settings.autoAcceptChanges,
      () => void this.handleRunClaudeCode(),
      () => this.handleCancel()
    );
    this.promptInput = inputElements.promptInput;
    this.selectedTextOnlyCheckbox = inputElements.selectedTextOnlyCheckbox;
    this.autoAcceptCheckbox = inputElements.autoAcceptCheckbox;
    this.conversationalModeCheckbox = inputElements.conversationalModeCheckbox;
    this.modelSelect = inputElements.modelSelect;
    this.runButton = inputElements.runButton;
    this.cancelButton = inputElements.cancelButton;
    this.conversationalModeCheckbox.addEventListener("change", () => {
      const isConversational = this.conversationalModeCheckbox.checked;
      this.selectedTextOnlyCheckbox.disabled = isConversational;
      this.autoAcceptCheckbox.disabled = isConversational;
      if (isConversational) {
        this.selectedTextOnlyCheckbox.checked = false;
        this.autoAcceptCheckbox.checked = false;
      }
    });
    this.modelSelect.addEventListener("change", () => {
      const context = this.getCurrentContext();
      context.selectedModel = this.modelSelect.value;
    });
    this.promptInputKeydownHandler = (e) => {
      var _a, _b;
      if (e.key === "Enter" && !e.shiftKey && !e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        void this.handleRunClaudeCode();
      } else if (e.key === "Enter" && (e.ctrlKey || e.metaKey)) {
        e.preventDefault();
        const start = (_a = this.promptInput.selectionStart) != null ? _a : 0;
        const end = (_b = this.promptInput.selectionEnd) != null ? _b : 0;
        const value = this.promptInput.value;
        this.promptInput.value = value.substring(0, start) + "\n" + value.substring(end);
        this.promptInput.selectionStart = this.promptInput.selectionEnd = start + 1;
      }
    };
    this.promptInput.addEventListener("keydown", this.promptInputKeydownHandler);
    UIBuilder.buildInteractivePromptSection(
      container,
      (response) => this.respondToPrompt(response)
    );
    const resultElements = UIBuilder.buildResultSection(container);
    this.resultArea = resultElements.resultArea;
    this.statusIndicator = resultElements.statusArea;
    this.statusText = resultElements.statusText;
    this.lastPromptArea = resultElements.lastPromptArea;
    this.setupSmartAutoScroll();
    const permissionElements = UIBuilder.buildPermissionApprovalSection(
      container,
      () => void this.handleApprovePermission(),
      () => this.handleDenyPermission()
    );
    this.permissionApprovalSection = permissionElements.permissionApprovalSection;
    const previewElements = UIBuilder.buildPreviewSection(
      container,
      () => this.handleApplyChanges(),
      () => this.handleRejectChanges()
    );
    this.previewArea = previewElements.previewArea;
    this.previewContentContainer = previewElements.previewContentContainer;
    UIBuilder.buildAgentSection(container);
    const activityColumn = container.querySelector(".claude-code-activity-column");
    if (activityColumn) {
      this.agentTracker.initialize(activityColumn);
    }
    const toolCallSection = container.createEl("div", {
      cls: "claude-code-tool-call-section"
    });
    this.toolCallDisplay = new ToolCallDisplay(toolCallSection, this.toolCallTracker);
    const outputSectionResult = UIBuilder.buildOutputSection(container);
    this.outputArea = outputSectionResult.outputArea;
    this.outputSection = outputSectionResult.outputSection;
    this.historyList = UIBuilder.buildHistorySection(
      container,
      () => this.clearHistory()
    );
  }
  /**
   * Update the current note label
   */
  updateCurrentNoteLabel() {
    if (this.currentNotePath) {
      const fileName = this.currentNotePath.split("/").pop() || "Unknown";
      const context = this.contextManager.getContext(this.currentNotePath);
      const runningIndicator = context.isRunning ? " \u{1F504}" : "";
      this.currentNoteLabel.textContent = `\u{1F4DD} ${fileName}${runningIndicator}`;
    } else {
      this.currentNoteLabel.textContent = "\u{1F4DD} " + t("header.noNoteSelected");
    }
    this.updateRunningIndicator();
  }
  /**
   * Update the indicator showing how many other notes have running processes
   */
  updateRunningIndicator() {
    var _a, _b;
    const runningPaths = this.contextManager.getRunningNotePaths();
    const otherRunning = runningPaths.filter((p) => p !== this.currentNotePath);
    let indicator = (_a = this.currentNoteLabel.parentElement) == null ? void 0 : _a.querySelector(".claude-code-running-indicator");
    if (otherRunning.length > 0) {
      if (!indicator) {
        indicator = document.createElement("span");
        indicator.addClass("claude-code-running-indicator");
        (_b = this.currentNoteLabel.parentElement) == null ? void 0 : _b.appendChild(indicator);
      }
      const noteNames = otherRunning.map((p) => p.split("/").pop() || "Unknown").join(", ");
      indicator.textContent = ` (${otherRunning.length} other running)`;
      indicator.setAttribute("title", `Running: ${noteNames}`);
      indicator.removeClass("claude-code-hidden");
    } else if (indicator) {
      indicator.addClass("claude-code-hidden");
    }
  }
  /**
   * Handle active note change
   */
  onActiveNoteChange() {
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile && activeFile.path !== this.currentNotePath) {
      this.currentNotePath = activeFile.path;
      this.updateCurrentNoteLabel();
      this.loadNoteContext(this.currentNotePath);
    }
  }
  /**
   * Load context for a specific note
   */
  loadNoteContext(notePath) {
    var _a, _b, _c, _d;
    const context = this.contextManager.getContext(notePath);
    (_a = this.outputRenderer) == null ? void 0 : _a.setNotePath(notePath);
    (_b = this.outputRenderer) == null ? void 0 : _b.clear();
    for (const line of context.outputLines) {
      (_c = this.outputRenderer) == null ? void 0 : _c.appendLine(line);
    }
    this.agentTracker.restore(context.agentSteps);
    console.debug("[Load Note Context] Output lines count:", context.outputLines.length);
    console.debug("[Load Note Context] Agent steps count:", context.agentSteps.length);
    console.debug("[Load Note Context] isRunning:", context.isRunning);
    if (context.outputLines.length > 0) {
      this.parseTodosFromOutput();
    } else {
      console.debug("[Load Note Context] Clearing todo list - no output");
      this.clearTodoList();
    }
    this.updateHistoryDisplay(context.history);
    if (context.selectedModel !== void 0) {
      this.modelSelect.value = context.selectedModel;
    } else {
      this.modelSelect.value = this.plugin.settings.modelAlias;
    }
    if (context.lastPrompt) {
      this.showLastPrompt(context.lastPrompt);
    } else {
      this.hideLastPrompt();
    }
    if (context.isRunning) {
      this.runButton.disabled = true;
      this.runButton.textContent = t("input.runningButton");
      this.cancelButton.removeClass("claude-code-hidden");
      this.cancelButton.addClass("claude-code-inline-visible");
      this.resumeElapsedTimeTracking();
      if (context.currentResultText) {
        this.restoreStreamingResult(context.currentResultText);
      }
    } else {
      this.stopElapsedTimeTracking();
      this.runButton.disabled = false;
      this.runButton.textContent = t("input.runButton");
      this.cancelButton.addClass("claude-code-hidden");
      this.cancelButton.removeClass("claude-code-inline-visible");
      this.hideStatus();
      if (!context.currentResponse || !context.currentResponse.assistantMessage) {
        this.hideResult();
      } else {
        this.showResult(context.currentResponse.assistantMessage);
      }
    }
    if (context.pendingPreviewContent) {
      this.restorePreview(context.pendingPreviewContent, context.originalPreviewContent || "");
    } else {
      this.hidePreviewUI();
    }
    if (((_d = context.currentResponse) == null ? void 0 : _d.isPermissionRequest) && !context.isRunning) {
      this.showPermissionApprovalSection();
    } else {
      this.hidePermissionApprovalSection();
    }
  }
  /**
   * Get current note's context
   */
  getCurrentContext() {
    return this.contextManager.getContext(this.currentNotePath);
  }
  /**
   * Handle Run Claude Code button click
   */
  handleRunClaudeCode() {
    return __async(this, null, function* () {
      const context = this.getCurrentContext();
      if (context.isRunning) {
        new import_obsidian3.Notice(t("notice.alreadyProcessing"));
        return;
      }
      const prompt = this.promptInput.value.trim();
      if (!prompt) {
        new import_obsidian3.Notice(t("notice.enterPrompt"));
        return;
      }
      this.resetScrollState();
      try {
        this.promptInput.value = "";
        const file = this.app.workspace.getActiveFile();
        if (!file) {
          new import_obsidian3.Notice(t("notice.noActiveNote"));
          return;
        }
        const leaves = this.app.workspace.getLeavesOfType("markdown");
        let activeView = null;
        for (const leaf of leaves) {
          const view = leaf.view;
          if (view.file && view.file.path === file.path) {
            activeView = view;
            break;
          }
        }
        if (!activeView && leaves.length > 0) {
          activeView = leaves[0].view;
        }
        if (!activeView || !activeView.editor) {
          new import_obsidian3.Notice(t("notice.noEditor"));
          return;
        }
        const editor = activeView.editor;
        const selectedText = editor.getSelection();
        const useSelectedTextOnly = this.selectedTextOnlyCheckbox.checked && selectedText;
        const noteContent = editor.getValue();
        const vaultPath = this.app.vault.adapter.getBasePath();
        if (!vaultPath) {
          new import_obsidian3.Notice(t("notice.noVaultPath"));
          return;
        }
        context.currentRequest = {
          noteContent,
          userPrompt: prompt,
          notePath: file.path,
          selectedText: useSelectedTextOnly ? selectedText : void 0,
          vaultPath,
          configDir: this.app.vault.configDir,
          runtimeModelOverride: this.modelSelect.value || void 0,
          conversationalMode: this.conversationalModeCheckbox.checked
        };
        this.runButton.disabled = true;
        this.runButton.textContent = t("input.runningButton");
        this.cancelButton.removeClass("claude-code-hidden");
        this.cancelButton.addClass("claude-code-inline-visible");
        context.outputLines = [];
        this.outputRenderer.clear();
        this.agentTracker.clear();
        this.clearTodoList();
        this.hidePreview();
        this.hideResult();
        this.resultArea.empty();
        this.currentResultStreamingElement = null;
        this.hitFinalContentMarker = false;
        context.currentResultText = void 0;
        this.showLastPrompt(prompt);
        this.showStatus("\u{1F914} " + t("status.processing") + "... 0.0s");
        this.startElapsedTimeTracking("\u{1F914} " + t("status.processing"));
        const runNotePath = file.path;
        context.isRunning = true;
        this.updateCurrentNoteLabel();
        const response = yield context.runner.run(
          context.currentRequest,
          (line, isMarkdown, isStreaming, isAssistantMessage) => {
            this.appendOutputToNote(runNotePath, line, isMarkdown, isStreaming, isAssistantMessage);
            if (this.currentNotePath === runNotePath) {
              this.updateStatusFromOutput(line);
            }
          }
        );
        context.isRunning = false;
        context.currentResponse = response;
        context.executionStartTime = void 0;
        context.baseStatusMessage = void 0;
        this.hideStatus();
        this.runButton.disabled = false;
        this.runButton.textContent = t("input.runButton");
        this.cancelButton.addClass("claude-code-hidden");
        this.cancelButton.removeClass("claude-code-inline-visible");
        this.updateCurrentNoteLabel();
        if (response.success) {
          context.history.push({
            prompt,
            timestamp: new Date(),
            success: true,
            notePath: file.path,
            response,
            request: context.currentRequest,
            outputLines: context.outputLines
          });
          this.updateHistoryDisplay(context.history);
          try {
            this.contextManager.saveContext(file.path, vaultPath);
          } catch (error) {
            console.error("Failed to save context:", error);
          }
          if (response.modifiedContent && response.modifiedContent.trim()) {
            if (this.autoAcceptCheckbox.checked) {
              if (this.currentNotePath === runNotePath) {
                this.showStatus("\u2705 " + t("status.autoApplying"));
              }
              this.applyChangesToEditor(response.modifiedContent, editor);
              if (this.currentNotePath === runNotePath) {
                this.hideStatus();
              }
              new import_obsidian3.Notice("\u2713 " + t("notice.changesApplied"));
            } else {
              this.showPreview(response.modifiedContent, runNotePath);
            }
          } else {
            if (response.isPermissionRequest) {
              if (this.currentNotePath === runNotePath) {
                this.showPermissionApprovalSection();
                const resultSection = document.getElementById("claude-code-result-section");
                const hasStreamedContent = resultSection && resultSection.hasClass("claude-code-visible") && this.resultArea.children.length > 0;
                if (!hasStreamedContent && response.assistantMessage && response.assistantMessage.trim()) {
                  this.showResult(response.assistantMessage);
                }
              }
              new import_obsidian3.Notice("\u26A0\uFE0F " + t("notice.permissionRequest"));
            } else {
              if (this.currentNotePath === runNotePath) {
                const resultSection = document.getElementById("claude-code-result-section");
                const hasStreamedContent = resultSection && resultSection.hasClass("claude-code-visible") && this.resultArea.children.length > 0;
                if (!hasStreamedContent && response.assistantMessage && response.assistantMessage.trim()) {
                  this.showResult(response.assistantMessage);
                  new import_obsidian3.Notice("\u2713 " + t("notice.completed"));
                } else if (hasStreamedContent) {
                  new import_obsidian3.Notice("\u2713 " + t("notice.completed"));
                } else {
                  new import_obsidian3.Notice("\u2713 " + t("notice.completedNoChanges"));
                }
              } else {
                new import_obsidian3.Notice("\u2713 " + t("notice.completed"));
              }
            }
          }
        } else {
          if (this.currentNotePath === runNotePath) {
            this.showErrorStatus("\u274C " + t("status.failed"));
          }
          new import_obsidian3.Notice(`\u2717 ${response.error || "Unknown error"}`);
          context.history.push({
            prompt,
            timestamp: new Date(),
            success: false,
            notePath: file.path,
            response,
            request: context.currentRequest
          });
          this.updateHistoryDisplay(context.history);
        }
      } catch (error) {
        context.isRunning = false;
        context.executionStartTime = void 0;
        context.baseStatusMessage = void 0;
        throw error;
      }
    });
  }
  /**
   * Append output to a specific note's context
   */
  appendOutputToNote(notePath, text, isMarkdown = false, isStreaming = false, isAssistantMessage = false) {
    const context = this.contextManager.getContext(notePath);
    context.outputLines.push(text);
    if (isAssistantMessage && isStreaming === true) {
      context.currentResultText = (context.currentResultText || "") + text;
    }
    if (isStreaming !== true) {
      const agentStep = OutputRenderer.parseAgentActivity(text);
      if (agentStep) {
        context.agentSteps.push(agentStep);
      }
    }
    if (notePath === this.currentNotePath) {
      if (isStreaming === true) {
        this.outputRenderer.appendStreamingText(text);
        console.debug("[Append Output] isStreaming=true, isAssistantMessage=", isAssistantMessage);
        if (isAssistantMessage) {
          this.appendToResultUI(text);
        }
        return;
      } else if (isStreaming === "finish") {
        this.outputRenderer.finishStreamingBlock();
        if (isAssistantMessage) {
          this.finishResultStreaming();
        }
      } else if (isAssistantMessage && !isStreaming) {
        const hasStreamingContent = this.currentResultStreamingElement !== null || this.resultArea && this.resultArea.children.length > 0;
        if (!hasStreamingContent) {
          console.debug("[Append Output] Non-streaming assistant message, adding to result");
          this.showResultMarkdown(text);
        } else {
          console.debug("[Append Output] Non-streaming assistant message, but already have streaming content - skipping");
        }
      }
      this.outputRenderer.appendLine(text, isMarkdown);
      const agentStep = OutputRenderer.parseAgentActivity(text);
      if (agentStep) {
        if (this.isToolStart(text)) {
          const now = Date.now();
          this.toolStartTimes.set(agentStep.key, now);
          this.lastToolKey = agentStep.key;
          agentStep.startTime = now;
        } else if (this.isToolComplete(text)) {
          if (this.lastToolKey && this.toolStartTimes.has(this.lastToolKey)) {
            const startTime = this.toolStartTimes.get(this.lastToolKey);
            const duration = Date.now() - startTime;
            this.agentTracker.addStep(__spreadProps(__spreadValues({}, agentStep), {
              key: this.lastToolKey,
              duration
            }));
            this.toolStartTimes.delete(this.lastToolKey);
            this.lastToolKey = null;
            return;
          }
        }
        this.agentTracker.addStep(agentStep);
      }
    }
  }
  /**
   * Check if output line indicates a tool is starting
   */
  isToolStart(text) {
    return text.includes("\u{1F527} Using tool:") || text.includes("$ ") || text.includes("\u{1F50D} Glob searching:") || text.includes("\u{1F50E} Grep searching:") || text.includes("\u{1F4D6} Reading file:") || text.includes("\u270D\uFE0F  Writing file:") || text.includes("\u270F\uFE0F  Editing file:") || text.includes("\u{1F310} Fetching webpage:") || text.includes("\u{1F50D} Web searching:") || text.includes("\u{1F916} Launching agent:");
  }
  /**
   * Check if output line indicates a tool completed
   */
  isToolComplete(text) {
    return text.includes("\u2713 Found") || // Glob/Grep results
    text.includes("\u2713 Output") || // Bash output
    text.includes("complete") || // Generic completion
    text.includes("\u{1F4E5} Tool result");
  }
  /**
   * Update status based on output line
   */
  updateStatusFromOutput(line) {
    const status = OutputStatusManager.extractStatus(line);
    if (status) {
      this.showStatus(status);
    }
    if (line.includes("Using tool: TodoWrite") || line.includes("\u{1F527} Using tool: TodoWrite")) {
      setTimeout(() => this.parseTodosFromOutput(), 100);
    }
  }
  /**
   * Parse todos from the output lines
   */
  parseTodosFromOutput() {
    const context = this.getCurrentContext();
    console.debug("[Parse Todos] Total output lines:", context.outputLines.length);
    const todoWriteIndices = [];
    context.outputLines.forEach((line, index) => {
      if (line.includes("Using tool: TodoWrite")) {
        todoWriteIndices.push(index);
      }
    });
    console.debug("[Parse Todos] Found TodoWrite at indices:", todoWriteIndices);
    if (todoWriteIndices.length === 0) {
      console.debug("[Parse Todos] No TodoWrite found in output lines");
      return;
    }
    const lastTodoWriteIndex = todoWriteIndices[todoWriteIndices.length - 1];
    console.debug("[Parse Todos] Using last TodoWrite at index:", lastTodoWriteIndex);
    if (lastTodoWriteIndex + 1 < context.outputLines.length) {
      const jsonLine = context.outputLines[lastTodoWriteIndex + 1];
      console.debug("[Parse Todos] JSON line length:", jsonLine.length);
      console.debug("[Parse Todos] JSON line preview:", jsonLine.substring(0, 300));
      try {
        const jsonStr = jsonLine.trim();
        console.debug("[Parse Todos] Trimmed JSON length:", jsonStr.length);
        console.debug("[Parse Todos] First char:", jsonStr[0], "Last char:", jsonStr[jsonStr.length - 1]);
        const toolInput = JSON.parse(jsonStr);
        if (toolInput.todos && Array.isArray(toolInput.todos)) {
          console.debug("[Parse Todos] Found todos count:", toolInput.todos.length);
          console.debug("[Parse Todos] Todos:", JSON.stringify(toolInput.todos, null, 2));
          this.updateTodoList(toolInput.todos);
        } else {
          console.debug("[Parse Todos] No todos array found in parsed JSON");
          console.debug("[Parse Todos] Parsed object keys:", Object.keys(toolInput));
        }
      } catch (error) {
        console.error("[Parse Todos] Failed to parse todos JSON:", error);
        console.error("[Parse Todos] Error details:", error instanceof Error ? error.message : error);
        const jsonStr = jsonLine.trim();
        console.error("[Parse Todos] Full JSON string:", jsonStr);
      }
    }
  }
  /**
   * Show status indicator
   */
  showStatus(message) {
    const resultSection = document.getElementById("claude-code-result-section");
    if (resultSection) {
      resultSection.removeClass("claude-code-hidden");
      resultSection.addClass("claude-code-visible");
    }
    this.statusIndicator.removeClass("claude-code-hidden");
    this.statusIndicator.addClass("claude-code-flex-visible");
    this.resultArea.addClass("claude-code-hidden");
    this.resultArea.removeClass("claude-code-visible");
    this.statusText.textContent = message;
  }
  /**
   * Show error status without progress bar animation
   */
  showErrorStatus(message) {
    this.stopElapsedTimeTracking();
    const resultSection = document.getElementById("claude-code-result-section");
    if (resultSection) {
      resultSection.removeClass("claude-code-hidden");
      resultSection.addClass("claude-code-visible");
    }
    this.statusIndicator.removeClass("claude-code-hidden");
    this.statusIndicator.addClass("claude-code-flex-visible");
    this.resultArea.addClass("claude-code-hidden");
    this.resultArea.removeClass("claude-code-visible");
    this.statusText.textContent = message;
  }
  /**
   * Start elapsed time tracking (stores timing in per-note context)
   */
  startElapsedTimeTracking(baseMessage) {
    const context = this.getCurrentContext();
    context.executionStartTime = Date.now();
    context.baseStatusMessage = baseMessage || "\u{1F914} Claude is processing";
    this.stopElapsedTimeTracking();
    this.elapsedTimeInterval = setInterval(() => {
      const ctx = this.getCurrentContext();
      if (ctx.executionStartTime) {
        const elapsed = Date.now() - ctx.executionStartTime;
        const seconds = (elapsed / 1e3).toFixed(1);
        this.statusText.textContent = `${ctx.baseStatusMessage || "\u{1F914} Processing"}... ${seconds}s`;
      }
    }, 100);
  }
  /**
   * Resume elapsed time tracking for current note (used when switching back to a running note)
   */
  resumeElapsedTimeTracking() {
    const context = this.getCurrentContext();
    if (!context.executionStartTime || !context.isRunning) {
      return;
    }
    this.stopElapsedTimeTracking();
    this.elapsedTimeInterval = setInterval(() => {
      const ctx = this.getCurrentContext();
      if (ctx.executionStartTime) {
        const elapsed = Date.now() - ctx.executionStartTime;
        const seconds = (elapsed / 1e3).toFixed(1);
        this.statusText.textContent = `${ctx.baseStatusMessage || "\u{1F914} Processing"}... ${seconds}s`;
      }
    }, 100);
  }
  /**
   * Stop elapsed time tracking
   */
  stopElapsedTimeTracking() {
    if (this.elapsedTimeInterval) {
      clearInterval(this.elapsedTimeInterval);
      this.elapsedTimeInterval = null;
    }
  }
  /**
   * Hide status indicator
   */
  hideStatus() {
    this.stopElapsedTimeTracking();
    this.statusIndicator.addClass("claude-code-hidden");
    this.statusIndicator.removeClass("claude-code-flex-visible");
    if (this.resultArea.children.length > 0) {
      this.resultArea.removeClass("claude-code-hidden");
      this.resultArea.addClass("claude-code-visible");
      const resultSection = document.getElementById("claude-code-result-section");
      if (resultSection) {
        resultSection.removeClass("claude-code-hidden");
        resultSection.addClass("claude-code-visible");
      }
    }
  }
  /**
   * Show the last prompt that was sent
   */
  showLastPrompt(prompt) {
    const context = this.getCurrentContext();
    context.lastPrompt = prompt;
    this.lastPromptArea.empty();
    this.lastPromptArea.removeClass("claude-code-hidden");
    this.lastPromptArea.createEl("span", {
      cls: "claude-code-last-prompt-label",
      text: "\u{1F4AC} "
    });
    const displayPrompt = prompt.length > 200 ? prompt.substring(0, 200) + "..." : prompt;
    this.lastPromptArea.createEl("span", {
      cls: "claude-code-last-prompt-text",
      text: displayPrompt
    });
    if (prompt.length > 200) {
      this.lastPromptArea.setAttribute("title", prompt);
    }
  }
  /**
   * Hide the last prompt display
   */
  hideLastPrompt() {
    this.lastPromptArea.addClass("claude-code-hidden");
    this.lastPromptArea.empty();
  }
  /**
   * Show preview of changes
   * @param modifiedContent The modified content to preview
   * @param forNotePath Optional: the note path this preview belongs to (defaults to current note)
   */
  showPreview(modifiedContent, forNotePath) {
    var _a, _b;
    const targetNotePath = forNotePath || this.currentNotePath;
    const context = this.contextManager.getContext(targetNotePath);
    const originalContent = ((_a = context.currentRequest) == null ? void 0 : _a.selectedText) || ((_b = context.currentRequest) == null ? void 0 : _b.noteContent) || "";
    context.pendingPreviewContent = modifiedContent;
    context.originalPreviewContent = originalContent;
    if (targetNotePath !== this.currentNotePath) {
      return;
    }
    const previewSection = document.getElementById("claude-code-preview-section");
    if (previewSection) {
      previewSection.removeClass("claude-code-hidden");
      previewSection.addClass("claude-code-visible");
    }
    this.previewArea.empty();
    const oldRendered = this.previewContentContainer.querySelector(".claude-code-preview-rendered");
    if (oldRendered)
      oldRendered.remove();
    const oldDiff = this.previewContentContainer.querySelector(".claude-code-preview-diff");
    if (oldDiff)
      oldDiff.remove();
    const statsDiv = this.previewArea.createEl("div", { cls: "claude-code-preview-stats" });
    statsDiv.createEl("span", { text: `${t("preview.originalLabel")} ${originalContent.length} ${t("preview.charsLabel")}` });
    statsDiv.createEl("span", { text: ` \u2192 ${t("preview.modifiedLabel")} ${modifiedContent.length} ${t("preview.charsLabel")}` });
    statsDiv.createEl("span", { text: ` (${modifiedContent.length - originalContent.length >= 0 ? "+" : ""}${modifiedContent.length - originalContent.length})` });
    const previewContent = this.previewArea.createEl("pre", { cls: "claude-code-preview-content" });
    previewContent.createEl("code", { text: modifiedContent });
    this.previewArea.addClass("claude-code-hidden");
    const diffArea = this.previewContentContainer.createEl("div", {
      cls: "claude-code-preview-diff claude-code-visible"
    });
    const diffElement = this.generateDiffElement(originalContent, modifiedContent);
    diffArea.appendChild(diffElement);
    const renderedArea = this.previewContentContainer.createEl("div", {
      cls: "claude-code-preview-rendered claude-code-hidden"
    });
    void import_obsidian3.MarkdownRenderer.render(
      this.app,
      modifiedContent,
      renderedArea,
      this.currentNotePath,
      this
    );
  }
  /**
   * Hide preview and clear context state
   */
  hidePreview() {
    this.hidePreviewUI();
    const context = this.getCurrentContext();
    context.pendingPreviewContent = void 0;
    context.originalPreviewContent = void 0;
  }
  /**
   * Hide preview UI only (without clearing context state)
   * Used when switching notes to preserve each note's preview state
   */
  hidePreviewUI() {
    const previewSection = document.getElementById("claude-code-preview-section");
    if (previewSection) {
      previewSection.addClass("claude-code-hidden");
      previewSection.removeClass("claude-code-visible");
    }
  }
  /**
   * Restore preview from stored context state (used when switching notes)
   */
  restorePreview(modifiedContent, originalContent) {
    const previewSection = document.getElementById("claude-code-preview-section");
    if (previewSection) {
      previewSection.removeClass("claude-code-hidden");
      previewSection.addClass("claude-code-visible");
    }
    this.previewArea.empty();
    const oldRendered = this.previewContentContainer.querySelector(".claude-code-preview-rendered");
    if (oldRendered)
      oldRendered.remove();
    const oldDiff = this.previewContentContainer.querySelector(".claude-code-preview-diff");
    if (oldDiff)
      oldDiff.remove();
    const statsDiv = this.previewArea.createEl("div", { cls: "claude-code-preview-stats" });
    statsDiv.createEl("span", { text: `${t("preview.originalLabel")} ${originalContent.length} ${t("preview.charsLabel")}` });
    statsDiv.createEl("span", { text: ` \u2192 ${t("preview.modifiedLabel")} ${modifiedContent.length} ${t("preview.charsLabel")}` });
    statsDiv.createEl("span", { text: ` (${modifiedContent.length - originalContent.length >= 0 ? "+" : ""}${modifiedContent.length - originalContent.length})` });
    const previewContent = this.previewArea.createEl("pre", { cls: "claude-code-preview-content" });
    previewContent.createEl("code", { text: modifiedContent });
    this.previewArea.addClass("claude-code-hidden");
    const diffArea = this.previewContentContainer.createEl("div", {
      cls: "claude-code-preview-diff claude-code-visible"
    });
    const diffElement = this.generateDiffElement(originalContent, modifiedContent);
    diffArea.appendChild(diffElement);
    const renderedArea = this.previewContentContainer.createEl("div", {
      cls: "claude-code-preview-rendered claude-code-hidden"
    });
    void import_obsidian3.MarkdownRenderer.render(
      this.app,
      modifiedContent,
      renderedArea,
      this.currentNotePath,
      this
    );
  }
  /**
   * Restore streaming result from context (used when switching back to a running note)
   */
  restoreStreamingResult(text) {
    const resultSection = document.getElementById("claude-code-result-section");
    if (resultSection) {
      resultSection.removeClass("claude-code-hidden");
      resultSection.addClass("claude-code-visible");
    }
    this.resultArea.removeClass("claude-code-hidden");
    this.resultArea.addClass("claude-code-visible");
    this.resultArea.empty();
    this.currentResultStreamingElement = this.resultArea.createEl("div", {
      cls: "claude-code-result-streaming markdown-rendered"
    });
    this.currentResultStreamingElement.accumulatedText = text;
    this.lastRenderedText = "";
    this.hitFinalContentMarker = false;
    this.renderStreamingMarkdown(text);
    console.debug("[Restore Streaming Result] Restored text length:", text.length);
  }
  /**
   * Append text to result panel UI only (context update handled by appendOutputToNote)
   * Used for streaming assistant messages when the current note is active
   */
  appendToResultUI(text) {
    console.debug("[Append To Result UI] Called with text:", text.substring(0, 50));
    if (this.hitFinalContentMarker) {
      console.debug("[Append To Result UI] Already hit FINAL-CONTENT marker flag, ignoring chunk");
      return;
    }
    const resultSection = document.getElementById("claude-code-result-section");
    if (resultSection) {
      console.debug("[Append To Result UI] Showing result section");
      resultSection.removeClass("claude-code-hidden");
      resultSection.addClass("claude-code-visible");
    }
    this.resultArea.removeClass("claude-code-hidden");
    this.resultArea.addClass("claude-code-visible");
    if (!this.currentResultStreamingElement) {
      console.debug("[Append To Result UI] Creating streaming element");
      this.currentResultStreamingElement = this.resultArea.createEl("div", {
        cls: "claude-code-result-streaming markdown-rendered"
      });
      this.currentResultStreamingElement.accumulatedText = "";
    }
    const accumulatedText = this.currentResultStreamingElement.accumulatedText || "";
    if (accumulatedText.includes("---FINAL-CONTENT---")) {
      console.debug("[Append To Result UI] Found FINAL-CONTENT in existing text, cleaning up and setting flag");
      this.cleanupFinalContentFromStream();
      this.hitFinalContentMarker = true;
      return;
    }
    const combinedText = accumulatedText + text;
    if (combinedText.includes("---FINAL-CONTENT---")) {
      const finalContentIndex = combinedText.indexOf("---FINAL-CONTENT---");
      const textBeforeMarker = combinedText.substring(0, finalContentIndex);
      this.currentResultStreamingElement.accumulatedText = textBeforeMarker;
      this.renderStreamingMarkdown(textBeforeMarker);
      console.debug("[Append To Result UI] Hit FINAL-CONTENT marker, setting flag");
      this.hitFinalContentMarker = true;
      return;
    }
    this.currentResultStreamingElement.accumulatedText = combinedText;
    this.renderStreamingMarkdown(combinedText);
    console.debug("[Append To Result UI] Appended chunk, accumulated length:", combinedText.length);
    this.autoScrollResult();
  }
  /**
   * Render accumulated markdown text by detecting and rendering complete blocks
   * Appends complete paragraphs/blocks as independent chunks
   */
  renderStreamingMarkdown(text) {
    if (!this.currentResultStreamingElement)
      return;
    const newContent = text.substring(this.lastRenderedText.length);
    if (!newContent)
      return;
    const { completeBlocks, remainingText } = this.extractCompleteBlocks(newContent);
    if (completeBlocks.length > 0) {
      this.removeIncompletePlainText();
      for (const block of completeBlocks) {
        this.appendMarkdownBlock(block);
      }
      this.lastRenderedText = this.lastRenderedText + newContent.substring(0, newContent.length - remainingText.length);
    }
    if (remainingText) {
      this.appendPlainText(remainingText);
    }
  }
  /**
   * Extract complete markdown blocks from the new content
   * Returns blocks that are ready to be rendered and remaining incomplete text
   */
  extractCompleteBlocks(newContent) {
    const blocks = [];
    const paragraphs = newContent.split(/\n\n+/);
    if (paragraphs.length > 1) {
      for (let i = 0; i < paragraphs.length - 1; i++) {
        if (paragraphs[i].trim()) {
          blocks.push(paragraphs[i]);
        }
      }
      return {
        completeBlocks: blocks,
        remainingText: paragraphs[paragraphs.length - 1]
      };
    }
    return {
      completeBlocks: [],
      remainingText: newContent
    };
  }
  /**
   * Remove incomplete plain text from the last render
   * (will be re-added as part of complete block or new plain text)
   */
  removeIncompletePlainText() {
    if (!this.currentResultStreamingElement)
      return;
    const lastChild = this.currentResultStreamingElement.lastChild;
    if (lastChild && lastChild.nodeType === Node.TEXT_NODE) {
      this.currentResultStreamingElement.removeChild(lastChild);
    }
  }
  /**
   * Append a complete markdown block as an independent rendered chunk
   */
  appendMarkdownBlock(blockText) {
    if (!this.currentResultStreamingElement)
      return;
    const blockContainer = document.createElement("div");
    blockContainer.addClass("markdown-block");
    void import_obsidian3.MarkdownRenderer.render(
      this.app,
      blockText,
      blockContainer,
      this.currentNotePath,
      this
    ).catch((e) => {
      console.error("[Append Markdown Block] Error:", e);
      blockContainer.textContent = blockText;
    });
    this.currentResultStreamingElement.appendChild(blockContainer);
  }
  /**
   * Append plain text without any processing
   */
  appendPlainText(text) {
    if (!this.currentResultStreamingElement)
      return;
    const lastChild = this.currentResultStreamingElement.lastChild;
    if (lastChild && lastChild.nodeType === Node.TEXT_NODE) {
      lastChild.textContent = text;
    } else {
      const textNode = document.createTextNode(text);
      this.currentResultStreamingElement.appendChild(textNode);
    }
  }
  /**
   * Clean up FINAL-CONTENT marker and everything after it from the streaming element
   */
  cleanupFinalContentFromStream() {
    if (!this.currentResultStreamingElement)
      return;
    const fullText = this.currentResultStreamingElement.textContent || "";
    const finalContentIndex = fullText.indexOf("---FINAL-CONTENT---");
    if (finalContentIndex === -1)
      return;
    console.debug("[Cleanup FINAL-CONTENT] Removing marker and content after it");
    const textToKeep = fullText.substring(0, finalContentIndex).trim();
    this.currentResultStreamingElement.empty();
    this.currentResultStreamingElement.createEl("span", {
      cls: "streaming-text-chunk",
      text: textToKeep
    });
    console.debug("[Cleanup FINAL-CONTENT] Cleaned up, kept text length:", textToKeep.length);
  }
  /**
   * Show markdown content in result section (for non-streaming assistant messages)
   */
  showResultMarkdown(text) {
    console.debug("[Show Result Markdown] Called with text length:", text.length);
    let filteredText = text;
    const finalContentIndex = text.indexOf("---FINAL-CONTENT---");
    if (finalContentIndex !== -1) {
      filteredText = text.substring(0, finalContentIndex).trim();
      console.debug("[Show Result Markdown] Filtered FINAL-CONTENT, new length:", filteredText.length);
    }
    const resultSection = document.getElementById("claude-code-result-section");
    if (resultSection) {
      resultSection.removeClass("claude-code-hidden");
      resultSection.addClass("claude-code-visible");
    }
    this.resultArea.removeClass("claude-code-hidden");
    this.resultArea.addClass("claude-code-visible");
    const contentDiv = this.resultArea.createEl("div", {
      cls: "markdown-rendered"
    });
    void import_obsidian3.MarkdownRenderer.render(
      this.app,
      filteredText,
      contentDiv,
      this.currentNotePath,
      this
    ).catch((e) => {
      console.error("[Show Result Markdown] Render error:", e);
      contentDiv.textContent = filteredText;
    });
    this.resultArea.scrollTop = this.resultArea.scrollHeight;
  }
  /**
   * Setup smart auto-scroll detection on result area
   */
  setupSmartAutoScroll() {
    this.resultArea.addEventListener("scroll", () => {
      const { scrollTop, scrollHeight, clientHeight } = this.resultArea;
      const isNearBottom = scrollHeight - scrollTop - clientHeight < 50;
      if (!isNearBottom) {
        this.userHasScrolled = true;
      } else {
        this.userHasScrolled = false;
      }
    });
  }
  /**
   * Auto-scroll result area to bottom (only if user hasn't manually scrolled up)
   */
  autoScrollResult() {
    if (!this.userHasScrolled) {
      this.resultArea.scrollTop = this.resultArea.scrollHeight;
    }
  }
  /**
   * Reset scroll state (call when starting new request)
   */
  resetScrollState() {
    this.userHasScrolled = false;
    this.lastRenderedText = "";
  }
  /**
   * Finish the streaming result block
   */
  finishResultStreaming() {
    if (this.currentResultStreamingElement) {
      console.debug("[Finish Result Streaming] Cleaning up streaming state");
      const fullAccumulatedText = this.currentResultStreamingElement.fullText || "";
      if (fullAccumulatedText && fullAccumulatedText.length > this.lastRenderedText.length) {
        const unrenderedText = fullAccumulatedText.substring(this.lastRenderedText.length);
        if (unrenderedText.trim()) {
          console.debug("[Finish Result Streaming] Rendering final unrendered text:", unrenderedText.substring(0, 50));
          const lastChild = this.currentResultStreamingElement.lastChild;
          if (lastChild && lastChild.nodeType === Node.TEXT_NODE) {
            this.currentResultStreamingElement.removeChild(lastChild);
          }
          this.appendMarkdownBlock(unrenderedText);
        }
      } else {
        const lastChild = this.currentResultStreamingElement.lastChild;
        if (lastChild && lastChild.nodeType === Node.TEXT_NODE) {
          const remainingText = lastChild.textContent || "";
          if (remainingText.trim()) {
            this.currentResultStreamingElement.removeChild(lastChild);
            this.appendMarkdownBlock(remainingText);
          }
        }
      }
      this.currentResultStreamingElement.removeClass("claude-code-result-streaming");
      this.currentResultStreamingElement.addClass("markdown-rendered");
      this.currentResultStreamingElement = null;
    }
  }
  /**
   * Show result panel with Claude's response
   */
  showResult(message) {
    this.resultArea.empty();
    let filteredMessage = message;
    const finalContentIndex = message.indexOf("---FINAL-CONTENT---");
    if (finalContentIndex !== -1) {
      filteredMessage = message.substring(0, finalContentIndex).trim();
      console.debug("[Show Result] Filtered FINAL-CONTENT, original length:", message.length, "filtered length:", filteredMessage.length);
    }
    void import_obsidian3.MarkdownRenderer.render(
      this.app,
      filteredMessage,
      this.resultArea,
      this.currentNotePath,
      this
    );
    const resultSection = document.getElementById("claude-code-result-section");
    if (resultSection) {
      resultSection.removeClass("claude-code-hidden");
      resultSection.addClass("claude-code-visible");
    }
    this.statusIndicator.addClass("claude-code-hidden");
    this.statusIndicator.removeClass("claude-code-flex-visible");
    this.resultArea.removeClass("claude-code-hidden");
    this.resultArea.addClass("claude-code-visible");
  }
  /**
   * Hide result panel
   */
  hideResult() {
    this.resultArea.addClass("claude-code-hidden");
    this.resultArea.removeClass("claude-code-visible");
    this.resultArea.empty();
    if (this.statusIndicator.hasClass("claude-code-hidden")) {
      const resultSection = document.getElementById("claude-code-result-section");
      if (resultSection) {
        resultSection.addClass("claude-code-hidden");
        resultSection.removeClass("claude-code-visible");
      }
    }
  }
  /**
   * Show permission approval section
   */
  showPermissionApprovalSection() {
    if (this.permissionApprovalSection) {
      this.permissionApprovalSection.removeClass("claude-code-hidden");
      this.permissionApprovalSection.addClass("claude-code-visible");
    }
  }
  /**
   * Hide permission approval section
   */
  hidePermissionApprovalSection() {
    if (this.permissionApprovalSection) {
      this.permissionApprovalSection.addClass("claude-code-hidden");
      this.permissionApprovalSection.removeClass("claude-code-visible");
    }
  }
  /**
   * Handle approve permission button click
   */
  handleApprovePermission() {
    return __async(this, null, function* () {
      const context = this.getCurrentContext();
      if (!context.currentRequest) {
        new import_obsidian3.Notice(t("misc.noPendingRequest"));
        return;
      }
      this.hidePermissionApprovalSection();
      const file = this.app.workspace.getActiveFile();
      if (!file) {
        new import_obsidian3.Notice(t("notice.noActiveNote"));
        return;
      }
      const leaves = this.app.workspace.getLeavesOfType("markdown");
      let activeView = null;
      for (const leaf of leaves) {
        const view = leaf.view;
        if (view.file && view.file.path === file.path) {
          activeView = view;
          break;
        }
      }
      if (!activeView || !activeView.editor) {
        new import_obsidian3.Notice(t("notice.noEditor"));
        return;
      }
      const editor = activeView.editor;
      const approvalPrompt = "Yes, I approve. You have permissionless mode enabled - please proceed with the action you were asking about. Don't hesitate to execute it.";
      const newRequest = __spreadProps(__spreadValues({}, context.currentRequest), {
        userPrompt: approvalPrompt,
        bypassPermissions: true,
        configDir: this.app.vault.configDir
      });
      this.runButton.disabled = true;
      this.runButton.textContent = t("input.runningButton");
      this.cancelButton.removeClass("claude-code-hidden");
      this.cancelButton.addClass("claude-code-inline-visible");
      this.outputRenderer.clear();
      this.hidePreview();
      this.hideResult();
      this.showStatus("\u{1F513} " + t("status.runningAuthorized") + " ... 0.0s");
      this.startElapsedTimeTracking("\u{1F513} " + t("status.runningAuthorized"));
      const runNotePath = file.path;
      context.isRunning = true;
      const response = yield context.runner.run(
        newRequest,
        (line, isMarkdown, isStreaming, isAssistantMessage) => {
          this.appendOutputToNote(runNotePath, line, isMarkdown, isStreaming, isAssistantMessage);
          if (this.currentNotePath === runNotePath) {
            this.updateStatusFromOutput(line);
          }
        }
      );
      context.isRunning = false;
      context.currentResponse = response;
      context.executionStartTime = void 0;
      context.baseStatusMessage = void 0;
      this.hideStatus();
      this.runButton.disabled = false;
      this.runButton.textContent = t("input.runButton");
      this.cancelButton.addClass("claude-code-hidden");
      this.cancelButton.removeClass("claude-code-inline-visible");
      if (response.success) {
        context.history.push({
          prompt: approvalPrompt,
          timestamp: new Date(),
          success: true,
          notePath: file.path,
          response,
          request: newRequest,
          outputLines: context.outputLines
        });
        this.updateHistoryDisplay(context.history);
        const vaultPath = this.app.vault.adapter.getBasePath();
        this.contextManager.saveContext(file.path, vaultPath);
        if (response.modifiedContent && response.modifiedContent.trim()) {
          if (this.autoAcceptCheckbox.checked) {
            if (this.currentNotePath === runNotePath) {
              this.showStatus("\u2705 " + t("status.autoApplying"));
            }
            this.applyChangesToEditor(response.modifiedContent, editor);
            if (this.currentNotePath === runNotePath) {
              this.hideStatus();
            }
            new import_obsidian3.Notice("\u2713 " + t("notice.changesApplied"));
          } else {
            this.showPreview(response.modifiedContent, runNotePath);
          }
        } else {
          if (this.currentNotePath === runNotePath) {
            const resultSection = document.getElementById("claude-code-result-section");
            const hasStreamedContent = resultSection && resultSection.hasClass("claude-code-visible") && this.resultArea.children.length > 0;
            if (!hasStreamedContent && response.assistantMessage && response.assistantMessage.trim()) {
              this.showResult(response.assistantMessage);
              new import_obsidian3.Notice("\u2713 " + t("notice.completed"));
            } else if (hasStreamedContent) {
              new import_obsidian3.Notice("\u2713 " + t("notice.completed"));
            } else {
              new import_obsidian3.Notice("\u2713 " + t("notice.completedNoChanges"));
            }
          } else {
            new import_obsidian3.Notice("\u2713 " + t("notice.completed"));
          }
        }
      } else {
        if (this.currentNotePath === runNotePath) {
          this.showErrorStatus("\u274C " + t("status.failed"));
        }
        new import_obsidian3.Notice(`\u2717 Claude Code failed: ${response.error || "Unknown error"}`);
      }
    });
  }
  /**
   * Handle deny permission button click
   */
  handleDenyPermission() {
    this.hidePermissionApprovalSection();
    new import_obsidian3.Notice(t("notice.permissionDenied"));
  }
  /**
   * Handle apply changes
   */
  handleApplyChanges() {
    var _a;
    const context = this.getCurrentContext();
    const contentToApply = context.pendingPreviewContent || ((_a = context.currentResponse) == null ? void 0 : _a.modifiedContent);
    if (!contentToApply) {
      new import_obsidian3.Notice("\u26A0 " + t("notice.noChangesToApply"));
      console.error("[Apply Changes] No modified content found in context");
      return;
    }
    const file = this.app.workspace.getActiveFile();
    if (!file) {
      new import_obsidian3.Notice("\u26A0 " + t("notice.noActiveFile"));
      console.error("[Apply Changes] No active file found");
      return;
    }
    const leaves = this.app.workspace.getLeavesOfType("markdown");
    let targetView = null;
    for (const leaf of leaves) {
      const view = leaf.view;
      if (view.file && view.file.path === file.path) {
        targetView = view;
        break;
      }
    }
    if (!targetView && leaves.length > 0) {
      targetView = leaves[0].view;
    }
    if (!targetView || !targetView.editor) {
      new import_obsidian3.Notice("\u26A0 " + t("notice.noEditor"));
      console.error("[Apply Changes] No markdown view or editor found");
      return;
    }
    try {
      this.applyChangesToEditor(contentToApply, targetView.editor);
      this.hidePreview();
      new import_obsidian3.Notice("\u2713 " + t("notice.changesAppliedSuccess"));
    } catch (error) {
      new import_obsidian3.Notice("\u2717 " + t("notice.failedApplyChanges"));
      console.error("[Apply Changes] Error:", error);
    }
  }
  /**
   * Apply changes to editor
   */
  applyChangesToEditor(content, editor) {
    var _a;
    const context = this.getCurrentContext();
    const cursorBefore = editor.getCursor();
    if ((_a = context.currentRequest) == null ? void 0 : _a.selectedText) {
      editor.replaceSelection(content);
    } else {
      editor.setValue(content);
    }
    if (this.plugin.settings.preserveCursorPosition) {
      editor.setCursor(cursorBefore);
    }
  }
  /**
   * Handle reject changes
   */
  handleRejectChanges() {
    this.hidePreview();
    new import_obsidian3.Notice(t("notice.changesRejected"));
  }
  /**
   * Handle cancel
   */
  handleCancel() {
    const context = this.getCurrentContext();
    context.runner.terminate();
    context.isRunning = false;
    context.executionStartTime = void 0;
    context.baseStatusMessage = void 0;
    this.runButton.disabled = false;
    this.runButton.textContent = t("input.runButton");
    this.cancelButton.addClass("claude-code-hidden");
    this.cancelButton.removeClass("claude-code-inline-visible");
    this.hideStatus();
    new import_obsidian3.Notice(t("notice.cancelled"));
  }
  /**
   * Respond to interactive prompt (placeholder for future use)
   */
  respondToPrompt(response) {
    console.debug("Interactive response:", response);
  }
  /**
   * Generate diff HTML between original and modified content
   */
  generateDiffElement(original, modified) {
    return DiffGenerator.generateDiffElement(original, modified);
  }
  /**
   * Update history display
   */
  updateHistoryDisplay(history) {
    this.historyList.empty();
    const historySection = document.getElementById("claude-code-history-section");
    if (history.length === 0) {
      if (historySection) {
        historySection.addClass("claude-code-hidden");
        historySection.removeClass("claude-code-visible");
      }
      return;
    }
    if (historySection) {
      historySection.removeClass("claude-code-hidden");
      historySection.addClass("claude-code-visible");
    }
    for (const item of history.slice().reverse()) {
      const li = this.historyList.createEl("li");
      const icon = item.success ? "\u2713" : "\u2717";
      const time = new Date(item.timestamp).toLocaleTimeString();
      li.createEl("span", { text: `${icon} ${time}`, cls: "history-time" });
      const displayPrompt = item.prompt.length > 100 ? item.prompt.substring(0, 100) + "..." : item.prompt;
      li.createEl("span", { text: displayPrompt, cls: "history-prompt" });
      li.addEventListener("click", () => this.restoreFromHistory(item));
      li.addClass("claude-code-cursor-pointer");
    }
  }
  /**
   * Restore state from a history item
   */
  restoreFromHistory(item) {
    var _a;
    const context = this.getCurrentContext();
    this.promptInput.value = item.prompt;
    if (item.outputLines && item.outputLines.length > 0) {
      this.outputRenderer.clear();
      for (const line of item.outputLines) {
        this.outputRenderer.appendLine(line);
      }
    }
    if (item.response) {
      context.currentResponse = item.response;
      if (item.response.assistantMessage && item.response.assistantMessage.trim()) {
        this.showResult(item.response.assistantMessage);
      }
    }
    if (item.request) {
      context.currentRequest = item.request;
    }
    if (item.success && ((_a = item.response) == null ? void 0 : _a.modifiedContent)) {
      this.showPreview(item.response.modifiedContent);
      new import_obsidian3.Notice(t("notice.historyRestoredWithChanges"));
    } else {
      this.hidePreview();
      new import_obsidian3.Notice(t("notice.historyRestored"));
    }
  }
  /**
   * Clear history
   */
  clearHistory() {
    this.contextManager.clearHistory(this.currentNotePath);
    this.updateHistoryDisplay([]);
    const historySection = document.getElementById("claude-code-history-section");
    if (historySection) {
      historySection.addClass("claude-code-hidden");
      historySection.removeClass("claude-code-visible");
    }
    new import_obsidian3.Notice(t("notice.historyCleared"));
  }
  /**
   * Clear the todo list display
   */
  clearTodoList() {
    const planColumn = document.querySelector(".claude-code-plan-column");
    const todoList = document.getElementById("claude-code-todo-list");
    const emptyPlan = document.getElementById("claude-code-empty-plan");
    console.debug("[Clear Todo List] Called");
    if (!todoList || !planColumn) {
      console.debug("[Clear Todo List] Elements not found");
      return;
    }
    todoList.empty();
    if (emptyPlan) {
      emptyPlan.addClass("claude-code-hidden");
    }
    todoList.addClass("claude-code-hidden");
    planColumn.addClass("claude-code-hidden");
    console.debug("[Clear Todo List] Plan column hidden");
  }
  /**
   * Update Claude's todo list display
   */
  updateTodoList(todos) {
    const agentContainer = document.getElementById("claude-code-agent-container");
    const planColumn = document.querySelector(".claude-code-plan-column");
    const todoList = document.getElementById("claude-code-todo-list");
    const emptyPlan = document.getElementById("claude-code-empty-plan");
    if (!agentContainer || !todoList || !planColumn)
      return;
    todoList.empty();
    if (todos.length === 0) {
      planColumn.addClass("claude-code-hidden");
      if (emptyPlan)
        emptyPlan.addClass("claude-code-hidden");
      todoList.addClass("claude-code-hidden");
      const agentStepsContainer = document.getElementById("claude-code-agent-steps");
      if (agentStepsContainer && agentStepsContainer.children.length === 0) {
        agentContainer.removeClass("is-visible");
        agentContainer.addClass("is-hidden");
      }
    } else {
      agentContainer.removeClass("is-hidden");
      agentContainer.addClass("is-visible");
      planColumn.removeClass("claude-code-hidden");
      planColumn.addClass("claude-code-flex-visible");
      if (emptyPlan)
        emptyPlan.addClass("claude-code-hidden");
      todoList.removeClass("claude-code-hidden");
      todoList.addClass("claude-code-flex-visible");
      for (const todo of todos) {
        const todoItem = todoList.createEl("div", { cls: "claude-code-todo-item" });
        let icon = "\u23F3";
        let statusClass = "pending";
        if (todo.status === "in_progress") {
          icon = "\u{1F504}";
          statusClass = "in-progress";
        } else if (todo.status === "completed") {
          icon = "\u2705";
          statusClass = "completed";
        }
        todoItem.createEl("span", {
          cls: `claude-code-todo-icon ${statusClass}`,
          text: icon
        });
        const text = todo.status === "in_progress" ? todo.activeForm : todo.content;
        todoItem.createEl("span", {
          cls: "claude-code-todo-content",
          text
        });
      }
    }
  }
  /**
   * Update settings
   */
  updateSettings() {
    this.autoAcceptCheckbox.checked = this.plugin.settings.autoAcceptChanges;
    this.modelSelect.value = this.plugin.settings.modelAlias;
  }
  onClose() {
    return __async(this, null, function* () {
      if (this.promptInputKeydownHandler) {
        this.promptInput.removeEventListener("keydown", this.promptInputKeydownHandler);
        this.promptInputKeydownHandler = null;
      }
      for (const { element, event, handler } of this.eventListeners) {
        element.removeEventListener(event, handler);
      }
      this.eventListeners = [];
      const vaultPath = this.app.vault.adapter.getBasePath();
      if (vaultPath) {
        try {
          this.contextManager.saveAllContexts(vaultPath);
        } catch (error) {
          console.error("Failed to save contexts on close:", error);
        }
      }
    });
  }
};

// src/core/settings.ts
var import_obsidian4 = require("obsidian");
var import_child_process2 = require("child_process");
var os2 = __toESM(require("os"));
var fs5 = __toESM(require("fs"));
var path6 = __toESM(require("path"));
var DEFAULT_SETTINGS = {
  claudeCodePath: "",
  autoDetectPath: true,
  modelAlias: "",
  customSystemPrompt: "",
  preserveCursorPosition: true,
  timeoutSeconds: 300,
  autoAcceptChanges: false,
  allowVaultAccess: true,
  enablePermissionlessMode: false,
  // Custom API configuration (empty = use default)
  anthropicBaseUrl: "",
  anthropicAuthToken: "",
  anthropicModel: "",
  anthropicSmallFastModel: "",
  // UI settings
  language: "en",
  // Remote WebSocket mode settings
  enableRemoteMode: false,
  remoteServerUrl: "ws://localhost:8080",
  remoteAuthToken: "",
  remoteAutoReconnect: true,
  remoteReconnectInterval: 3e3,
  remoteMaxReconnectAttempts: 10
};
var ClaudeCodeSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian4.Setting(containerEl).setName(t("settings.language")).setDesc(t("settings.languageDesc")).addDropdown((dropdown) => {
      const locales = getAvailableLocales();
      for (const locale of locales) {
        dropdown.addOption(locale.code, locale.name);
      }
      dropdown.setValue(getLocale()).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.language = value;
        setLocale(value);
        yield this.plugin.saveSettings();
        this.display();
        new import_obsidian4.Notice(t("misc.languageChanged"));
      }));
    });
    new import_obsidian4.Setting(containerEl).setName(t("settings.autoDetectPath")).setDesc(t("settings.autoDetectPathDesc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.autoDetectPath).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.autoDetectPath = value;
      if (value) {
        const detectedPath = this.detectClaudeCodePath();
        if (detectedPath) {
          this.plugin.settings.claudeCodePath = detectedPath;
        }
      }
      yield this.plugin.saveSettings();
      this.display();
    })));
    new import_obsidian4.Setting(containerEl).setName(t("settings.executablePath")).setDesc(t("settings.executablePathDesc")).addText((text) => text.setPlaceholder("/usr/local/bin/claude").setValue(this.plugin.settings.claudeCodePath).setDisabled(this.plugin.settings.autoDetectPath).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.claudeCodePath = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian4.Setting(containerEl).setName(t("settings.testInstallation")).setDesc(t("settings.testInstallationDesc")).addButton((button) => button.setButtonText(t("settings.testButton")).onClick(() => {
      void this.testClaudeCode().then((result) => {
        if (result.success) {
          button.setButtonText("\u2713 " + t("settings.testWorking"));
          setTimeout(() => {
            button.setButtonText(t("settings.testButton"));
          }, 2e3);
        } else {
          button.setButtonText("\u2717 " + t("settings.testFailed"));
          setTimeout(() => {
            button.setButtonText(t("settings.testButton"));
          }, 2e3);
          new import_obsidian4.Notice(`${t("misc.testFailed")}: ${result.error}`);
        }
      });
    }));
    new import_obsidian4.Setting(containerEl).setName(t("settings.customPrompt")).setDesc(t("settings.customPromptDesc")).addTextArea((text) => {
      text.setPlaceholder(t("settings.customPromptPlaceholder")).setValue(this.plugin.settings.customSystemPrompt).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.customSystemPrompt = value;
        yield this.plugin.saveSettings();
      }));
      text.inputEl.rows = 4;
      text.inputEl.cols = 50;
    });
    new import_obsidian4.Setting(containerEl).setName(t("settings.preserveCursor")).setDesc(t("settings.preserveCursorDesc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.preserveCursorPosition).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.preserveCursorPosition = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian4.Setting(containerEl).setName(t("settings.autoAcceptChanges")).setDesc(t("settings.autoAcceptChangesDesc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.autoAcceptChanges).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.autoAcceptChanges = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian4.Setting(containerEl).setName(t("settings.model")).setDesc(t("settings.modelDesc")).addDropdown((dropdown) => dropdown.addOption("", t("settings.modelDefault")).addOption("sonnet", t("settings.modelSonnet")).addOption("opus", t("settings.modelOpus")).addOption("haiku", t("settings.modelHaiku")).setValue(this.plugin.settings.modelAlias).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.modelAlias = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian4.Setting(containerEl).setName(t("settings.vaultAccess")).setDesc(t("settings.vaultAccessDesc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.allowVaultAccess).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.allowVaultAccess = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian4.Setting(containerEl).setName(t("settings.permissionlessMode")).setDesc(t("settings.permissionlessModeDesc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.enablePermissionlessMode).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.enablePermissionlessMode = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian4.Setting(containerEl).setName(t("settings.timeout")).setDesc(t("settings.timeoutDesc")).addText((text) => text.setPlaceholder("300").setValue(String(this.plugin.settings.timeoutSeconds)).onChange((value) => __async(this, null, function* () {
      const num = parseInt(value);
      if (!isNaN(num) && num >= 0) {
        this.plugin.settings.timeoutSeconds = num;
        yield this.plugin.saveSettings();
      }
    })));
    new import_obsidian4.Setting(containerEl).setName(t("settings.customApiConfig")).setDesc(t("settings.customApiConfigDesc")).setHeading();
    new import_obsidian4.Setting(containerEl).setName(t("settings.apiBaseUrl")).setDesc(t("settings.apiBaseUrlDesc")).addText((text) => text.setPlaceholder("https://api.anthropic.com").setValue(this.plugin.settings.anthropicBaseUrl).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.anthropicBaseUrl = value.trim();
      yield this.plugin.saveSettings();
    })));
    new import_obsidian4.Setting(containerEl).setName(t("settings.apiAuthToken")).setDesc(t("settings.apiAuthTokenDesc")).addText((text) => {
      text.setPlaceholder(t("settings.apiAuthTokenPlaceholder")).setValue(this.plugin.settings.anthropicAuthToken).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.anthropicAuthToken = value.trim();
        yield this.plugin.saveSettings();
      }));
      text.inputEl.type = "password";
    });
    new import_obsidian4.Setting(containerEl).setName(t("settings.customModel")).setDesc(t("settings.customModelDesc")).addText((text) => text.setPlaceholder("claude-sonnet-4-20250514").setValue(this.plugin.settings.anthropicModel).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.anthropicModel = value.trim();
      yield this.plugin.saveSettings();
    })));
    new import_obsidian4.Setting(containerEl).setName(t("settings.customSmallModel")).setDesc(t("settings.customSmallModelDesc")).addText((text) => text.setPlaceholder("claude-haiku-3-5-20241022").setValue(this.plugin.settings.anthropicSmallFastModel).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.anthropicSmallFastModel = value.trim();
      yield this.plugin.saveSettings();
    })));
    new import_obsidian4.Setting(containerEl).setName("Remote Mode (WebSocket)").setDesc("Connect to remote Claude relay server instead of running Claude locally").setHeading();
    new import_obsidian4.Setting(containerEl).setName("Enable remote mode").setDesc("Use WebSocket connection to remote Claude server instead of local Claude Code").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableRemoteMode).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.enableRemoteMode = value;
      yield this.plugin.saveSettings();
      new import_obsidian4.Notice("Remote mode " + (value ? "enabled" : "disabled") + ". Reload Obsidian to apply changes.");
    })));
    new import_obsidian4.Setting(containerEl).setName("Server URL").setDesc("WebSocket server URL (e.g., ws://localhost:8080 or wss://your-server.com)").addText((text) => text.setPlaceholder("ws://localhost:8080").setValue(this.plugin.settings.remoteServerUrl).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.remoteServerUrl = value.trim();
      yield this.plugin.saveSettings();
    })));
    new import_obsidian4.Setting(containerEl).setName("Auth token (optional)").setDesc("Optional authentication token for server connection").addText((text) => {
      text.setPlaceholder("your-auth-token").setValue(this.plugin.settings.remoteAuthToken).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.remoteAuthToken = value.trim();
        yield this.plugin.saveSettings();
      }));
      text.inputEl.type = "password";
    });
    new import_obsidian4.Setting(containerEl).setName("Auto-reconnect").setDesc("Automatically reconnect to server if connection is lost").addToggle((toggle) => toggle.setValue(this.plugin.settings.remoteAutoReconnect).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.remoteAutoReconnect = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian4.Setting(containerEl).setName("Reconnect interval (ms)").setDesc("Initial reconnection delay in milliseconds (will increase exponentially)").addText((text) => text.setPlaceholder("3000").setValue(String(this.plugin.settings.remoteReconnectInterval)).onChange((value) => __async(this, null, function* () {
      const num = parseInt(value);
      if (!isNaN(num) && num >= 1e3) {
        this.plugin.settings.remoteReconnectInterval = num;
        yield this.plugin.saveSettings();
      }
    })));
    new import_obsidian4.Setting(containerEl).setName("Max reconnect attempts").setDesc("Maximum number of reconnection attempts before giving up").addText((text) => text.setPlaceholder("10").setValue(String(this.plugin.settings.remoteMaxReconnectAttempts)).onChange((value) => __async(this, null, function* () {
      const num = parseInt(value);
      if (!isNaN(num) && num >= 1) {
        this.plugin.settings.remoteMaxReconnectAttempts = num;
        yield this.plugin.saveSettings();
      }
    })));
    new import_obsidian4.Setting(containerEl).setName("Test connection").setDesc("Verify that the remote server is accessible").addButton((button) => button.setButtonText("Test Connection").onClick(() => {
      button.setButtonText("Testing...");
      button.setDisabled(true);
      void this.testRemoteConnection().then((result) => {
        button.setDisabled(false);
        if (result.success) {
          button.setButtonText("\u2713 Connected");
          setTimeout(() => {
            button.setButtonText("Test Connection");
          }, 2e3);
          new import_obsidian4.Notice("Successfully connected to remote server");
        } else {
          button.setButtonText("\u2717 Failed");
          setTimeout(() => {
            button.setButtonText("Test Connection");
          }, 2e3);
          new import_obsidian4.Notice(`Connection failed: ${result.error}`);
        }
      });
    }));
  }
  /**
   * Test remote WebSocket connection
   */
  testRemoteConnection() {
    return __async(this, null, function* () {
      try {
        const { WebSocketClient: WebSocketClient2 } = yield Promise.resolve().then(() => (init_websocket_client(), websocket_client_exports));
        const client = new WebSocketClient2({
          url: this.plugin.settings.remoteServerUrl,
          conversationId: "test-connection-" + Date.now(),
          autoReconnect: false,
          connectTimeout: 5e3
        });
        yield client.connect();
        client.disconnect();
        return { success: true };
      } catch (error) {
        return { success: false, error: String(error) };
      }
    });
  }
  /**
   * Attempt to detect Claude Code installation path (cross-platform)
   */
  detectClaudeCodePath() {
    const isWindows = process.platform === "win32";
    const homeDir = process.env.HOME || process.env.USERPROFILE || os2.homedir();
    let possiblePaths = [];
    if (isWindows) {
      possiblePaths = [
        "claude",
        // If in PATH
        path6.join(homeDir, "AppData", "Local", "Programs", "claude", "claude.exe"),
        path6.join(homeDir, ".bun", "bin", "claude.exe"),
        "C:\\Program Files\\claude\\claude.exe"
      ];
    } else {
      possiblePaths = [
        "claude",
        // If in PATH
        "/usr/local/bin/claude",
        "/usr/bin/claude",
        path6.join(homeDir, ".local", "bin", "claude"),
        path6.join(homeDir, "bin", "claude"),
        path6.join(homeDir, ".bun", "bin", "claude")
      ];
    }
    for (const cmdPath of possiblePaths) {
      try {
        if (!cmdPath.includes("/") && !cmdPath.includes("\\")) {
          const whichCmd = isWindows ? "where" : "which";
          const result = (0, import_child_process2.execSync)(`${whichCmd} ${cmdPath}`, { encoding: "utf8" }).trim();
          if (result) {
            return result.split("\n")[0].trim();
          }
        } else {
          if (fs5.existsSync(cmdPath)) {
            return cmdPath;
          }
        }
      } catch (e) {
      }
    }
    return null;
  }
  /**
   * Test if Claude Code is accessible and working (cross-platform)
   */
  testClaudeCode() {
    return __async(this, null, function* () {
      try {
        const cmdPath = this.plugin.settings.claudeCodePath || "claude";
        const isWindows = process.platform === "win32";
        const homeDir = process.env.HOME || process.env.USERPROFILE || os2.homedir();
        const pathSeparator = isWindows ? ";" : ":";
        const envPath = process.env.PATH || "";
        let pathsToAdd = [];
        if (isWindows) {
          pathsToAdd = [
            path6.join(homeDir, "AppData", "Local", "Programs", "nodejs"),
            path6.join(homeDir, ".bun", "bin"),
            "C:\\Program Files\\nodejs",
            "C:\\Program Files (x86)\\nodejs"
          ];
        } else {
          pathsToAdd = [
            path6.join(homeDir, ".nvm", "versions", "node", "v20.18.2", "bin"),
            path6.join(homeDir, ".bun", "bin"),
            "/usr/local/bin",
            "/usr/bin",
            "/bin"
          ];
        }
        const existingPaths = pathsToAdd.filter((p) => {
          try {
            return fs5.existsSync(p);
          } catch (e) {
            return false;
          }
        });
        const enhancedPath = [.../* @__PURE__ */ new Set([...existingPaths, ...envPath.split(pathSeparator)])].join(pathSeparator);
        return new Promise((resolve) => {
          (0, import_child_process2.exec)(`${cmdPath} --version`, {
            timeout: 5e3,
            env: __spreadProps(__spreadValues({}, process.env), {
              PATH: enhancedPath
            })
          }, (error, stdout, stderr) => {
            if (error) {
              resolve({ success: false, error: error.message });
            } else {
              resolve({ success: true });
            }
          });
        });
      } catch (e) {
        return { success: false, error: String(e) };
      }
    });
  }
};

// src/main.ts
var ClaudeCodePlugin = class extends import_obsidian5.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      initI18n(this.settings.language);
      this.registerView(
        VIEW_TYPE_CLAUDE_CODE,
        (leaf) => new ClaudeCodeView(leaf, this)
      );
      this.addRibbonIcon("bot", "Open Claude Code", () => {
        void this.activateView();
      });
      this.addCommand({
        id: "open-claude-code-view",
        name: "Open Claude Code panel",
        callback: () => {
          void this.activateView();
        }
      });
      this.addCommand({
        id: "run-claude-code-quick",
        name: "Quick run Claude Code (with default prompt)",
        callback: () => __async(this, null, function* () {
          yield this.activateView();
        })
      });
      this.addCommand({
        id: "run-claude-code-selection",
        name: "Run Claude Code on selected text",
        callback: () => __async(this, null, function* () {
          yield this.activateView();
          const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_CLAUDE_CODE);
          if (leaves.length > 0) {
            const view = leaves[0].view;
            const checkbox = view.containerEl.querySelector('.claude-code-options input[type="checkbox"]');
            if (checkbox) {
              checkbox.checked = true;
            }
          }
        })
      });
      this.addSettingTab(new ClaudeCodeSettingTab(this.app, this));
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
      const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_CLAUDE_CODE);
      leaves.forEach((leaf) => {
        const view = leaf.view;
        view.updateSettings();
      });
    });
  }
  activateView() {
    return __async(this, null, function* () {
      const { workspace } = this.app;
      let leaf = null;
      const leaves = workspace.getLeavesOfType(VIEW_TYPE_CLAUDE_CODE);
      if (leaves.length > 0) {
        leaf = leaves[0];
      } else {
        leaf = workspace.getRightLeaf(false);
        yield leaf == null ? void 0 : leaf.setViewState({ type: VIEW_TYPE_CLAUDE_CODE, active: true });
      }
      if (leaf) {
        void workspace.revealLeaf(leaf);
      }
    });
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL3dzL2xpYi9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL3dzL2xpYi9idWZmZXItdXRpbC5qcyIsICJub2RlX21vZHVsZXMvd3MvbGliL2xpbWl0ZXIuanMiLCAibm9kZV9tb2R1bGVzL3dzL2xpYi9wZXJtZXNzYWdlLWRlZmxhdGUuanMiLCAibm9kZV9tb2R1bGVzL3dzL2xpYi92YWxpZGF0aW9uLmpzIiwgIm5vZGVfbW9kdWxlcy93cy9saWIvcmVjZWl2ZXIuanMiLCAibm9kZV9tb2R1bGVzL3dzL2xpYi9zZW5kZXIuanMiLCAibm9kZV9tb2R1bGVzL3dzL2xpYi9ldmVudC10YXJnZXQuanMiLCAibm9kZV9tb2R1bGVzL3dzL2xpYi9leHRlbnNpb24uanMiLCAibm9kZV9tb2R1bGVzL3dzL2xpYi93ZWJzb2NrZXQuanMiLCAibm9kZV9tb2R1bGVzL3dzL2xpYi9zdHJlYW0uanMiLCAibm9kZV9tb2R1bGVzL3dzL2xpYi9zdWJwcm90b2NvbC5qcyIsICJub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC1zZXJ2ZXIuanMiLCAibm9kZV9tb2R1bGVzL3dzL3dyYXBwZXIubWpzIiwgInNyYy9jb3JlL3dlYnNvY2tldC93ZWJzb2NrZXQtdHlwZXMudHMiLCAic3JjL2NvcmUvd2Vic29ja2V0L3dlYnNvY2tldC1jbGllbnQudHMiLCAic3JjL21haW4udHMiLCAic3JjL3VpL3ZpZXcudHMiLCAic3JjL2NvcmUvdHlwZXMudHMiLCAic3JjL2kxOG4vbG9jYWxlcy9lbi50cyIsICJzcmMvaTE4bi9sb2NhbGVzL3poLnRzIiwgInNyYy9pMThuL2xvY2FsZXMvZXMudHMiLCAic3JjL2kxOG4vbG9jYWxlcy9kZS50cyIsICJzcmMvaTE4bi9sb2NhbGVzL3B0LnRzIiwgInNyYy9pMThuL2luZGV4LnRzIiwgInNyYy91aS91aS1idWlsZGVyLnRzIiwgInNyYy91aS9vdXRwdXQtcmVuZGVyZXIudHMiLCAic3JjL3VpL3BhcnNlcnMvYWdlbnQtYWN0aXZpdHktcGFyc2VyLnRzIiwgInNyYy91aS9hZ2VudC1hY3Rpdml0eS10cmFja2VyLnRzIiwgInNyYy9tYW5hZ2Vycy9ub3RlLWNvbnRleHQtbWFuYWdlci50cyIsICJzcmMvY29yZS9jbGF1ZGUtY29kZS1ydW5uZXIudHMiLCAic3JjL2NvcmUvc3RyZWFtaW5nL3Rvb2wtb3V0cHV0LWZvcm1hdHRlci50cyIsICJzcmMvY29yZS9zdHJlYW1pbmcvc3RyZWFtLWV2ZW50LXByb2Nlc3Nvci50cyIsICJzcmMvY29yZS9zZXNzaW9uLW1hbmFnZXIudHMiLCAic3JjL2NvcmUvcHJvbXB0LWJ1aWxkZXIudHMiLCAic3JjL2NvcmUvY2xpLWFyZ3MtYnVpbGRlci50cyIsICJzcmMvY29yZS9wcm9jZXNzLXNwYXduZXIudHMiLCAic3JjL2NvcmUvcmVzcG9uc2UtcGFyc2VyLnRzIiwgInNyYy9jb3JlL3N0cmVhbWluZy9yZXNwb25zZS1jb250ZW50LWV4dHJhY3Rvci50cyIsICJzcmMvdWkvcGFyc2Vycy9vdXRwdXQtc3RhdHVzLW1hbmFnZXIudHMiLCAic3JjL3VpL3JlbmRlcmVycy9kaWZmLWdlbmVyYXRvci50cyIsICJzcmMvdWkvdG9vbC1jYWxsLXRyYWNrZXIudHMiLCAic3JjL3VpL2NvbXBvbmVudHMvdG9vbC1jYWxsLWRpc3BsYXkudHMiLCAic3JjL3VpL3N0cmVhbWluZy1yZW5kZXJlci50cyIsICJzcmMvY29yZS9zZXR0aW5ncy50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCSU5BUllfVFlQRVMgPSBbJ25vZGVidWZmZXInLCAnYXJyYXlidWZmZXInLCAnZnJhZ21lbnRzJ107XG5jb25zdCBoYXNCbG9iID0gdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnO1xuXG5pZiAoaGFzQmxvYikgQklOQVJZX1RZUEVTLnB1c2goJ2Jsb2InKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEJJTkFSWV9UWVBFUyxcbiAgQ0xPU0VfVElNRU9VVDogMzAwMDAsXG4gIEVNUFRZX0JVRkZFUjogQnVmZmVyLmFsbG9jKDApLFxuICBHVUlEOiAnMjU4RUFGQTUtRTkxNC00N0RBLTk1Q0EtQzVBQjBEQzg1QjExJyxcbiAgaGFzQmxvYixcbiAga0Zvck9uRXZlbnRBdHRyaWJ1dGU6IFN5bWJvbCgna0lzRm9yT25FdmVudEF0dHJpYnV0ZScpLFxuICBrTGlzdGVuZXI6IFN5bWJvbCgna0xpc3RlbmVyJyksXG4gIGtTdGF0dXNDb2RlOiBTeW1ib2woJ3N0YXR1cy1jb2RlJyksXG4gIGtXZWJTb2NrZXQ6IFN5bWJvbCgnd2Vic29ja2V0JyksXG4gIE5PT1A6ICgpID0+IHt9XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBFTVBUWV9CVUZGRVIgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IEZhc3RCdWZmZXIgPSBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdO1xuXG4vKipcbiAqIE1lcmdlcyBhbiBhcnJheSBvZiBidWZmZXJzIGludG8gYSBuZXcgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGFycmF5IG9mIGJ1ZmZlcnMgdG8gY29uY2F0XG4gKiBAcGFyYW0ge051bWJlcn0gdG90YWxMZW5ndGggVGhlIHRvdGFsIGxlbmd0aCBvZiBidWZmZXJzIGluIHRoZSBsaXN0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSByZXN1bHRpbmcgYnVmZmVyXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHJldHVybiBFTVBUWV9CVUZGRVI7XG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkgcmV0dXJuIGxpc3RbMF07XG5cbiAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYnVmID0gbGlzdFtpXTtcbiAgICB0YXJnZXQuc2V0KGJ1Ziwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYnVmLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCB0b3RhbExlbmd0aCkge1xuICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlcih0YXJnZXQuYnVmZmVyLCB0YXJnZXQuYnl0ZU9mZnNldCwgb2Zmc2V0KTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogTWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IHNvdXJjZSBUaGUgYnVmZmVyIHRvIG1hc2tcbiAqIEBwYXJhbSB7QnVmZmVyfSBtYXNrIFRoZSBtYXNrIHRvIHVzZVxuICogQHBhcmFtIHtCdWZmZXJ9IG91dHB1dCBUaGUgYnVmZmVyIHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCB3cml0aW5nXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gbWFzay5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX21hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSBzb3VyY2VbaV0gXiBtYXNrW2kgJiAzXTtcbiAgfVxufVxuXG4vKipcbiAqIFVubWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIHVubWFza1xuICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIF91bm1hc2soYnVmZmVyLCBtYXNrKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmZmVyW2ldIF49IG1hc2tbaSAmIDNdO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBidWZmZXIgdG8gYW4gYEFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIFRoZSBidWZmZXIgdG8gY29udmVydFxuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IENvbnZlcnRlZCBidWZmZXJcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9BcnJheUJ1ZmZlcihidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IGJ1Zi5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBidWYuYnVmZmVyO1xuICB9XG5cbiAgcmV0dXJuIGJ1Zi5idWZmZXIuc2xpY2UoYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlT2Zmc2V0ICsgYnVmLmxlbmd0aCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGRhdGFgIHRvIGEgYEJ1ZmZlcmAuXG4gKlxuICogQHBhcmFtIHsqfSBkYXRhIFRoZSBkYXRhIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGJ1ZmZlclxuICogQHRocm93cyB7VHlwZUVycm9yfVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b0J1ZmZlcihkYXRhKSB7XG4gIHRvQnVmZmVyLnJlYWRPbmx5ID0gdHJ1ZTtcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSByZXR1cm4gZGF0YTtcblxuICBsZXQgYnVmO1xuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICBidWYgPSBuZXcgRmFzdEJ1ZmZlcihkYXRhKTtcbiAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICBidWYgPSBuZXcgRmFzdEJ1ZmZlcihkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgIHRvQnVmZmVyLnJlYWRPbmx5ID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gYnVmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29uY2F0LFxuICBtYXNrOiBfbWFzayxcbiAgdG9BcnJheUJ1ZmZlcixcbiAgdG9CdWZmZXIsXG4gIHVubWFzazogX3VubWFza1xufTtcblxuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgICovXG5pZiAoIXByb2Nlc3MuZW52LldTX05PX0JVRkZFUl9VVElMKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgYnVmZmVyVXRpbCA9IHJlcXVpcmUoJ2J1ZmZlcnV0aWwnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzLm1hc2sgPSBmdW5jdGlvbiAoc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICBpZiAobGVuZ3RoIDwgNDgpIF9tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBlbHNlIGJ1ZmZlclV0aWwubWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cy51bm1hc2sgPSBmdW5jdGlvbiAoYnVmZmVyLCBtYXNrKSB7XG4gICAgICBpZiAoYnVmZmVyLmxlbmd0aCA8IDMyKSBfdW5tYXNrKGJ1ZmZlciwgbWFzayk7XG4gICAgICBlbHNlIGJ1ZmZlclV0aWwudW5tYXNrKGJ1ZmZlciwgbWFzayk7XG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIENvbnRpbnVlIHJlZ2FyZGxlc3Mgb2YgdGhlIGVycm9yLlxuICB9XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBrRG9uZSA9IFN5bWJvbCgna0RvbmUnKTtcbmNvbnN0IGtSdW4gPSBTeW1ib2woJ2tSdW4nKTtcblxuLyoqXG4gKiBBIHZlcnkgc2ltcGxlIGpvYiBxdWV1ZSB3aXRoIGFkanVzdGFibGUgY29uY3VycmVuY3kuIEFkYXB0ZWQgZnJvbVxuICogaHR0cHM6Ly9naXRodWIuY29tL1NUUk1ML2FzeW5jLWxpbWl0ZXJcbiAqL1xuY2xhc3MgTGltaXRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBMaW1pdGVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25jdXJyZW5jeT1JbmZpbml0eV0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGpvYnMgYWxsb3dlZFxuICAgKiAgICAgdG8gcnVuIGNvbmN1cnJlbnRseVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uY3VycmVuY3kpIHtcbiAgICB0aGlzW2tEb25lXSA9ICgpID0+IHtcbiAgICAgIHRoaXMucGVuZGluZy0tO1xuICAgICAgdGhpc1trUnVuXSgpO1xuICAgIH07XG4gICAgdGhpcy5jb25jdXJyZW5jeSA9IGNvbmN1cnJlbmN5IHx8IEluZmluaXR5O1xuICAgIHRoaXMuam9icyA9IFtdO1xuICAgIHRoaXMucGVuZGluZyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGpvYiB0byB0aGUgcXVldWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGpvYiBUaGUgam9iIHRvIHJ1blxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGQoam9iKSB7XG4gICAgdGhpcy5qb2JzLnB1c2goam9iKTtcbiAgICB0aGlzW2tSdW5dKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGpvYiBmcm9tIHRoZSBxdWV1ZSBhbmQgcnVucyBpdCBpZiBwb3NzaWJsZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFtrUnVuXSgpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nID09PSB0aGlzLmNvbmN1cnJlbmN5KSByZXR1cm47XG5cbiAgICBpZiAodGhpcy5qb2JzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgam9iID0gdGhpcy5qb2JzLnNoaWZ0KCk7XG5cbiAgICAgIHRoaXMucGVuZGluZysrO1xuICAgICAgam9iKHRoaXNba0RvbmVdKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMaW1pdGVyO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgemxpYiA9IHJlcXVpcmUoJ3psaWInKTtcblxuY29uc3QgYnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcbmNvbnN0IExpbWl0ZXIgPSByZXF1aXJlKCcuL2xpbWl0ZXInKTtcbmNvbnN0IHsga1N0YXR1c0NvZGUgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IEZhc3RCdWZmZXIgPSBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdO1xuY29uc3QgVFJBSUxFUiA9IEJ1ZmZlci5mcm9tKFsweDAwLCAweDAwLCAweGZmLCAweGZmXSk7XG5jb25zdCBrUGVyTWVzc2FnZURlZmxhdGUgPSBTeW1ib2woJ3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3Qga1RvdGFsTGVuZ3RoID0gU3ltYm9sKCd0b3RhbC1sZW5ndGgnKTtcbmNvbnN0IGtDYWxsYmFjayA9IFN5bWJvbCgnY2FsbGJhY2snKTtcbmNvbnN0IGtCdWZmZXJzID0gU3ltYm9sKCdidWZmZXJzJyk7XG5jb25zdCBrRXJyb3IgPSBTeW1ib2woJ2Vycm9yJyk7XG5cbi8vXG4vLyBXZSBsaW1pdCB6bGliIGNvbmN1cnJlbmN5LCB3aGljaCBwcmV2ZW50cyBzZXZlcmUgbWVtb3J5IGZyYWdtZW50YXRpb25cbi8vIGFzIGRvY3VtZW50ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy84ODcxI2lzc3VlY29tbWVudC0yNTA5MTU5MTNcbi8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTIwMlxuLy9cbi8vIEludGVudGlvbmFsbHkgZ2xvYmFsOyBpdCdzIHRoZSBnbG9iYWwgdGhyZWFkIHBvb2wgdGhhdCdzIGFuIGlzc3VlLlxuLy9cbmxldCB6bGliTGltaXRlcjtcblxuLyoqXG4gKiBwZXJtZXNzYWdlLWRlZmxhdGUgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIFBlck1lc3NhZ2VEZWZsYXRlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQZXJNZXNzYWdlRGVmbGF0ZSBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxOdW1iZXIpfSBbb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzXSBBZHZlcnRpc2Ugc3VwcG9ydFxuICAgKiAgICAgZm9yLCBvciByZXF1ZXN0LCBhIGN1c3RvbSBjbGllbnQgd2luZG93IHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcj1mYWxzZV0gQWR2ZXJ0aXNlL1xuICAgKiAgICAgYWNrbm93bGVkZ2UgZGlzYWJsaW5nIG9mIGNsaWVudCBjb250ZXh0IHRha2VvdmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0PTEwXSBUaGUgbnVtYmVyIG9mIGNvbmN1cnJlbnRcbiAgICogICAgIGNhbGxzIHRvIHpsaWJcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxOdW1iZXIpfSBbb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzXSBSZXF1ZXN0L2NvbmZpcm0gdGhlXG4gICAqICAgICB1c2Ugb2YgYSBjdXN0b20gc2VydmVyIHdpbmRvdyBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXI9ZmFsc2VdIFJlcXVlc3QvYWNjZXB0XG4gICAqICAgICBkaXNhYmxpbmcgb2Ygc2VydmVyIGNvbnRleHQgdGFrZW92ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRocmVzaG9sZD0xMDI0XSBTaXplIChpbiBieXRlcykgYmVsb3cgd2hpY2hcbiAgICogICAgIG1lc3NhZ2VzIHNob3VsZCBub3QgYmUgY29tcHJlc3NlZCBpZiBjb250ZXh0IHRha2VvdmVyIGlzIGRpc2FibGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy56bGliRGVmbGF0ZU9wdGlvbnNdIE9wdGlvbnMgdG8gcGFzcyB0byB6bGliIG9uXG4gICAqICAgICBkZWZsYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy56bGliSW5mbGF0ZU9wdGlvbnNdIE9wdGlvbnMgdG8gcGFzcyB0byB6bGliIG9uXG4gICAqICAgICBpbmZsYXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzU2VydmVyPWZhbHNlXSBDcmVhdGUgdGhlIGluc3RhbmNlIGluIGVpdGhlciBzZXJ2ZXIgb3JcbiAgICogICAgIGNsaWVudCBtb2RlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4UGF5bG9hZD0wXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2UgbGVuZ3RoXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBpc1NlcnZlciwgbWF4UGF5bG9hZCkge1xuICAgIHRoaXMuX21heFBheWxvYWQgPSBtYXhQYXlsb2FkIHwgMDtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLl90aHJlc2hvbGQgPVxuICAgICAgdGhpcy5fb3B0aW9ucy50aHJlc2hvbGQgIT09IHVuZGVmaW5lZCA/IHRoaXMuX29wdGlvbnMudGhyZXNob2xkIDogMTAyNDtcbiAgICB0aGlzLl9pc1NlcnZlciA9ICEhaXNTZXJ2ZXI7XG4gICAgdGhpcy5fZGVmbGF0ZSA9IG51bGw7XG4gICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG5cbiAgICB0aGlzLnBhcmFtcyA9IG51bGw7XG5cbiAgICBpZiAoIXpsaWJMaW1pdGVyKSB7XG4gICAgICBjb25zdCBjb25jdXJyZW5jeSA9XG4gICAgICAgIHRoaXMuX29wdGlvbnMuY29uY3VycmVuY3lMaW1pdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyB0aGlzLl9vcHRpb25zLmNvbmN1cnJlbmN5TGltaXRcbiAgICAgICAgICA6IDEwO1xuICAgICAgemxpYkxpbWl0ZXIgPSBuZXcgTGltaXRlcihjb25jdXJyZW5jeSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGV4dGVuc2lvbk5hbWUoKSB7XG4gICAgcmV0dXJuICdwZXJtZXNzYWdlLWRlZmxhdGUnO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gRXh0ZW5zaW9uIHBhcmFtZXRlcnNcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgb2ZmZXIoKSB7XG4gICAgY29uc3QgcGFyYW1zID0ge307XG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgcGFyYW1zLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHMpIHtcbiAgICAgIHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzKSB7XG4gICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PSBudWxsKSB7XG4gICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHQgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyL3Jlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWd1cmF0aW9ucyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVycy9yZXBvbnNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHVibGljXG4gICAqL1xuICBhY2NlcHQoY29uZmlndXJhdGlvbnMpIHtcbiAgICBjb25maWd1cmF0aW9ucyA9IHRoaXMubm9ybWFsaXplUGFyYW1zKGNvbmZpZ3VyYXRpb25zKTtcblxuICAgIHRoaXMucGFyYW1zID0gdGhpcy5faXNTZXJ2ZXJcbiAgICAgID8gdGhpcy5hY2NlcHRBc1NlcnZlcihjb25maWd1cmF0aW9ucylcbiAgICAgIDogdGhpcy5hY2NlcHRBc0NsaWVudChjb25maWd1cmF0aW9ucyk7XG5cbiAgICByZXR1cm4gdGhpcy5wYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgYWxsIHJlc291cmNlcyB1c2VkIGJ5IHRoZSBleHRlbnNpb24uXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuX2luZmxhdGUpIHtcbiAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kZWZsYXRlKSB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZS5jbG9zZSgpO1xuICAgICAgdGhpcy5fZGVmbGF0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnVGhlIGRlZmxhdGUgc3RyZWFtIHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgcHJvY2Vzc2VkJ1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogIEFjY2VwdCBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IG9mZmVycyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFjY2VwdEFzU2VydmVyKG9mZmVycykge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLl9vcHRpb25zO1xuICAgIGNvbnN0IGFjY2VwdGVkID0gb2ZmZXJzLmZpbmQoKHBhcmFtcykgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICAob3B0cy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3ZlciA9PT0gZmFsc2UgJiZcbiAgICAgICAgICBwYXJhbXMuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIpIHx8XG4gICAgICAgIChwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cyAmJlxuICAgICAgICAgIChvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICAodHlwZW9mIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID4gcGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMpKSkgfHxcbiAgICAgICAgKHR5cGVvZiBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgIXBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICBpZiAoIWFjY2VwdGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbmUgb2YgdGhlIGV4dGVuc2lvbiBvZmZlcnMgY2FuIGJlIGFjY2VwdGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIGFjY2VwdGVkLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdHMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIGFjY2VwdGVkLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICBhY2NlcHRlZC5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzID0gb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPT09IHRydWUgfHxcbiAgICAgIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gZmFsc2VcbiAgICApIHtcbiAgICAgIGRlbGV0ZSBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzO1xuICAgIH1cblxuICAgIHJldHVybiBhY2NlcHRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHQgdGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiByZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gcmVzcG9uc2UgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiByZXNwb25zZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFjY2VwdEFzQ2xpZW50KHJlc3BvbnNlKSB7XG4gICAgY29uc3QgcGFyYW1zID0gcmVzcG9uc2VbMF07XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLl9vcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyID09PSBmYWxzZSAmJlxuICAgICAgcGFyYW1zLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgcGFyYW1ldGVyIFwiY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXJcIicpO1xuICAgIH1cblxuICAgIGlmICghcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSBmYWxzZSB8fFxuICAgICAgKHR5cGVvZiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInICYmXG4gICAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID4gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVW5leHBlY3RlZCBvciBpbnZhbGlkIHBhcmFtZXRlciBcImNsaWVudF9tYXhfd2luZG93X2JpdHNcIidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY29uZmlndXJhdGlvbnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnMvcmVwb25zZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIG9mZmVycy9yZXNwb25zZSB3aXRoIG5vcm1hbGl6ZWQgcGFyYW1ldGVyc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbm9ybWFsaXplUGFyYW1zKGNvbmZpZ3VyYXRpb25zKSB7XG4gICAgY29uZmlndXJhdGlvbnMuZm9yRWFjaCgocGFyYW1zKSA9PiB7XG4gICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBwYXJhbXNba2V5XTtcblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUGFyYW1ldGVyIFwiJHtrZXl9XCIgbXVzdCBoYXZlIG9ubHkgYSBzaW5nbGUgdmFsdWVgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gdmFsdWVbMF07XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsaWVudF9tYXhfd2luZG93X2JpdHMnKSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBudW0gPSArdmFsdWU7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobnVtKSB8fCBudW0gPCA4IHx8IG51bSA+IDE1KSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gbnVtO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzU2VydmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnc2VydmVyX21heF93aW5kb3dfYml0cycpIHtcbiAgICAgICAgICBjb25zdCBudW0gPSArdmFsdWU7XG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG51bSkgfHwgbnVtIDwgOCB8fCBudW0gPiAxNSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlID0gbnVtO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIGtleSA9PT0gJ2NsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3NlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyJ1xuICAgICAgICApIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gcGFyYW1ldGVyIFwiJHtrZXl9XCJgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjb25maWd1cmF0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzIGRhdGEuIENvbmN1cnJlbmN5IGxpbWl0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBkZWNvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICB6bGliTGltaXRlci5hZGQoKGRvbmUpID0+IHtcbiAgICAgIHRoaXMuX2RlY29tcHJlc3MoZGF0YSwgZmluLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wcmVzcyBkYXRhLiBDb25jdXJyZW5jeSBsaW1pdGVkLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBEYXRhIHRvIGNvbXByZXNzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICB6bGliTGltaXRlci5hZGQoKGRvbmUpID0+IHtcbiAgICAgIHRoaXMuX2NvbXByZXNzKGRhdGEsIGZpbiwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wcmVzcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZWNvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBlbmRwb2ludCA9IHRoaXMuX2lzU2VydmVyID8gJ2NsaWVudCcgOiAnc2VydmVyJztcblxuICAgIGlmICghdGhpcy5faW5mbGF0ZSkge1xuICAgICAgY29uc3Qga2V5ID0gYCR7ZW5kcG9pbnR9X21heF93aW5kb3dfYml0c2A7XG4gICAgICBjb25zdCB3aW5kb3dCaXRzID1cbiAgICAgICAgdHlwZW9mIHRoaXMucGFyYW1zW2tleV0gIT09ICdudW1iZXInXG4gICAgICAgICAgPyB6bGliLlpfREVGQVVMVF9XSU5ET1dCSVRTXG4gICAgICAgICAgOiB0aGlzLnBhcmFtc1trZXldO1xuXG4gICAgICB0aGlzLl9pbmZsYXRlID0gemxpYi5jcmVhdGVJbmZsYXRlUmF3KHtcbiAgICAgICAgLi4udGhpcy5fb3B0aW9ucy56bGliSW5mbGF0ZU9wdGlvbnMsXG4gICAgICAgIHdpbmRvd0JpdHNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrUGVyTWVzc2FnZURlZmxhdGVdID0gdGhpcztcbiAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuICAgICAgdGhpcy5faW5mbGF0ZS5vbignZXJyb3InLCBpbmZsYXRlT25FcnJvcik7XG4gICAgICB0aGlzLl9pbmZsYXRlLm9uKCdkYXRhJywgaW5mbGF0ZU9uRGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5faW5mbGF0ZVtrQ2FsbGJhY2tdID0gY2FsbGJhY2s7XG5cbiAgICB0aGlzLl9pbmZsYXRlLndyaXRlKGRhdGEpO1xuICAgIGlmIChmaW4pIHRoaXMuX2luZmxhdGUud3JpdGUoVFJBSUxFUik7XG5cbiAgICB0aGlzLl9pbmZsYXRlLmZsdXNoKCgpID0+IHtcbiAgICAgIGNvbnN0IGVyciA9IHRoaXMuX2luZmxhdGVba0Vycm9yXTtcblxuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBidWZmZXJVdGlsLmNvbmNhdChcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10sXG4gICAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXVxuICAgICAgKTtcblxuICAgICAgaWYgKHRoaXMuX2luZmxhdGUuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10gPSBbXTtcblxuICAgICAgICBpZiAoZmluICYmIHRoaXMucGFyYW1zW2Ake2VuZHBvaW50fV9ub19jb250ZXh0X3Rha2VvdmVyYF0pIHtcbiAgICAgICAgICB0aGlzLl9pbmZsYXRlLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHJlc3MgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgRGF0YSB0byBjb21wcmVzc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBlbmRwb2ludCA9IHRoaXMuX2lzU2VydmVyID8gJ3NlcnZlcicgOiAnY2xpZW50JztcblxuICAgIGlmICghdGhpcy5fZGVmbGF0ZSkge1xuICAgICAgY29uc3Qga2V5ID0gYCR7ZW5kcG9pbnR9X21heF93aW5kb3dfYml0c2A7XG4gICAgICBjb25zdCB3aW5kb3dCaXRzID1cbiAgICAgICAgdHlwZW9mIHRoaXMucGFyYW1zW2tleV0gIT09ICdudW1iZXInXG4gICAgICAgICAgPyB6bGliLlpfREVGQVVMVF9XSU5ET1dCSVRTXG4gICAgICAgICAgOiB0aGlzLnBhcmFtc1trZXldO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlID0gemxpYi5jcmVhdGVEZWZsYXRlUmF3KHtcbiAgICAgICAgLi4udGhpcy5fb3B0aW9ucy56bGliRGVmbGF0ZU9wdGlvbnMsXG4gICAgICAgIHdpbmRvd0JpdHNcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10gPSBbXTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZS5vbignZGF0YScsIGRlZmxhdGVPbkRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXSA9IGNhbGxiYWNrO1xuXG4gICAgdGhpcy5fZGVmbGF0ZS53cml0ZShkYXRhKTtcbiAgICB0aGlzLl9kZWZsYXRlLmZsdXNoKHpsaWIuWl9TWU5DX0ZMVVNILCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2RlZmxhdGUpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIGRlZmxhdGUgc3RyZWFtIHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAgICAvL1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBkYXRhID0gYnVmZmVyVXRpbC5jb25jYXQoXG4gICAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdLFxuICAgICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF1cbiAgICAgICk7XG5cbiAgICAgIGlmIChmaW4pIHtcbiAgICAgICAgZGF0YSA9IG5ldyBGYXN0QnVmZmVyKGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEubGVuZ3RoIC0gNCk7XG4gICAgICB9XG5cbiAgICAgIC8vXG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgY2FsbGJhY2sgd2lsbCBub3QgYmUgY2FsbGVkIGFnYWluIGluXG4gICAgICAvLyBgUGVyTWVzc2FnZURlZmxhdGUjY2xlYW51cCgpYC5cbiAgICAgIC8vXG4gICAgICB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja10gPSBudWxsO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10gPSBbXTtcblxuICAgICAgaWYgKGZpbiAmJiB0aGlzLnBhcmFtc1tgJHtlbmRwb2ludH1fbm9fY29udGV4dF90YWtlb3ZlcmBdKSB7XG4gICAgICAgIHRoaXMuX2RlZmxhdGUucmVzZXQoKTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQZXJNZXNzYWdlRGVmbGF0ZTtcblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkRlZmxhdGVSYXdgIHN0cmVhbSBgJ2RhdGEnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZsYXRlT25EYXRhKGNodW5rKSB7XG4gIHRoaXNba0J1ZmZlcnNdLnB1c2goY2h1bmspO1xuICB0aGlzW2tUb3RhbExlbmd0aF0gKz0gY2h1bmsubGVuZ3RoO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuSW5mbGF0ZVJhd2Agc3RyZWFtIGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluZmxhdGVPbkRhdGEoY2h1bmspIHtcbiAgdGhpc1trVG90YWxMZW5ndGhdICs9IGNodW5rLmxlbmd0aDtcblxuICBpZiAoXG4gICAgdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9tYXhQYXlsb2FkIDwgMSB8fFxuICAgIHRoaXNba1RvdGFsTGVuZ3RoXSA8PSB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX21heFBheWxvYWRcbiAgKSB7XG4gICAgdGhpc1trQnVmZmVyc10ucHVzaChjaHVuayk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpc1trRXJyb3JdID0gbmV3IFJhbmdlRXJyb3IoJ01heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnKTtcbiAgdGhpc1trRXJyb3JdLmNvZGUgPSAnV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIJztcbiAgdGhpc1trRXJyb3JdW2tTdGF0dXNDb2RlXSA9IDEwMDk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBpbmZsYXRlT25EYXRhKTtcblxuICAvL1xuICAvLyBUaGUgY2hvaWNlIHRvIGVtcGxveSBgemxpYi5yZXNldCgpYCBvdmVyIGB6bGliLmNsb3NlKClgIGlzIGRpY3RhdGVkIGJ5IHRoZVxuICAvLyBmYWN0IHRoYXQgaW4gTm9kZS5qcyB2ZXJzaW9ucyBwcmlvciB0byAxMy4xMC4wLCB0aGUgY2FsbGJhY2sgZm9yXG4gIC8vIGB6bGliLmZsdXNoKClgIGlzIG5vdCBjYWxsZWQgaWYgYHpsaWIuY2xvc2UoKWAgaXMgdXNlZC4gVXRpbGl6aW5nXG4gIC8vIGB6bGliLnJlc2V0KClgIGVuc3VyZXMgdGhhdCBlaXRoZXIgdGhlIGNhbGxiYWNrIGlzIGludm9rZWQgb3IgYW4gZXJyb3IgaXNcbiAgLy8gZW1pdHRlZC5cbiAgLy9cbiAgdGhpcy5yZXNldCgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuSW5mbGF0ZVJhd2Agc3RyZWFtIGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVtaXR0ZWQgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluZmxhdGVPbkVycm9yKGVycikge1xuICAvL1xuICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIGNhbGwgYFpsaWIjY2xvc2UoKWAgYXMgdGhlIGhhbmRsZSBpcyBhdXRvbWF0aWNhbGx5XG4gIC8vIGNsb3NlZCB3aGVuIGFuIGVycm9yIGlzIGVtaXR0ZWQuXG4gIC8vXG4gIHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5faW5mbGF0ZSA9IG51bGw7XG5cbiAgaWYgKHRoaXNba0Vycm9yXSkge1xuICAgIHRoaXNba0NhbGxiYWNrXSh0aGlzW2tFcnJvcl0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGVycltrU3RhdHVzQ29kZV0gPSAxMDA3O1xuICB0aGlzW2tDYWxsYmFja10oZXJyKTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgaXNVdGY4IH0gPSByZXF1aXJlKCdidWZmZXInKTtcblxuY29uc3QgeyBoYXNCbG9iIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG4vL1xuLy8gQWxsb3dlZCB0b2tlbiBjaGFyYWN0ZXJzOlxuLy9cbi8vICchJywgJyMnLCAnJCcsICclJywgJyYnLCAnJycsICcqJywgJysnLCAnLScsXG4vLyAnLicsIDAtOSwgQS1aLCAnXicsICdfJywgJ2AnLCBhLXosICd8JywgJ34nXG4vL1xuLy8gdG9rZW5DaGFyc1szMl0gPT09IDAgLy8gJyAnXG4vLyB0b2tlbkNoYXJzWzMzXSA9PT0gMSAvLyAnISdcbi8vIHRva2VuQ2hhcnNbMzRdID09PSAwIC8vICdcIidcbi8vIC4uLlxuLy9cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdG9rZW5DaGFycyA9IFtcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMCAtIDE1XG4gIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDE2IC0gMzFcbiAgMCwgMSwgMCwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMSwgMSwgMCwgMSwgMSwgMCwgLy8gMzIgLSA0N1xuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyA0OCAtIDYzXG4gIDAsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDY0IC0gNzlcbiAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCwgMCwgMCwgMSwgMSwgLy8gODAgLSA5NVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAvLyA5NiAtIDExMVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAxLCAwLCAxLCAwIC8vIDExMiAtIDEyN1xuXTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGF0dXMgY29kZSBpcyBhbGxvd2VkIGluIGEgY2xvc2UgZnJhbWUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIHN0YXR1cyBjb2RlXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHN0YXR1cyBjb2RlIGlzIHZhbGlkLCBlbHNlIGBmYWxzZWBcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkge1xuICByZXR1cm4gKFxuICAgIChjb2RlID49IDEwMDAgJiZcbiAgICAgIGNvZGUgPD0gMTAxNCAmJlxuICAgICAgY29kZSAhPT0gMTAwNCAmJlxuICAgICAgY29kZSAhPT0gMTAwNSAmJlxuICAgICAgY29kZSAhPT0gMTAwNikgfHxcbiAgICAoY29kZSA+PSAzMDAwICYmIGNvZGUgPD0gNDk5OSlcbiAgKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBidWZmZXIgY29udGFpbnMgb25seSBjb3JyZWN0IFVURi04LlxuICogUG9ydGVkIGZyb20gaHR0cHM6Ly93d3cuY2wuY2FtLmFjLnVrLyU3RW1nazI1L3Vjcy91dGY4X2NoZWNrLmMgYnlcbiAqIE1hcmt1cyBLdWhuLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgVGhlIGJ1ZmZlciB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGBidWZgIGNvbnRhaW5zIG9ubHkgY29ycmVjdCBVVEYtOCwgZWxzZSBgZmFsc2VgXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIF9pc1ZhbGlkVVRGOChidWYpIHtcbiAgY29uc3QgbGVuID0gYnVmLmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgaWYgKChidWZbaV0gJiAweDgwKSA9PT0gMCkge1xuICAgICAgLy8gMHh4eHh4eHhcbiAgICAgIGkrKztcbiAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAweGUwKSA9PT0gMHhjMCkge1xuICAgICAgLy8gMTEweHh4eHggMTB4eHh4eHhcbiAgICAgIGlmIChcbiAgICAgICAgaSArIDEgPT09IGxlbiB8fFxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaV0gJiAweGZlKSA9PT0gMHhjMCAvLyBPdmVybG9uZ1xuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaSArPSAyO1xuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZjApID09PSAweGUwKSB7XG4gICAgICAvLyAxMTEweHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgaWYgKFxuICAgICAgICBpICsgMiA+PSBsZW4gfHxcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2kgKyAyXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaV0gPT09IDB4ZTAgJiYgKGJ1ZltpICsgMV0gJiAweGUwKSA9PT0gMHg4MCkgfHwgLy8gT3ZlcmxvbmdcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhlZCAmJiAoYnVmW2kgKyAxXSAmIDB4ZTApID09PSAweGEwKSAvLyBTdXJyb2dhdGUgKFUrRDgwMCAtIFUrREZGRilcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMztcbiAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAweGY4KSA9PT0gMHhmMCkge1xuICAgICAgLy8gMTExMTB4eHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgIGlmIChcbiAgICAgICAgaSArIDMgPj0gbGVuIHx8XG4gICAgICAgIChidWZbaSArIDFdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpICsgMl0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2kgKyAzXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaV0gPT09IDB4ZjAgJiYgKGJ1ZltpICsgMV0gJiAweGYwKSA9PT0gMHg4MCkgfHwgLy8gT3ZlcmxvbmdcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhmNCAmJiBidWZbaSArIDFdID4gMHg4ZikgfHxcbiAgICAgICAgYnVmW2ldID4gMHhmNCAvLyA+IFUrMTBGRkZGXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpICs9IDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSB2YWx1ZSBpcyBhIGBCbG9iYC5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBiZSB0ZXN0ZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYEJsb2JgLCBlbHNlIGBmYWxzZWBcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIGhhc0Jsb2IgJiZcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHZhbHVlLmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHZhbHVlLnR5cGUgPT09ICdzdHJpbmcnICYmXG4gICAgdHlwZW9mIHZhbHVlLnN0cmVhbSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICh2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnQmxvYicgfHxcbiAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdGaWxlJylcbiAgKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQmxvYixcbiAgaXNWYWxpZFN0YXR1c0NvZGUsXG4gIGlzVmFsaWRVVEY4OiBfaXNWYWxpZFVURjgsXG4gIHRva2VuQ2hhcnNcbn07XG5cbmlmIChpc1V0ZjgpIHtcbiAgbW9kdWxlLmV4cG9ydHMuaXNWYWxpZFVURjggPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgcmV0dXJuIGJ1Zi5sZW5ndGggPCAyNCA/IF9pc1ZhbGlkVVRGOChidWYpIDogaXNVdGY4KGJ1Zik7XG4gIH07XG59IC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqLyBlbHNlIGlmICghcHJvY2Vzcy5lbnYuV1NfTk9fVVRGXzhfVkFMSURBVEUpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBpc1ZhbGlkVVRGOCA9IHJlcXVpcmUoJ3V0Zi04LXZhbGlkYXRlJyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cy5pc1ZhbGlkVVRGOCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICAgIHJldHVybiBidWYubGVuZ3RoIDwgMzIgPyBfaXNWYWxpZFVURjgoYnVmKSA6IGlzVmFsaWRVVEY4KGJ1Zik7XG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIENvbnRpbnVlIHJlZ2FyZGxlc3Mgb2YgdGhlIGVycm9yLlxuICB9XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IFdyaXRhYmxlIH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3Qge1xuICBCSU5BUllfVFlQRVMsXG4gIEVNUFRZX0JVRkZFUixcbiAga1N0YXR1c0NvZGUsXG4gIGtXZWJTb2NrZXRcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgeyBjb25jYXQsIHRvQXJyYXlCdWZmZXIsIHVubWFzayB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuY29uc3QgeyBpc1ZhbGlkU3RhdHVzQ29kZSwgaXNWYWxpZFVURjggfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG5jb25zdCBGYXN0QnVmZmVyID0gQnVmZmVyW1N5bWJvbC5zcGVjaWVzXTtcblxuY29uc3QgR0VUX0lORk8gPSAwO1xuY29uc3QgR0VUX1BBWUxPQURfTEVOR1RIXzE2ID0gMTtcbmNvbnN0IEdFVF9QQVlMT0FEX0xFTkdUSF82NCA9IDI7XG5jb25zdCBHRVRfTUFTSyA9IDM7XG5jb25zdCBHRVRfREFUQSA9IDQ7XG5jb25zdCBJTkZMQVRJTkcgPSA1O1xuY29uc3QgREVGRVJfRVZFTlQgPSA2O1xuXG4vKipcbiAqIEh5QmkgUmVjZWl2ZXIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGV4dGVuZHMgV3JpdGFibGVcbiAqL1xuY2xhc3MgUmVjZWl2ZXIgZXh0ZW5kcyBXcml0YWJsZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUmVjZWl2ZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyXG4gICAqICAgICBhbnkgb2YgdGhlIGAnbWVzc2FnZSdgLCBgJ3BpbmcnYCwgYW5kIGAncG9uZydgIGV2ZW50cyBjYW4gYmUgZW1pdHRlZFxuICAgKiAgICAgbXVsdGlwbGUgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYmluYXJ5VHlwZT1ub2RlYnVmZmVyXSBUaGUgdHlwZSBmb3IgYmluYXJ5IGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmV4dGVuc2lvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuZWdvdGlhdGVkXG4gICAqICAgICBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaXNTZXJ2ZXI9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIHRvIG9wZXJhdGUgaW5cbiAgICogICAgIGNsaWVudCBvciBzZXJ2ZXIgbW9kZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0wXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2UgbGVuZ3RoXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9hbGxvd1N5bmNocm9ub3VzRXZlbnRzID1cbiAgICAgIG9wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cyAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzXG4gICAgICAgIDogdHJ1ZTtcbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gb3B0aW9ucy5iaW5hcnlUeXBlIHx8IEJJTkFSWV9UWVBFU1swXTtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gb3B0aW9ucy5leHRlbnNpb25zIHx8IHt9O1xuICAgIHRoaXMuX2lzU2VydmVyID0gISFvcHRpb25zLmlzU2VydmVyO1xuICAgIHRoaXMuX21heFBheWxvYWQgPSBvcHRpb25zLm1heFBheWxvYWQgfCAwO1xuICAgIHRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiA9ICEhb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb247XG4gICAgdGhpc1trV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPSAwO1xuICAgIHRoaXMuX2J1ZmZlcnMgPSBbXTtcblxuICAgIHRoaXMuX2NvbXByZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYXNrID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xuICAgIHRoaXMuX21hc2tlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2ZpbiA9IGZhbHNlO1xuICAgIHRoaXMuX29wY29kZSA9IDA7XG5cbiAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgdGhpcy5fZXJyb3JlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudHMgYFdyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBUaGUgY2h1bmsgb2YgZGF0YSB0byB3cml0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RpbmcgVGhlIGNoYXJhY3RlciBlbmNvZGluZyBvZiBgY2h1bmtgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDggJiYgdGhpcy5fc3RhdGUgPT0gR0VUX0lORk8pIHJldHVybiBjYigpO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBjaHVuay5sZW5ndGg7XG4gICAgdGhpcy5fYnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3VtZXMgYG5gIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gY29uc3VtZVxuICAgKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSBjb25zdW1lZCBieXRlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3VtZShuKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBuO1xuXG4gICAgaWYgKG4gPT09IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoKSByZXR1cm4gdGhpcy5fYnVmZmVycy5zaGlmdCgpO1xuXG4gICAgaWYgKG4gPCB0aGlzLl9idWZmZXJzWzBdLmxlbmd0aCkge1xuICAgICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyc1swXTtcbiAgICAgIHRoaXMuX2J1ZmZlcnNbMF0gPSBuZXcgRmFzdEJ1ZmZlcihcbiAgICAgICAgYnVmLmJ1ZmZlcixcbiAgICAgICAgYnVmLmJ5dGVPZmZzZXQgKyBuLFxuICAgICAgICBidWYubGVuZ3RoIC0gblxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBuKTtcbiAgICB9XG5cbiAgICBjb25zdCBkc3QgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG5cbiAgICBkbyB7XG4gICAgICBjb25zdCBidWYgPSB0aGlzLl9idWZmZXJzWzBdO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gZHN0Lmxlbmd0aCAtIG47XG5cbiAgICAgIGlmIChuID49IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgZHN0LnNldCh0aGlzLl9idWZmZXJzLnNoaWZ0KCksIG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkc3Quc2V0KG5ldyBVaW50OEFycmF5KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBuKSwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyc1swXSA9IG5ldyBGYXN0QnVmZmVyKFxuICAgICAgICAgIGJ1Zi5idWZmZXIsXG4gICAgICAgICAgYnVmLmJ5dGVPZmZzZXQgKyBuLFxuICAgICAgICAgIGJ1Zi5sZW5ndGggLSBuXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIG4gLT0gYnVmLmxlbmd0aDtcbiAgICB9IHdoaWxlIChuID4gMCk7XG5cbiAgICByZXR1cm4gZHN0O1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgcGFyc2luZyBsb29wLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhcnRMb29wKGNiKSB7XG4gICAgdGhpcy5fbG9vcCA9IHRydWU7XG5cbiAgICBkbyB7XG4gICAgICBzd2l0Y2ggKHRoaXMuX3N0YXRlKSB7XG4gICAgICAgIGNhc2UgR0VUX0lORk86XG4gICAgICAgICAgdGhpcy5nZXRJbmZvKGNiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfUEFZTE9BRF9MRU5HVEhfMTY6XG4gICAgICAgICAgdGhpcy5nZXRQYXlsb2FkTGVuZ3RoMTYoY2IpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9QQVlMT0FEX0xFTkdUSF82NDpcbiAgICAgICAgICB0aGlzLmdldFBheWxvYWRMZW5ndGg2NChjYik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX01BU0s6XG4gICAgICAgICAgdGhpcy5nZXRNYXNrKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX0RBVEE6XG4gICAgICAgICAgdGhpcy5nZXREYXRhKGNiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBJTkZMQVRJTkc6XG4gICAgICAgIGNhc2UgREVGRVJfRVZFTlQ6XG4gICAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IHdoaWxlICh0aGlzLl9sb29wKTtcblxuICAgIGlmICghdGhpcy5fZXJyb3JlZCkgY2IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgZmlyc3QgdHdvIGJ5dGVzIG9mIGEgZnJhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRJbmZvKGNiKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCAyKSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnVmID0gdGhpcy5jb25zdW1lKDIpO1xuXG4gICAgaWYgKChidWZbMF0gJiAweDMwKSAhPT0gMHgwMCkge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnUlNWMiBhbmQgUlNWMyBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8yXzMnXG4gICAgICApO1xuXG4gICAgICBjYihlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY29tcHJlc3NlZCA9IChidWZbMF0gJiAweDQwKSA9PT0gMHg0MDtcblxuICAgIGlmIChjb21wcmVzc2VkICYmICF0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXG4gICAgICApO1xuXG4gICAgICBjYihlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZmluID0gKGJ1ZlswXSAmIDB4ODApID09PSAweDgwO1xuICAgIHRoaXMuX29wY29kZSA9IGJ1ZlswXSAmIDB4MGY7XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IGJ1ZlsxXSAmIDB4N2Y7XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAwKSB7XG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2ZyYWdtZW50ZWQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ2ludmFsaWQgb3Bjb2RlIDAnLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfT1BDT0RFJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9vcGNvZGUgPSB0aGlzLl9mcmFnbWVudGVkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAxIHx8IHRoaXMuX29wY29kZSA9PT0gMHgwMikge1xuICAgICAgaWYgKHRoaXMuX2ZyYWdtZW50ZWQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgYGludmFsaWQgb3Bjb2RlICR7dGhpcy5fb3Bjb2RlfWAsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NvbXByZXNzZWQgPSBjb21wcmVzc2VkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID4gMHgwNyAmJiB0aGlzLl9vcGNvZGUgPCAweDBiKSB7XG4gICAgICBpZiAoIXRoaXMuX2Zpbikge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnRklOIG11c3QgYmUgc2V0JyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9FWFBFQ1RFRF9GSU4nXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fcGF5bG9hZExlbmd0aCA+IDB4N2QgfHxcbiAgICAgICAgKHRoaXMuX29wY29kZSA9PT0gMHgwOCAmJiB0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgIGBpbnZhbGlkIHBheWxvYWQgbGVuZ3RoICR7dGhpcy5fcGF5bG9hZExlbmd0aH1gLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfQ09OVFJPTF9QQVlMT0FEX0xFTkdUSCdcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICBgaW52YWxpZCBvcGNvZGUgJHt0aGlzLl9vcGNvZGV9YCxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9JTlZBTElEX09QQ09ERSdcbiAgICAgICk7XG5cbiAgICAgIGNiKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2ZpbiAmJiAhdGhpcy5fZnJhZ21lbnRlZCkgdGhpcy5fZnJhZ21lbnRlZCA9IHRoaXMuX29wY29kZTtcbiAgICB0aGlzLl9tYXNrZWQgPSAoYnVmWzFdICYgMHg4MCkgPT09IDB4ODA7XG5cbiAgICBpZiAodGhpcy5faXNTZXJ2ZXIpIHtcbiAgICAgIGlmICghdGhpcy5fbWFza2VkKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdNQVNLIG11c3QgYmUgc2V0JyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9FWFBFQ1RFRF9NQVNLJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fbWFza2VkKSB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICdNQVNLIG11c3QgYmUgY2xlYXInLFxuICAgICAgICB0cnVlLFxuICAgICAgICAxMDAyLFxuICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfTUFTSydcbiAgICAgICk7XG5cbiAgICAgIGNiKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMTI2KSB0aGlzLl9zdGF0ZSA9IEdFVF9QQVlMT0FEX0xFTkdUSF8xNjtcbiAgICBlbHNlIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxMjcpIHRoaXMuX3N0YXRlID0gR0VUX1BBWUxPQURfTEVOR1RIXzY0O1xuICAgIGVsc2UgdGhpcy5oYXZlTGVuZ3RoKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGV4dGVuZGVkIHBheWxvYWQgbGVuZ3RoICg3KzE2KS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBheWxvYWRMZW5ndGgxNihjYikge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgMikge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSB0aGlzLmNvbnN1bWUoMikucmVhZFVJbnQxNkJFKDApO1xuICAgIHRoaXMuaGF2ZUxlbmd0aChjYik7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aCAoNys2NCkuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXlsb2FkTGVuZ3RoNjQoY2IpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDgpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBidWYgPSB0aGlzLmNvbnN1bWUoOCk7XG4gICAgY29uc3QgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKTtcblxuICAgIC8vXG4gICAgLy8gVGhlIG1heGltdW0gc2FmZSBpbnRlZ2VyIGluIEphdmFTY3JpcHQgaXMgMl41MyAtIDEuIEFuIGVycm9yIGlzIHJldHVybmVkXG4gICAgLy8gaWYgcGF5bG9hZCBsZW5ndGggaXMgZ3JlYXRlciB0aGFuIHRoaXMgbnVtYmVyLlxuICAgIC8vXG4gICAgaWYgKG51bSA+IE1hdGgucG93KDIsIDUzIC0gMzIpIC0gMSkge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnVW5zdXBwb3J0ZWQgV2ViU29ja2V0IGZyYW1lOiBwYXlsb2FkIGxlbmd0aCA+IDJeNTMgLSAxJyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIDEwMDksXG4gICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfREFUQV9QQVlMT0FEX0xFTkdUSCdcbiAgICAgICk7XG5cbiAgICAgIGNiKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gbnVtICogTWF0aC5wb3coMiwgMzIpICsgYnVmLnJlYWRVSW50MzJCRSg0KTtcbiAgICB0aGlzLmhhdmVMZW5ndGgoY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBheWxvYWQgbGVuZ3RoIGhhcyBiZWVuIHJlYWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYXZlTGVuZ3RoKGNiKSB7XG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggJiYgdGhpcy5fb3Bjb2RlIDwgMHgwOCkge1xuICAgICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoICs9IHRoaXMuX3BheWxvYWRMZW5ndGg7XG4gICAgICBpZiAodGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID4gdGhpcy5fbWF4UGF5bG9hZCAmJiB0aGlzLl9tYXhQYXlsb2FkID4gMCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgMTAwOSxcbiAgICAgICAgICAnV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9tYXNrZWQpIHRoaXMuX3N0YXRlID0gR0VUX01BU0s7XG4gICAgZWxzZSB0aGlzLl9zdGF0ZSA9IEdFVF9EQVRBO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIG1hc2sgYnl0ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRNYXNrKCkge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgNCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX21hc2sgPSB0aGlzLmNvbnN1bWUoNCk7XG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfREFUQTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBkYXRhIGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0RGF0YShjYikge1xuICAgIGxldCBkYXRhID0gRU1QVFlfQlVGRkVSO1xuXG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgdGhpcy5fcGF5bG9hZExlbmd0aCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGF0YSA9IHRoaXMuY29uc3VtZSh0aGlzLl9wYXlsb2FkTGVuZ3RoKTtcblxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9tYXNrZWQgJiZcbiAgICAgICAgKHRoaXMuX21hc2tbMF0gfCB0aGlzLl9tYXNrWzFdIHwgdGhpcy5fbWFza1syXSB8IHRoaXMuX21hc2tbM10pICE9PSAwXG4gICAgICApIHtcbiAgICAgICAgdW5tYXNrKGRhdGEsIHRoaXMuX21hc2spO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9vcGNvZGUgPiAweDA3KSB7XG4gICAgICB0aGlzLmNvbnRyb2xNZXNzYWdlKGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY29tcHJlc3NlZCkge1xuICAgICAgdGhpcy5fc3RhdGUgPSBJTkZMQVRJTkc7XG4gICAgICB0aGlzLmRlY29tcHJlc3MoZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCkge1xuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgbWVzc2FnZSBpcyBub3QgY29tcHJlc3NlZCBzbyBpdHMgbGVuZ3RoIGlzIHRoZSBzdW0gb2YgdGhlIHBheWxvYWRcbiAgICAgIC8vIGxlbmd0aCBvZiBhbGwgZnJhZ21lbnRzLlxuICAgICAgLy9cbiAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGg7XG4gICAgICB0aGlzLl9mcmFnbWVudHMucHVzaChkYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGFNZXNzYWdlKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzZXMgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWNvbXByZXNzKGRhdGEsIGNiKSB7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXG4gICAgcGVyTWVzc2FnZURlZmxhdGUuZGVjb21wcmVzcyhkYXRhLCB0aGlzLl9maW4sIChlcnIsIGJ1ZikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAgIGlmIChidWYubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuX21lc3NhZ2VMZW5ndGggPiB0aGlzLl9tYXhQYXlsb2FkICYmIHRoaXMuX21heFBheWxvYWQgPiAwKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAgICdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgMTAwOSxcbiAgICAgICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9mcmFnbWVudHMucHVzaChidWYpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRhdGFNZXNzYWdlKGNiKTtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gR0VUX0lORk8pIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGF0YU1lc3NhZ2UoY2IpIHtcbiAgICBpZiAoIXRoaXMuX2Zpbikge1xuICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtZXNzYWdlTGVuZ3RoID0gdGhpcy5fbWVzc2FnZUxlbmd0aDtcbiAgICBjb25zdCBmcmFnbWVudHMgPSB0aGlzLl9mcmFnbWVudHM7XG5cbiAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMikge1xuICAgICAgbGV0IGRhdGE7XG5cbiAgICAgIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnbm9kZWJ1ZmZlcicpIHtcbiAgICAgICAgZGF0YSA9IGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICAgIGRhdGEgPSB0b0FycmF5QnVmZmVyKGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgQmxvYihmcmFnbWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IGZyYWdtZW50cztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2FsbG93U3luY2hyb25vdXNFdmVudHMpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IERFRkVSX0VWRU5UO1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGRhdGEsIHRydWUpO1xuICAgICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICAgICAgdGhpcy5zdGFydExvb3AoY2IpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYnVmID0gY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XG5cbiAgICAgIGlmICghdGhpcy5fc2tpcFVURjhWYWxpZGF0aW9uICYmICFpc1ZhbGlkVVRGOChidWYpKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBFcnJvcixcbiAgICAgICAgICAnaW52YWxpZCBVVEYtOCBzZXF1ZW5jZScsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDA3LFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9VVEY4J1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc3RhdGUgPT09IElORkxBVElORyB8fCB0aGlzLl9hbGxvd1N5bmNocm9ub3VzRXZlbnRzKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGJ1ZiwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBERUZFUl9FVkVOVDtcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBidWYsIGZhbHNlKTtcbiAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBjb250cm9sIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIERhdGEgdG8gaGFuZGxlXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnRyb2xNZXNzYWdlKGRhdGEsIGNiKSB7XG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwOCkge1xuICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0KCdjb25jbHVkZScsIDEwMDUsIEVNUFRZX0JVRkZFUik7XG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb2RlID0gZGF0YS5yZWFkVUludDE2QkUoMCk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgICBgaW52YWxpZCBzdGF0dXMgY29kZSAke2NvZGV9YCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDAyLFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NMT1NFX0NPREUnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBidWYgPSBuZXcgRmFzdEJ1ZmZlcihcbiAgICAgICAgICBkYXRhLmJ1ZmZlcixcbiAgICAgICAgICBkYXRhLmJ5dGVPZmZzZXQgKyAyLFxuICAgICAgICAgIGRhdGEubGVuZ3RoIC0gMlxuICAgICAgICApO1xuXG4gICAgICAgIGlmICghdGhpcy5fc2tpcFVURjhWYWxpZGF0aW9uICYmICFpc1ZhbGlkVVRGOChidWYpKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgICAgRXJyb3IsXG4gICAgICAgICAgICAnaW52YWxpZCBVVEYtOCBzZXF1ZW5jZScsXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgMTAwNyxcbiAgICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9VVEY4J1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjYihlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXQoJ2NvbmNsdWRlJywgY29kZSwgYnVmKTtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYWxsb3dTeW5jaHJvbm91c0V2ZW50cykge1xuICAgICAgdGhpcy5lbWl0KHRoaXMuX29wY29kZSA9PT0gMHgwOSA/ICdwaW5nJyA6ICdwb25nJywgZGF0YSk7XG4gICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdGF0ZSA9IERFRkVSX0VWRU5UO1xuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuX29wY29kZSA9PT0gMHgwOSA/ICdwaW5nJyA6ICdwb25nJywgZGF0YSk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYW4gZXJyb3Igb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzpFcnJvcnxSYW5nZUVycm9yKX0gRXJyb3JDdG9yIFRoZSBlcnJvciBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZpeCBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gYWRkIGEgZGVmYXVsdCBwcmVmaXggdG9cbiAgICogICAgIGBtZXNzYWdlYFxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhdHVzQ29kZSBUaGUgc3RhdHVzIGNvZGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVycm9yQ29kZSBUaGUgZXhwb3NlZCBlcnJvciBjb2RlXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yKX0gVGhlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjcmVhdGVFcnJvcihFcnJvckN0b3IsIG1lc3NhZ2UsIHByZWZpeCwgc3RhdHVzQ29kZSwgZXJyb3JDb2RlKSB7XG4gICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgIHRoaXMuX2Vycm9yZWQgPSB0cnVlO1xuXG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yQ3RvcihcbiAgICAgIHByZWZpeCA/IGBJbnZhbGlkIFdlYlNvY2tldCBmcmFtZTogJHttZXNzYWdlfWAgOiBtZXNzYWdlXG4gICAgKTtcblxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgdGhpcy5jcmVhdGVFcnJvcik7XG4gICAgZXJyLmNvZGUgPSBlcnJvckNvZGU7XG4gICAgZXJyW2tTdGF0dXNDb2RlXSA9IHN0YXR1c0NvZGU7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY2VpdmVyO1xuIiwgIi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwiXkR1cGxleFwiIH1dICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBEdXBsZXggfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyByYW5kb21GaWxsU3luYyB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IHsgRU1QVFlfQlVGRkVSLCBrV2ViU29ja2V0LCBOT09QIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgeyBpc0Jsb2IsIGlzVmFsaWRTdGF0dXNDb2RlIH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcbmNvbnN0IHsgbWFzazogYXBwbHlNYXNrLCB0b0J1ZmZlciB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuXG5jb25zdCBrQnl0ZUxlbmd0aCA9IFN5bWJvbCgna0J5dGVMZW5ndGgnKTtcbmNvbnN0IG1hc2tCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNCk7XG5jb25zdCBSQU5ET01fUE9PTF9TSVpFID0gOCAqIDEwMjQ7XG5sZXQgcmFuZG9tUG9vbDtcbmxldCByYW5kb21Qb29sUG9pbnRlciA9IFJBTkRPTV9QT09MX1NJWkU7XG5cbmNvbnN0IERFRkFVTFQgPSAwO1xuY29uc3QgREVGTEFUSU5HID0gMTtcbmNvbnN0IEdFVF9CTE9CX0RBVEEgPSAyO1xuXG4vKipcbiAqIEh5QmkgU2VuZGVyIGltcGxlbWVudGF0aW9uLlxuICovXG5jbGFzcyBTZW5kZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFNlbmRlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtEdXBsZXh9IHNvY2tldCBUaGUgY29ubmVjdGlvbiBzb2NrZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtleHRlbnNpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZCBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtnZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZSBtYXNraW5nXG4gICAqICAgICBrZXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvY2tldCwgZXh0ZW5zaW9ucywgZ2VuZXJhdGVNYXNrKSB7XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMgfHwge307XG5cbiAgICBpZiAoZ2VuZXJhdGVNYXNrKSB7XG4gICAgICB0aGlzLl9nZW5lcmF0ZU1hc2sgPSBnZW5lcmF0ZU1hc2s7XG4gICAgICB0aGlzLl9tYXNrQnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgIH1cblxuICAgIHRoaXMuX3NvY2tldCA9IHNvY2tldDtcblxuICAgIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSB0cnVlO1xuICAgIHRoaXMuX2NvbXByZXNzID0gZmFsc2U7XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzID0gMDtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIHRoaXMuX3N0YXRlID0gREVGQVVMVDtcbiAgICB0aGlzLm9uZXJyb3IgPSBOT09QO1xuICAgIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogRnJhbWVzIGEgcGllY2Ugb2YgZGF0YSBhY2NvcmRpbmcgdG8gdGhlIEh5QmkgV2ViU29ja2V0IHByb3RvY29sLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBUaGUgZGF0YSB0byBmcmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIEZJTiBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAgICogICAgIG1hc2tpbmcga2V5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gW29wdGlvbnMubWFza0J1ZmZlcl0gVGhlIGJ1ZmZlciB1c2VkIHRvIHN0b3JlIHRoZSBtYXNraW5nXG4gICAqICAgICBrZXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMub3Bjb2RlIFRoZSBvcGNvZGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWFkT25seT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZVxuICAgKiAgICAgbW9kaWZpZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yc3YxPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgUlNWMSBiaXRcbiAgICogQHJldHVybiB7KEJ1ZmZlcnxTdHJpbmcpW119IFRoZSBmcmFtZWQgZGF0YVxuICAgKiBAcHVibGljXG4gICAqL1xuICBzdGF0aWMgZnJhbWUoZGF0YSwgb3B0aW9ucykge1xuICAgIGxldCBtYXNrO1xuICAgIGxldCBtZXJnZSA9IGZhbHNlO1xuICAgIGxldCBvZmZzZXQgPSAyO1xuICAgIGxldCBza2lwTWFza2luZyA9IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMubWFzaykge1xuICAgICAgbWFzayA9IG9wdGlvbnMubWFza0J1ZmZlciB8fCBtYXNrQnVmZmVyO1xuXG4gICAgICBpZiAob3B0aW9ucy5nZW5lcmF0ZU1hc2spIHtcbiAgICAgICAgb3B0aW9ucy5nZW5lcmF0ZU1hc2sobWFzayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmFuZG9tUG9vbFBvaW50ZXIgPT09IFJBTkRPTV9QT09MX1NJWkUpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi9cbiAgICAgICAgICBpZiAocmFuZG9tUG9vbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBsYXppbHkgaW5pdGlhbGl6ZWQgYmVjYXVzZSBzZXJ2ZXItc2VudCBmcmFtZXMgbXVzdCBub3RcbiAgICAgICAgICAgIC8vIGJlIG1hc2tlZCBzbyBpdCBtYXkgbmV2ZXIgYmUgdXNlZC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICByYW5kb21Qb29sID0gQnVmZmVyLmFsbG9jKFJBTkRPTV9QT09MX1NJWkUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJhbmRvbUZpbGxTeW5jKHJhbmRvbVBvb2wsIDAsIFJBTkRPTV9QT09MX1NJWkUpO1xuICAgICAgICAgIHJhbmRvbVBvb2xQb2ludGVyID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hc2tbMF0gPSByYW5kb21Qb29sW3JhbmRvbVBvb2xQb2ludGVyKytdO1xuICAgICAgICBtYXNrWzFdID0gcmFuZG9tUG9vbFtyYW5kb21Qb29sUG9pbnRlcisrXTtcbiAgICAgICAgbWFza1syXSA9IHJhbmRvbVBvb2xbcmFuZG9tUG9vbFBvaW50ZXIrK107XG4gICAgICAgIG1hc2tbM10gPSByYW5kb21Qb29sW3JhbmRvbVBvb2xQb2ludGVyKytdO1xuICAgICAgfVxuXG4gICAgICBza2lwTWFza2luZyA9IChtYXNrWzBdIHwgbWFza1sxXSB8IG1hc2tbMl0gfCBtYXNrWzNdKSA9PT0gMDtcbiAgICAgIG9mZnNldCA9IDY7XG4gICAgfVxuXG4gICAgbGV0IGRhdGFMZW5ndGg7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoXG4gICAgICAgICghb3B0aW9ucy5tYXNrIHx8IHNraXBNYXNraW5nKSAmJlxuICAgICAgICBvcHRpb25zW2tCeXRlTGVuZ3RoXSAhPT0gdW5kZWZpbmVkXG4gICAgICApIHtcbiAgICAgICAgZGF0YUxlbmd0aCA9IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIG1lcmdlID0gb3B0aW9ucy5tYXNrICYmIG9wdGlvbnMucmVhZE9ubHkgJiYgIXNraXBNYXNraW5nO1xuICAgIH1cblxuICAgIGxldCBwYXlsb2FkTGVuZ3RoID0gZGF0YUxlbmd0aDtcblxuICAgIGlmIChkYXRhTGVuZ3RoID49IDY1NTM2KSB7XG4gICAgICBvZmZzZXQgKz0gODtcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjc7XG4gICAgfSBlbHNlIGlmIChkYXRhTGVuZ3RoID4gMTI1KSB7XG4gICAgICBvZmZzZXQgKz0gMjtcbiAgICAgIHBheWxvYWRMZW5ndGggPSAxMjY7XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG1lcmdlID8gZGF0YUxlbmd0aCArIG9mZnNldCA6IG9mZnNldCk7XG5cbiAgICB0YXJnZXRbMF0gPSBvcHRpb25zLmZpbiA/IG9wdGlvbnMub3Bjb2RlIHwgMHg4MCA6IG9wdGlvbnMub3Bjb2RlO1xuICAgIGlmIChvcHRpb25zLnJzdjEpIHRhcmdldFswXSB8PSAweDQwO1xuXG4gICAgdGFyZ2V0WzFdID0gcGF5bG9hZExlbmd0aDtcblxuICAgIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjYpIHtcbiAgICAgIHRhcmdldC53cml0ZVVJbnQxNkJFKGRhdGFMZW5ndGgsIDIpO1xuICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI3KSB7XG4gICAgICB0YXJnZXRbMl0gPSB0YXJnZXRbM10gPSAwO1xuICAgICAgdGFyZ2V0LndyaXRlVUludEJFKGRhdGFMZW5ndGgsIDQsIDYpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5tYXNrKSByZXR1cm4gW3RhcmdldCwgZGF0YV07XG5cbiAgICB0YXJnZXRbMV0gfD0gMHg4MDtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gNF0gPSBtYXNrWzBdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAzXSA9IG1hc2tbMV07XG4gICAgdGFyZ2V0W29mZnNldCAtIDJdID0gbWFza1syXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gMV0gPSBtYXNrWzNdO1xuXG4gICAgaWYgKHNraXBNYXNraW5nKSByZXR1cm4gW3RhcmdldCwgZGF0YV07XG5cbiAgICBpZiAobWVyZ2UpIHtcbiAgICAgIGFwcGx5TWFzayhkYXRhLCBtYXNrLCB0YXJnZXQsIG9mZnNldCwgZGF0YUxlbmd0aCk7XG4gICAgICByZXR1cm4gW3RhcmdldF07XG4gICAgfVxuXG4gICAgYXBwbHlNYXNrKGRhdGEsIG1hc2ssIGRhdGEsIDAsIGRhdGFMZW5ndGgpO1xuICAgIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGNsb3NlIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29kZV0gVGhlIHN0YXR1cyBjb2RlIGNvbXBvbmVudCBvZiB0aGUgYm9keVxuICAgKiBAcGFyYW0geyhTdHJpbmd8QnVmZmVyKX0gW2RhdGFdIFRoZSBtZXNzYWdlIGNvbXBvbmVudCBvZiB0aGUgYm9keVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayB0aGUgbWVzc2FnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNvZGUsIGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgbGV0IGJ1ZjtcblxuICAgIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGJ1ZiA9IEVNUFRZX0JVRkZFUjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2RlICE9PSAnbnVtYmVyJyB8fCAhaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSB2YWxpZCBlcnJvciBjb2RlIG51bWJlcicpO1xuICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkIHx8ICFkYXRhLmxlbmd0aCkge1xuICAgICAgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpO1xuICAgICAgYnVmLndyaXRlVUludDE2QkUoY29kZSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuXG4gICAgICBpZiAobGVuZ3RoID4gMTIzKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgbWVzc2FnZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTIzIGJ5dGVzJyk7XG4gICAgICB9XG5cbiAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyICsgbGVuZ3RoKTtcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDApO1xuXG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJ1Zi53cml0ZShkYXRhLCAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1Zi5zZXQoZGF0YSwgMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ1Zi5sZW5ndGgsXG4gICAgICBmaW46IHRydWUsXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgIG1hc2ssXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgb3Bjb2RlOiAweDA4LFxuICAgICAgcmVhZE9ubHk6IGZhbHNlLFxuICAgICAgcnN2MTogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGJ1ZiwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShidWYsIG9wdGlvbnMpLCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcGluZyBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBwaW5nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgbGV0IGJ5dGVMZW5ndGg7XG4gICAgbGV0IHJlYWRPbmx5O1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEuc2l6ZTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XG4gICAgfVxuXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAxMjUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgW2tCeXRlTGVuZ3RoXTogYnl0ZUxlbmd0aCxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgbWFzayxcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICBvcGNvZGU6IDB4MDksXG4gICAgICByZWFkT25seSxcbiAgICAgIHJzdjE6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xuICAgICAgICB0aGlzLmVucXVldWUoW3RoaXMuZ2V0QmxvYkRhdGEsIGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5nZXRCbG9iRGF0YShkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2IpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHBvbmcgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcG9uZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGxldCBieXRlTGVuZ3RoO1xuICAgIGxldCByZWFkT25seTtcblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLnNpemU7XG4gICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gdG9CdWZmZXIoZGF0YSk7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICByZWFkT25seSA9IHRvQnVmZmVyLnJlYWRPbmx5O1xuICAgIH1cblxuICAgIGlmIChieXRlTGVuZ3RoID4gMTI1KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIGRhdGEgc2l6ZSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMTI1IGJ5dGVzJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXG4gICAgICBmaW46IHRydWUsXG4gICAgICBnZW5lcmF0ZU1hc2s6IHRoaXMuX2dlbmVyYXRlTWFzayxcbiAgICAgIG1hc2ssXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgb3Bjb2RlOiAweDBhLFxuICAgICAgcmVhZE9ubHksXG4gICAgICByc3YxOiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAoaXNCbG9iKGRhdGEpKSB7XG4gICAgICBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmdldEJsb2JEYXRhLCBkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZ2V0QmxvYkRhdGEoZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBkYXRhIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmluYXJ5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5XG4gICAqICAgICBvciB0ZXh0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29tcHJlc3M9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICAgKiAgICAgY29tcHJlc3MgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZnJhZ21lbnQgaXMgdGhlXG4gICAqICAgICBsYXN0IG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuICAgIGxldCBvcGNvZGUgPSBvcHRpb25zLmJpbmFyeSA/IDIgOiAxO1xuICAgIGxldCByc3YxID0gb3B0aW9ucy5jb21wcmVzcztcblxuICAgIGxldCBieXRlTGVuZ3RoO1xuICAgIGxldCByZWFkT25seTtcblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLnNpemU7XG4gICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gdG9CdWZmZXIoZGF0YSk7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICByZWFkT25seSA9IHRvQnVmZmVyLnJlYWRPbmx5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9maXJzdEZyYWdtZW50KSB7XG4gICAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gZmFsc2U7XG4gICAgICBpZiAoXG4gICAgICAgIHJzdjEgJiZcbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUgJiZcbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUucGFyYW1zW1xuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLl9pc1NlcnZlclxuICAgICAgICAgICAgPyAnc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXInXG4gICAgICAgICAgICA6ICdjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlcidcbiAgICAgICAgXVxuICAgICAgKSB7XG4gICAgICAgIHJzdjEgPSBieXRlTGVuZ3RoID49IHBlck1lc3NhZ2VEZWZsYXRlLl90aHJlc2hvbGQ7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb21wcmVzcyA9IHJzdjE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJzdjEgPSBmYWxzZTtcbiAgICAgIG9wY29kZSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZmluKSB0aGlzLl9maXJzdEZyYWdtZW50ID0gdHJ1ZTtcblxuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBba0J5dGVMZW5ndGhdOiBieXRlTGVuZ3RoLFxuICAgICAgZmluOiBvcHRpb25zLmZpbixcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgbWFzazogb3B0aW9ucy5tYXNrLFxuICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcbiAgICAgIG9wY29kZSxcbiAgICAgIHJlYWRPbmx5LFxuICAgICAgcnN2MVxuICAgIH07XG5cbiAgICBpZiAoaXNCbG9iKGRhdGEpKSB7XG4gICAgICBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmdldEJsb2JEYXRhLCBkYXRhLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2JdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZ2V0QmxvYkRhdGEoZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpc3BhdGNoKGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGNvbnRlbnRzIG9mIGEgYmxvYiBhcyBiaW5hcnkgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCbG9ifSBibG9iIFRoZSBibG9iXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbXByZXNzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcbiAgICogICAgIHRoZSBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgRklOIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICAgKiAgICAgbWFza2luZyBrZXlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBbb3B0aW9ucy5tYXNrQnVmZmVyXSBUaGUgYnVmZmVyIHVzZWQgdG8gc3RvcmUgdGhlIG1hc2tpbmdcbiAgICogICAgIGtleVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlXG4gICAqICAgICBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJzdjE9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBSU1YxIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRCbG9iRGF0YShibG9iLCBjb21wcmVzcywgb3B0aW9ucywgY2IpIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgIHRoaXMuX3N0YXRlID0gR0VUX0JMT0JfREFUQTtcblxuICAgIGJsb2JcbiAgICAgIC5hcnJheUJ1ZmZlcigpXG4gICAgICAudGhlbigoYXJyYXlCdWZmZXIpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3NvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnVGhlIHNvY2tldCB3YXMgY2xvc2VkIHdoaWxlIHRoZSBibG9iIHdhcyBiZWluZyByZWFkJ1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIGBjYWxsQ2FsbGJhY2tzYCBpcyBjYWxsZWQgaW4gdGhlIG5leHQgdGljayB0byBlbnN1cmUgdGhhdCBlcnJvcnNcbiAgICAgICAgICAvLyB0aGF0IG1pZ2h0IGJlIHRocm93biBpbiB0aGUgY2FsbGJhY2tzIGJlaGF2ZSBsaWtlIGVycm9ycyB0aHJvd25cbiAgICAgICAgICAvLyBvdXRzaWRlIHRoZSBwcm9taXNlIGNoYWluLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsQ2FsbGJhY2tzLCB0aGlzLCBlcnIsIGNiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgICAgICBjb25zdCBkYXRhID0gdG9CdWZmZXIoYXJyYXlCdWZmZXIpO1xuXG4gICAgICAgIGlmICghY29tcHJlc3MpIHtcbiAgICAgICAgICB0aGlzLl9zdGF0ZSA9IERFRkFVTFQ7XG4gICAgICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XG4gICAgICAgICAgdGhpcy5kZXF1ZXVlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaChkYXRhLCBjb21wcmVzcywgb3B0aW9ucywgY2IpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gYG9uRXJyb3JgIGlzIGNhbGxlZCBpbiB0aGUgbmV4dCB0aWNrIGZvciB0aGUgc2FtZSByZWFzb24gdGhhdFxuICAgICAgICAvLyBgY2FsbENhbGxiYWNrc2AgYWJvdmUgaXMuXG4gICAgICAgIC8vXG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2sob25FcnJvciwgdGhpcywgZXJyLCBjYik7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb21wcmVzcz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBGSU4gYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gICAqICAgICBtYXNraW5nIGtleVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtvcHRpb25zLm1hc2tCdWZmZXJdIFRoZSBidWZmZXIgdXNlZCB0byBzdG9yZSB0aGUgbWFza2luZ1xuICAgKiAgICAga2V5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVhZE9ubHk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmVcbiAgICogICAgIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnN2MT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIFJTVjEgYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRpc3BhdGNoKGRhdGEsIGNvbXByZXNzLCBvcHRpb25zLCBjYikge1xuICAgIGlmICghY29tcHJlc3MpIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgdGhpcy5fc3RhdGUgPSBERUZMQVRJTkc7XG4gICAgcGVyTWVzc2FnZURlZmxhdGUuY29tcHJlc3MoZGF0YSwgb3B0aW9ucy5maW4sIChfLCBidWYpID0+IHtcbiAgICAgIGlmICh0aGlzLl9zb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAnVGhlIHNvY2tldCB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIGNvbXByZXNzZWQnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2FsbENhbGxiYWNrcyh0aGlzLCBlcnIsIGNiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG9wdGlvbnNba0J5dGVMZW5ndGhdO1xuICAgICAgdGhpcy5fc3RhdGUgPSBERUZBVUxUO1xuICAgICAgb3B0aW9ucy5yZWFkT25seSA9IGZhbHNlO1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGJ1Ziwgb3B0aW9ucyksIGNiKTtcbiAgICAgIHRoaXMuZGVxdWV1ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHF1ZXVlZCBzZW5kIG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXF1ZXVlKCkge1xuICAgIHdoaWxlICh0aGlzLl9zdGF0ZSA9PT0gREVGQVVMVCAmJiB0aGlzLl9xdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gcGFyYW1zWzNdW2tCeXRlTGVuZ3RoXTtcbiAgICAgIFJlZmxlY3QuYXBwbHkocGFyYW1zWzBdLCB0aGlzLCBwYXJhbXMuc2xpY2UoMSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIHNlbmQgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgU2VuZCBvcGVyYXRpb24gcGFyYW1ldGVycy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVucXVldWUocGFyYW1zKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBwYXJhbXNbM11ba0J5dGVMZW5ndGhdO1xuICAgIHRoaXMuX3F1ZXVlLnB1c2gocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGZyYW1lLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXIgfCBTdHJpbmcpW119IGxpc3QgVGhlIGZyYW1lIHRvIHNlbmRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2VuZEZyYW1lKGxpc3QsIGNiKSB7XG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAyKSB7XG4gICAgICB0aGlzLl9zb2NrZXQuY29yaygpO1xuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMF0pO1xuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMV0sIGNiKTtcbiAgICAgIHRoaXMuX3NvY2tldC51bmNvcmsoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGxpc3RbMF0sIGNiKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZW5kZXI7XG5cbi8qKlxuICogQ2FsbHMgcXVldWVkIGNhbGxiYWNrcyB3aXRoIGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7U2VuZGVyfSBzZW5kZXIgVGhlIGBTZW5kZXJgIGluc3RhbmNlXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVycm9yIHRvIGNhbGwgdGhlIGNhbGxiYWNrcyB3aXRoXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIFRoZSBmaXJzdCBjYWxsYmFja1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2FsbENhbGxiYWNrcyhzZW5kZXIsIGVyciwgY2IpIHtcbiAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykgY2IoZXJyKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbmRlci5fcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzZW5kZXIuX3F1ZXVlW2ldO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gcGFyYW1zW3BhcmFtcy5sZW5ndGggLSAxXTtcblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrKGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGVzIGEgYFNlbmRlcmAgZXJyb3IuXG4gKlxuICogQHBhcmFtIHtTZW5kZXJ9IHNlbmRlciBUaGUgYFNlbmRlcmAgaW5zdGFuY2VcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZXJyb3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gVGhlIGZpcnN0IHBlbmRpbmcgY2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG9uRXJyb3Ioc2VuZGVyLCBlcnIsIGNiKSB7XG4gIGNhbGxDYWxsYmFja3Moc2VuZGVyLCBlcnIsIGNiKTtcbiAgc2VuZGVyLm9uZXJyb3IoZXJyKTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsga0Zvck9uRXZlbnRBdHRyaWJ1dGUsIGtMaXN0ZW5lciB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3Qga0NvZGUgPSBTeW1ib2woJ2tDb2RlJyk7XG5jb25zdCBrRGF0YSA9IFN5bWJvbCgna0RhdGEnKTtcbmNvbnN0IGtFcnJvciA9IFN5bWJvbCgna0Vycm9yJyk7XG5jb25zdCBrTWVzc2FnZSA9IFN5bWJvbCgna01lc3NhZ2UnKTtcbmNvbnN0IGtSZWFzb24gPSBTeW1ib2woJ2tSZWFzb24nKTtcbmNvbnN0IGtUYXJnZXQgPSBTeW1ib2woJ2tUYXJnZXQnKTtcbmNvbnN0IGtUeXBlID0gU3ltYm9sKCdrVHlwZScpO1xuY29uc3Qga1dhc0NsZWFuID0gU3ltYm9sKCdrV2FzQ2xlYW4nKTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXZlbnQuXG4gKi9cbmNsYXNzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0aGUgYHR5cGVgIGFyZ3VtZW50IGlzIG5vdCBzcGVjaWZpZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICB0aGlzW2tUYXJnZXRdID0gbnVsbDtcbiAgICB0aGlzW2tUeXBlXSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUgeyp9XG4gICAqL1xuICBnZXQgdGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzW2tUYXJnZXRdO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpc1trVHlwZV07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgJ3RhcmdldCcsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsICd0eXBlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGNsb3NlIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKi9cbmNsYXNzIENsb3NlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYENsb3NlRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb2RlPTBdIFRoZSBzdGF0dXMgY29kZSBleHBsYWluaW5nIHdoeSB0aGVcbiAgICogICAgIGNvbm5lY3Rpb24gd2FzIGNsb3NlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmVhc29uPScnXSBBIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBleHBsYWluaW5nIHdoeVxuICAgKiAgICAgdGhlIGNvbm5lY3Rpb24gd2FzIGNsb3NlZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndhc0NsZWFuPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlXG4gICAqICAgICBjb25uZWN0aW9uIHdhcyBjbGVhbmx5IGNsb3NlZFxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIodHlwZSk7XG5cbiAgICB0aGlzW2tDb2RlXSA9IG9wdGlvbnMuY29kZSA9PT0gdW5kZWZpbmVkID8gMCA6IG9wdGlvbnMuY29kZTtcbiAgICB0aGlzW2tSZWFzb25dID0gb3B0aW9ucy5yZWFzb24gPT09IHVuZGVmaW5lZCA/ICcnIDogb3B0aW9ucy5yZWFzb247XG4gICAgdGhpc1trV2FzQ2xlYW5dID0gb3B0aW9ucy53YXNDbGVhbiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvcHRpb25zLndhc0NsZWFuO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgY29kZSgpIHtcbiAgICByZXR1cm4gdGhpc1trQ29kZV07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCByZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXNba1JlYXNvbl07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgd2FzQ2xlYW4oKSB7XG4gICAgcmV0dXJuIHRoaXNba1dhc0NsZWFuXTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICdjb2RlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCAncmVhc29uJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCAnd2FzQ2xlYW4nLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGVycm9yIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKi9cbmNsYXNzIEVycm9yRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYEVycm9yRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMuZXJyb3I9bnVsbF0gVGhlIGVycm9yIHRoYXQgZ2VuZXJhdGVkIHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2U9JyddIFRoZSBlcnJvciBtZXNzYWdlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIHRoaXNba0Vycm9yXSA9IG9wdGlvbnMuZXJyb3IgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLmVycm9yO1xuICAgIHRoaXNba01lc3NhZ2VdID0gb3B0aW9ucy5tZXNzYWdlID09PSB1bmRlZmluZWQgPyAnJyA6IG9wdGlvbnMubWVzc2FnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Kn1cbiAgICovXG4gIGdldCBlcnJvcigpIHtcbiAgICByZXR1cm4gdGhpc1trRXJyb3JdO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgbWVzc2FnZSgpIHtcbiAgICByZXR1cm4gdGhpc1trTWVzc2FnZV07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEVycm9yRXZlbnQucHJvdG90eXBlLCAnZXJyb3InLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXJyb3JFdmVudC5wcm90b3R5cGUsICdtZXNzYWdlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIG1lc3NhZ2UgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqL1xuY2xhc3MgTWVzc2FnZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBNZXNzYWdlRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMuZGF0YT1udWxsXSBUaGUgbWVzc2FnZSBjb250ZW50XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIHRoaXNba0RhdGFdID0gb3B0aW9ucy5kYXRhID09PSB1bmRlZmluZWQgPyBudWxsIDogb3B0aW9ucy5kYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHsqfVxuICAgKi9cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXNba0RhdGFdO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZXNzYWdlRXZlbnQucHJvdG90eXBlLCAnZGF0YScsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBUaGlzIHByb3ZpZGVzIG1ldGhvZHMgZm9yIGVtdWxhdGluZyB0aGUgYEV2ZW50VGFyZ2V0YCBpbnRlcmZhY2UuIEl0J3Mgbm90XG4gKiBtZWFudCB0byBiZSB1c2VkIGRpcmVjdGx5LlxuICpcbiAqIEBtaXhpblxuICovXG5jb25zdCBFdmVudFRhcmdldCA9IHtcbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvclxuICAgKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBoYW5kbGVyIFRoZSBsaXN0ZW5lciB0byBhZGRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvcHRpb25zIG9iamVjdCBzcGVjaWZpZXMgY2hhcmFjdGVyaXN0aWNzIGFib3V0XG4gICAqICAgICB0aGUgZXZlbnQgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vbmNlPWZhbHNlXSBBIGBCb29sZWFuYCBpbmRpY2F0aW5nIHRoYXQgdGhlXG4gICAqICAgICBsaXN0ZW5lciBzaG91bGQgYmUgaW52b2tlZCBhdCBtb3N0IG9uY2UgYWZ0ZXIgYmVpbmcgYWRkZWQuIElmIGB0cnVlYCxcbiAgICogICAgIHRoZSBsaXN0ZW5lciB3b3VsZCBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgd2hlbiBpbnZva2VkLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnModHlwZSkpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIW9wdGlvbnNba0Zvck9uRXZlbnRBdHRyaWJ1dGVdICYmXG4gICAgICAgIGxpc3RlbmVyW2tMaXN0ZW5lcl0gPT09IGhhbmRsZXIgJiZcbiAgICAgICAgIWxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgd3JhcHBlcjtcblxuICAgIGlmICh0eXBlID09PSAnbWVzc2FnZScpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbk1lc3NhZ2UoZGF0YSwgaXNCaW5hcnkpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgTWVzc2FnZUV2ZW50KCdtZXNzYWdlJywge1xuICAgICAgICAgIGRhdGE6IGlzQmluYXJ5ID8gZGF0YSA6IGRhdGEudG9TdHJpbmcoKVxuICAgICAgICB9KTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Nsb3NlJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uQ2xvc2UoY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDbG9zZUV2ZW50KCdjbG9zZScsIHtcbiAgICAgICAgICBjb2RlLFxuICAgICAgICAgIHJlYXNvbjogbWVzc2FnZS50b1N0cmluZygpLFxuICAgICAgICAgIHdhc0NsZWFuOiB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgJiYgdGhpcy5fY2xvc2VGcmFtZVNlbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEVycm9yRXZlbnQoJ2Vycm9yJywge1xuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGVuJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uT3BlbigpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ29wZW4nKTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd3JhcHBlcltrRm9yT25FdmVudEF0dHJpYnV0ZV0gPSAhIW9wdGlvbnNba0Zvck9uRXZlbnRBdHRyaWJ1dGVdO1xuICAgIHdyYXBwZXJba0xpc3RlbmVyXSA9IGhhbmRsZXI7XG5cbiAgICBpZiAob3B0aW9ucy5vbmNlKSB7XG4gICAgICB0aGlzLm9uY2UodHlwZSwgd3JhcHBlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub24odHlwZSwgd3JhcHBlcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byByZW1vdmVcbiAgICogQHBhcmFtIHsoRnVuY3Rpb258T2JqZWN0KX0gaGFuZGxlciBUaGUgbGlzdGVuZXIgdG8gcmVtb3ZlXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcikge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnModHlwZSkpIHtcbiAgICAgIGlmIChsaXN0ZW5lcltrTGlzdGVuZXJdID09PSBoYW5kbGVyICYmICFsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENsb3NlRXZlbnQsXG4gIEVycm9yRXZlbnQsXG4gIEV2ZW50LFxuICBFdmVudFRhcmdldCxcbiAgTWVzc2FnZUV2ZW50XG59O1xuXG4vKipcbiAqIENhbGwgYW4gZXZlbnQgbGlzdGVuZXJcbiAqXG4gKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gY2FsbFxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSB2YWx1ZSB0byB1c2UgYXMgYHRoaXNgYCB3aGVuIGNhbGxpbmcgdGhlIGxpc3RlbmVyXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gcGFzcyB0byB0aGUgbGlzdGVuZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNhbGxMaXN0ZW5lcihsaXN0ZW5lciwgdGhpc0FyZywgZXZlbnQpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ29iamVjdCcgJiYgbGlzdGVuZXIuaGFuZGxlRXZlbnQpIHtcbiAgICBsaXN0ZW5lci5oYW5kbGVFdmVudC5jYWxsKGxpc3RlbmVyLCBldmVudCk7XG4gIH0gZWxzZSB7XG4gICAgbGlzdGVuZXIuY2FsbCh0aGlzQXJnLCBldmVudCk7XG4gIH1cbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgdG9rZW5DaGFycyB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbi8qKlxuICogQWRkcyBhbiBvZmZlciB0byB0aGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgYSBwYXJhbWV0ZXIgdG8gdGhlIG1hcCBvZlxuICogcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdCBUaGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGV4dGVuc2lvbiBvciBwYXJhbWV0ZXIgbmFtZVxuICogQHBhcmFtIHsoT2JqZWN0fEJvb2xlYW58U3RyaW5nKX0gZWxlbSBUaGUgZXh0ZW5zaW9uIHBhcmFtZXRlcnMgb3IgdGhlXG4gKiAgICAgcGFyYW1ldGVyIHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdXNoKGRlc3QsIG5hbWUsIGVsZW0pIHtcbiAgaWYgKGRlc3RbbmFtZV0gPT09IHVuZGVmaW5lZCkgZGVzdFtuYW1lXSA9IFtlbGVtXTtcbiAgZWxzZSBkZXN0W25hbWVdLnB1c2goZWxlbSk7XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSBgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zYCBoZWFkZXIgaW50byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciBUaGUgZmllbGQgdmFsdWUgb2YgdGhlIGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcGFyc2VkIG9iamVjdFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBwYXJzZShoZWFkZXIpIHtcbiAgY29uc3Qgb2ZmZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgbGV0IGlzRXNjYXBpbmcgPSBmYWxzZTtcbiAgbGV0IGluUXVvdGVzID0gZmFsc2U7XG4gIGxldCBleHRlbnNpb25OYW1lO1xuICBsZXQgcGFyYW1OYW1lO1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGNvZGUgPSAtMTtcbiAgbGV0IGVuZCA9IC0xO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoZXh0ZW5zaW9uTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGkgIT09IDAgJiZcbiAgICAgICAgKGNvZGUgPT09IDB4MjAgLyogJyAnICovIHx8IGNvZGUgPT09IDB4MDkpIC8qICdcXHQnICovXG4gICAgICApIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIC8qICc7JyAqLyB8fCBjb2RlID09PSAweDJjIC8qICcsJyAqLykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgbmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFyYW1OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIHB1c2gocGFyYW1zLCBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCksIHRydWUpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2QgLyogJz0nICovICYmIHN0YXJ0ICE9PSAtMSAmJiBlbmQgPT09IC0xKSB7XG4gICAgICAgIHBhcmFtTmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgaSk7XG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy9cbiAgICAgIC8vIFRoZSB2YWx1ZSBvZiBhIHF1b3RlZC1zdHJpbmcgYWZ0ZXIgdW5lc2NhcGluZyBtdXN0IGNvbmZvcm0gdG8gdGhlXG4gICAgICAvLyB0b2tlbiBBQk5GLCBzbyBvbmx5IHRva2VuIGNoYXJhY3RlcnMgYXJlIHZhbGlkLlxuICAgICAgLy8gUmVmOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTkuMVxuICAgICAgLy9cbiAgICAgIGlmIChpc0VzY2FwaW5nKSB7XG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgICBlbHNlIGlmICghbXVzdFVuZXNjYXBlKSBtdXN0VW5lc2NhcGUgPSB0cnVlO1xuICAgICAgICBpc0VzY2FwaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGluUXVvdGVzKSB7XG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgLyogJ1wiJyAqLyAmJiBzdGFydCAhPT0gLTEpIHtcbiAgICAgICAgICBpblF1b3RlcyA9IGZhbHNlO1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg1YyAvKiAnXFwnICovKSB7XG4gICAgICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMiAmJiBoZWFkZXIuY2hhckNvZGVBdChpIC0gMSkgPT09IDB4M2QpIHtcbiAgICAgICAgaW5RdW90ZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCAhPT0gLTEgJiYgKGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2IgfHwgY29kZSA9PT0gMHgyYykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgbGV0IHZhbHVlID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICAgICAgICBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB2YWx1ZSk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBpblF1b3RlcyB8fCBjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgY29uc3QgdG9rZW4gPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIGlmIChleHRlbnNpb25OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICBwdXNoKG9mZmVycywgdG9rZW4sIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwdXNoKHBhcmFtcywgdG9rZW4sIHRydWUpO1xuICAgIH0gZWxzZSBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbi5yZXBsYWNlKC9cXFxcL2csICcnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHRva2VuKTtcbiAgICB9XG4gICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gIH1cblxuICByZXR1cm4gb2ZmZXJzO1xufVxuXG4vKipcbiAqIEJ1aWxkcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGZpZWxkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBtYXAgb2YgZXh0ZW5zaW9ucyBhbmQgcGFyYW1ldGVycyB0byBmb3JtYXRcbiAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBvYmplY3RcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZm9ybWF0KGV4dGVuc2lvbnMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpXG4gICAgLm1hcCgoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICBsZXQgY29uZmlndXJhdGlvbnMgPSBleHRlbnNpb25zW2V4dGVuc2lvbl07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29uZmlndXJhdGlvbnMpKSBjb25maWd1cmF0aW9ucyA9IFtjb25maWd1cmF0aW9uc107XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbnNcbiAgICAgICAgLm1hcCgocGFyYW1zKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFtleHRlbnNpb25dXG4gICAgICAgICAgICAuY29uY2F0KFxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLm1hcCgoaykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBwYXJhbXNba107XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHZhbHVlcyA9IFt2YWx1ZXNdO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgIC5tYXAoKHYpID0+ICh2ID09PSB0cnVlID8gayA6IGAke2t9PSR7dn1gKSlcbiAgICAgICAgICAgICAgICAgIC5qb2luKCc7ICcpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmpvaW4oJzsgJyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKCcsICcpO1xuICAgIH0pXG4gICAgLmpvaW4oJywgJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBmb3JtYXQsIHBhcnNlIH07XG4iLCAiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJeRHVwbGV4fFJlYWRhYmxlJFwiLCBcImNhdWdodEVycm9yc1wiOiBcIm5vbmVcIiB9XSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IG5ldCA9IHJlcXVpcmUoJ25ldCcpO1xuY29uc3QgdGxzID0gcmVxdWlyZSgndGxzJyk7XG5jb25zdCB7IHJhbmRvbUJ5dGVzLCBjcmVhdGVIYXNoIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IHsgRHVwbGV4LCBSZWFkYWJsZSB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB7IFVSTCB9ID0gcmVxdWlyZSgndXJsJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IFJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlcicpO1xuY29uc3QgU2VuZGVyID0gcmVxdWlyZSgnLi9zZW5kZXInKTtcbmNvbnN0IHsgaXNCbG9iIH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcblxuY29uc3Qge1xuICBCSU5BUllfVFlQRVMsXG4gIENMT1NFX1RJTUVPVVQsXG4gIEVNUFRZX0JVRkZFUixcbiAgR1VJRCxcbiAga0Zvck9uRXZlbnRBdHRyaWJ1dGUsXG4gIGtMaXN0ZW5lcixcbiAga1N0YXR1c0NvZGUsXG4gIGtXZWJTb2NrZXQsXG4gIE5PT1Bcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3Qge1xuICBFdmVudFRhcmdldDogeyBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyIH1cbn0gPSByZXF1aXJlKCcuL2V2ZW50LXRhcmdldCcpO1xuY29uc3QgeyBmb3JtYXQsIHBhcnNlIH0gPSByZXF1aXJlKCcuL2V4dGVuc2lvbicpO1xuY29uc3QgeyB0b0J1ZmZlciB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuXG5jb25zdCBrQWJvcnRlZCA9IFN5bWJvbCgna0Fib3J0ZWQnKTtcbmNvbnN0IHByb3RvY29sVmVyc2lvbnMgPSBbOCwgMTNdO1xuY29uc3QgcmVhZHlTdGF0ZXMgPSBbJ0NPTk5FQ1RJTkcnLCAnT1BFTicsICdDTE9TSU5HJywgJ0NMT1NFRCddO1xuY29uc3Qgc3VicHJvdG9jb2xSZWdleCA9IC9eWyEjJCUmJyorXFwtLjAtOUEtWl5fYHxhLXp+XSskLztcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBXZWJTb2NrZXQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFdlYlNvY2tldCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYFdlYlNvY2tldGAuXG4gICAqXG4gICAqIEBwYXJhbSB7KFN0cmluZ3xVUkwpfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxuICAgKiBAcGFyYW0geyhTdHJpbmd8U3RyaW5nW10pfSBbcHJvdG9jb2xzXSBUaGUgc3VicHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29ubmVjdGlvbiBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IEJJTkFSWV9UWVBFU1swXTtcbiAgICB0aGlzLl9jbG9zZUNvZGUgPSAxMDA2O1xuICAgIHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ID0gZmFsc2U7XG4gICAgdGhpcy5fY2xvc2VNZXNzYWdlID0gRU1QVFlfQlVGRkVSO1xuICAgIHRoaXMuX2Nsb3NlVGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2Vycm9yRW1pdHRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSB7fTtcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wcm90b2NvbCA9ICcnO1xuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ09OTkVDVElORztcbiAgICB0aGlzLl9yZWNlaXZlciA9IG51bGw7XG4gICAgdGhpcy5fc2VuZGVyID0gbnVsbDtcbiAgICB0aGlzLl9zb2NrZXQgPSBudWxsO1xuXG4gICAgaWYgKGFkZHJlc3MgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2J1ZmZlcmVkQW1vdW50ID0gMDtcbiAgICAgIHRoaXMuX2lzU2VydmVyID0gZmFsc2U7XG4gICAgICB0aGlzLl9yZWRpcmVjdHMgPSAwO1xuXG4gICAgICBpZiAocHJvdG9jb2xzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvdG9jb2xzID0gW107XG4gICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHByb3RvY29scykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm90b2NvbHMgPT09ICdvYmplY3QnICYmIHByb3RvY29scyAhPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMgPSBwcm90b2NvbHM7XG4gICAgICAgICAgcHJvdG9jb2xzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5pdEFzQ2xpZW50KHRoaXMsIGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2F1dG9Qb25nID0gb3B0aW9ucy5hdXRvUG9uZztcbiAgICAgIHRoaXMuX2Nsb3NlVGltZW91dCA9IG9wdGlvbnMuY2xvc2VUaW1lb3V0O1xuICAgICAgdGhpcy5faXNTZXJ2ZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgaGlzdG9yaWNhbCByZWFzb25zLCB0aGUgY3VzdG9tIFwibm9kZWJ1ZmZlclwiIHR5cGUgaXMgdXNlZCBieSB0aGUgZGVmYXVsdFxuICAgKiBpbnN0ZWFkIG9mIFwiYmxvYlwiLlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IGJpbmFyeVR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JpbmFyeVR5cGU7XG4gIH1cblxuICBzZXQgYmluYXJ5VHlwZSh0eXBlKSB7XG4gICAgaWYgKCFCSU5BUllfVFlQRVMuaW5jbHVkZXModHlwZSkpIHJldHVybjtcblxuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSB0eXBlO1xuXG4gICAgLy9cbiAgICAvLyBBbGxvdyB0byBjaGFuZ2UgYGJpbmFyeVR5cGVgIG9uIHRoZSBmbHkuXG4gICAgLy9cbiAgICBpZiAodGhpcy5fcmVjZWl2ZXIpIHRoaXMuX3JlY2VpdmVyLl9iaW5hcnlUeXBlID0gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGJ1ZmZlcmVkQW1vdW50KCkge1xuICAgIGlmICghdGhpcy5fc29ja2V0KSByZXR1cm4gdGhpcy5fYnVmZmVyZWRBbW91bnQ7XG5cbiAgICByZXR1cm4gdGhpcy5fc29ja2V0Ll93cml0YWJsZVN0YXRlLmxlbmd0aCArIHRoaXMuX3NlbmRlci5fYnVmZmVyZWRCeXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IGV4dGVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2V4dGVuc2lvbnMpLmpvaW4oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBpc1BhdXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGF1c2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbmNsb3NlKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbmVycm9yKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbm9wZW4oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9ubWVzc2FnZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHByb3RvY29sKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm90b2NvbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHJlYWR5U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWR5U3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCB1cmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXAgdGhlIHNvY2tldCBhbmQgdGhlIGludGVybmFsIHJlc291cmNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtEdXBsZXh9IHNvY2tldCBUaGUgbmV0d29yayBzb2NrZXQgYmV0d2VlbiB0aGUgc2VydmVyIGFuZCBjbGllbnRcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGhlYWQgVGhlIGZpcnN0IHBhY2tldCBvZiB0aGUgdXBncmFkZWQgc3RyZWFtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXJcbiAgICogICAgIGFueSBvZiB0aGUgYCdtZXNzYWdlJ2AsIGAncGluZydgLCBhbmQgYCdwb25nJ2AgZXZlbnRzIGNhbiBiZSBlbWl0dGVkXG4gICAqICAgICBtdWx0aXBsZSB0aW1lcyBpbiB0aGUgc2FtZSB0aWNrXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gICAqICAgICBtYXNraW5nIGtleVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0wXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2Ugc2l6ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3JcbiAgICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRTb2NrZXQoc29ja2V0LCBoZWFkLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoe1xuICAgICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzLFxuICAgICAgYmluYXJ5VHlwZTogdGhpcy5iaW5hcnlUeXBlLFxuICAgICAgZXh0ZW5zaW9uczogdGhpcy5fZXh0ZW5zaW9ucyxcbiAgICAgIGlzU2VydmVyOiB0aGlzLl9pc1NlcnZlcixcbiAgICAgIG1heFBheWxvYWQ6IG9wdGlvbnMubWF4UGF5bG9hZCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb25cbiAgICB9KTtcblxuICAgIGNvbnN0IHNlbmRlciA9IG5ldyBTZW5kZXIoc29ja2V0LCB0aGlzLl9leHRlbnNpb25zLCBvcHRpb25zLmdlbmVyYXRlTWFzayk7XG5cbiAgICB0aGlzLl9yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgIHRoaXMuX3NlbmRlciA9IHNlbmRlcjtcbiAgICB0aGlzLl9zb2NrZXQgPSBzb2NrZXQ7XG5cbiAgICByZWNlaXZlcltrV2ViU29ja2V0XSA9IHRoaXM7XG4gICAgc2VuZGVyW2tXZWJTb2NrZXRdID0gdGhpcztcbiAgICBzb2NrZXRba1dlYlNvY2tldF0gPSB0aGlzO1xuXG4gICAgcmVjZWl2ZXIub24oJ2NvbmNsdWRlJywgcmVjZWl2ZXJPbkNvbmNsdWRlKTtcbiAgICByZWNlaXZlci5vbignZHJhaW4nLCByZWNlaXZlck9uRHJhaW4pO1xuICAgIHJlY2VpdmVyLm9uKCdlcnJvcicsIHJlY2VpdmVyT25FcnJvcik7XG4gICAgcmVjZWl2ZXIub24oJ21lc3NhZ2UnLCByZWNlaXZlck9uTWVzc2FnZSk7XG4gICAgcmVjZWl2ZXIub24oJ3BpbmcnLCByZWNlaXZlck9uUGluZyk7XG4gICAgcmVjZWl2ZXIub24oJ3BvbmcnLCByZWNlaXZlck9uUG9uZyk7XG5cbiAgICBzZW5kZXIub25lcnJvciA9IHNlbmRlck9uRXJyb3I7XG5cbiAgICAvL1xuICAgIC8vIFRoZXNlIG1ldGhvZHMgbWF5IG5vdCBiZSBhdmFpbGFibGUgaWYgYHNvY2tldGAgaXMganVzdCBhIGBEdXBsZXhgLlxuICAgIC8vXG4gICAgaWYgKHNvY2tldC5zZXRUaW1lb3V0KSBzb2NrZXQuc2V0VGltZW91dCgwKTtcbiAgICBpZiAoc29ja2V0LnNldE5vRGVsYXkpIHNvY2tldC5zZXROb0RlbGF5KCk7XG5cbiAgICBpZiAoaGVhZC5sZW5ndGggPiAwKSBzb2NrZXQudW5zaGlmdChoZWFkKTtcblxuICAgIHNvY2tldC5vbignY2xvc2UnLCBzb2NrZXRPbkNsb3NlKTtcbiAgICBzb2NrZXQub24oJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuICAgIHNvY2tldC5vbignZW5kJywgc29ja2V0T25FbmQpO1xuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuT1BFTjtcbiAgICB0aGlzLmVtaXQoJ29wZW4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IHRoZSBgJ2Nsb3NlJ2AgZXZlbnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbWl0Q2xvc2UoKSB7XG4gICAgaWYgKCF0aGlzLl9zb2NrZXQpIHtcbiAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0VEO1xuICAgICAgdGhpcy5lbWl0KCdjbG9zZScsIHRoaXMuX2Nsb3NlQ29kZSwgdGhpcy5fY2xvc2VNZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXS5jbGVhbnVwKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVjZWl2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TRUQ7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIHRoaXMuX2Nsb3NlQ29kZSwgdGhpcy5fY2xvc2VNZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBhIGNsb3NpbmcgaGFuZHNoYWtlLlxuICAgKlxuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rXG4gICAqICAgICAtIC0gLXx3cy5jbG9zZSgpfC0tPnxjbG9zZSBmcmFtZXwtLT58d3MuY2xvc2UoKXwtIC0gLVxuICAgKiAgICB8ICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rICAgICB8XG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICAgICAgICB8XG4gICAqIENMT1NJTkcgIHx3cy5jbG9zZSgpfDwtLXxjbG9zZSBmcmFtZXw8LS0rLS0tLS0rICAgICAgIENMT1NJTkdcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgIHxcbiAgICogICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tKyAgICAgICAgfFxuICAgKiAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tPnxmaW58IC0gLSAtIC1cbiAgICogICAgfCAgICAgICAgICstLS0rICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tK1xuICAgKiAgICAgLSAtIC0gLSAtfGZpbnw8LS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgKiAgICAgICAgICAgICAgKy0tLStcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb2RlXSBTdGF0dXMgY29kZSBleHBsYWluaW5nIHdoeSB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nXG4gICAqIEBwYXJhbSB7KFN0cmluZ3xCdWZmZXIpfSBbZGF0YV0gVGhlIHJlYXNvbiB3aHkgdGhlIGNvbm5lY3Rpb24gaXNcbiAgICogICAgIGNsb3NpbmdcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY29kZSwgZGF0YSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHJldHVybjtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgY29uc3QgbXNnID0gJ1dlYlNvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSB0aGUgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQnO1xuICAgICAgYWJvcnRIYW5kc2hha2UodGhpcywgdGhpcy5fcmVxLCBtc2cpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TSU5HKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ICYmXG4gICAgICAgICh0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgfHwgdGhpcy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuX3NvY2tldC5lbmQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICB0aGlzLl9zZW5kZXIuY2xvc2UoY29kZSwgZGF0YSwgIXRoaXMuX2lzU2VydmVyLCAoZXJyKSA9PiB7XG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBlcnJvciBpcyBoYW5kbGVkIGJ5IHRoZSBgJ2Vycm9yJ2AgbGlzdGVuZXIgb24gdGhlIHNvY2tldC4gV2Ugb25seVxuICAgICAgLy8gd2FudCB0byBrbm93IGlmIHRoZSBjbG9zZSBmcmFtZSBoYXMgYmVlbiBzZW50IGhlcmUuXG4gICAgICAvL1xuICAgICAgaWYgKGVycikgcmV0dXJuO1xuXG4gICAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCA9IHRydWU7XG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkIHx8XG4gICAgICAgIHRoaXMuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZFxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuX3NvY2tldC5lbmQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHNldENsb3NlVGltZXIodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogUGF1c2UgdGhlIHNvY2tldC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcGF1c2UoKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORyB8fFxuICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLl9zb2NrZXQucGF1c2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgcGluZy5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBbZGF0YV0gVGhlIGRhdGEgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrXSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFjayB3aGljaCBpcyBleGVjdXRlZCB3aGVuIHRoZSBwaW5nIGlzIHNlbnRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcGluZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAwIChDT05ORUNUSU5HKScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBkYXRhO1xuICAgICAgZGF0YSA9IG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWFzayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBtYXNrO1xuICAgICAgbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWFzayA9PT0gdW5kZWZpbmVkKSBtYXNrID0gIXRoaXMuX2lzU2VydmVyO1xuICAgIHRoaXMuX3NlbmRlci5waW5nKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBtYXNrLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHBvbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFza10gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgcG9uZyBpcyBzZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBvbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gZGF0YTtcbiAgICAgIGRhdGEgPSBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gbWFzaztcbiAgICAgIG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1hc2sgPT09IHVuZGVmaW5lZCkgbWFzayA9ICF0aGlzLl9pc1NlcnZlcjtcbiAgICB0aGlzLl9zZW5kZXIucG9uZyhkYXRhIHx8IEVNUFRZX0JVRkZFUiwgbWFzaywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3VtZSB0aGUgc29ja2V0LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICByZXN1bWUoKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORyB8fFxuICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pIHRoaXMuX3NvY2tldC5yZXN1bWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmluYXJ5XSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5IG9yXG4gICAqICAgICB0ZXh0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29tcHJlc3NdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBjb21wcmVzc1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBmcmFnbWVudCBpcyB0aGVcbiAgICogICAgIGxhc3Qgb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFza10gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiBkYXRhIGlzIHdyaXR0ZW4gb3V0XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNlbmQoZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgYmluYXJ5OiB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycsXG4gICAgICBtYXNrOiAhdGhpcy5faXNTZXJ2ZXIsXG4gICAgICBjb21wcmVzczogdHJ1ZSxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKCF0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fc2VuZGVyLnNlbmQoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG9wdHMsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjaWJseSBjbG9zZSB0aGUgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdGVybWluYXRlKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHJldHVybjtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgY29uc3QgbXNnID0gJ1dlYlNvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSB0aGUgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQnO1xuICAgICAgYWJvcnRIYW5kc2hha2UodGhpcywgdGhpcy5fcmVxLCBtc2cpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zb2NrZXQpIHtcbiAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICAgIHRoaXMuX3NvY2tldC5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENPTk5FQ1RJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NPTk5FQ1RJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDT05ORUNUSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDT05ORUNUSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NPTk5FQ1RJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDT05ORUNUSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBPUEVOXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdPUEVOJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignT1BFTicpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gT1BFTlxuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdPUEVOJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignT1BFTicpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0lOR1xuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnQ0xPU0lORycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NJTkcnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnQ0xPU0lORycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NJTkcnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NFRFxuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnQ0xPU0VEJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0VEJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TRURcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnQ0xPU0VEJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0VEJylcbn0pO1xuXG5bXG4gICdiaW5hcnlUeXBlJyxcbiAgJ2J1ZmZlcmVkQW1vdW50JyxcbiAgJ2V4dGVuc2lvbnMnLFxuICAnaXNQYXVzZWQnLFxuICAncHJvdG9jb2wnLFxuICAncmVhZHlTdGF0ZScsXG4gICd1cmwnXG5dLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCBwcm9wZXJ0eSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufSk7XG5cbi8vXG4vLyBBZGQgdGhlIGBvbm9wZW5gLCBgb25lcnJvcmAsIGBvbmNsb3NlYCwgYW5kIGBvbm1lc3NhZ2VgIGF0dHJpYnV0ZXMuXG4vLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvY29tbXMuaHRtbCN0aGUtd2Vic29ja2V0LWludGVyZmFjZVxuLy9cblsnb3BlbicsICdlcnJvcicsICdjbG9zZScsICdtZXNzYWdlJ10uZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCBgb24ke21ldGhvZH1gLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQoKSB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKG1ldGhvZCkpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSkgcmV0dXJuIGxpc3RlbmVyW2tMaXN0ZW5lcl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgc2V0KGhhbmRsZXIpIHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnMobWV0aG9kKSkge1xuICAgICAgICBpZiAobGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihtZXRob2QsIGxpc3RlbmVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHJldHVybjtcblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKG1ldGhvZCwgaGFuZGxlciwge1xuICAgICAgICBba0Zvck9uRXZlbnRBdHRyaWJ1dGVdOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbldlYlNvY2tldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXI7XG5XZWJTb2NrZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSByZW1vdmVFdmVudExpc3RlbmVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldDtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgV2ViU29ja2V0IGNsaWVudC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBjbGllbnQgdG8gaW5pdGlhbGl6ZVxuICogQHBhcmFtIHsoU3RyaW5nfFVSTCl9IGFkZHJlc3MgVGhlIFVSTCB0byB3aGljaCB0byBjb25uZWN0XG4gKiBAcGFyYW0ge0FycmF5fSBwcm90b2NvbHMgVGhlIHN1YnByb3RvY29sc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25uZWN0aW9uIG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cz10cnVlXSBTcGVjaWZpZXMgd2hldGhlciBhbnlcbiAqICAgICBvZiB0aGUgYCdtZXNzYWdlJ2AsIGAncGluZydgLCBhbmQgYCdwb25nJ2AgZXZlbnRzIGNhbiBiZSBlbWl0dGVkIG11bHRpcGxlXG4gKiAgICAgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvUG9uZz10cnVlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG9cbiAqICAgICBhdXRvbWF0aWNhbGx5IHNlbmQgYSBwb25nIGluIHJlc3BvbnNlIHRvIGEgcGluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNsb3NlVGltZW91dD0zMDAwMF0gRHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXRcbiAqICAgICBmb3IgdGhlIGNsb3NpbmcgaGFuZHNoYWtlIHRvIGZpbmlzaCBhZnRlciBgd2Vic29ja2V0LmNsb3NlKClgIGlzIGNhbGxlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZmluaXNoUmVxdWVzdF0gQSBmdW5jdGlvbiB3aGljaCBjYW4gYmUgdXNlZCB0b1xuICogICAgIGN1c3RvbWl6ZSB0aGUgaGVhZGVycyBvZiBlYWNoIGh0dHAgcmVxdWVzdCBiZWZvcmUgaXQgaXMgc2VudFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5mb2xsb3dSZWRpcmVjdHM9ZmFsc2VdIFdoZXRoZXIgb3Igbm90IHRvIGZvbGxvd1xuICogICAgIHJlZGlyZWN0c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAqICAgICBtYXNraW5nIGtleVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhhbmRzaGFrZVRpbWVvdXRdIFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGVcbiAqICAgICBoYW5kc2hha2UgcmVxdWVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MTA0ODU3NjAwXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2VcbiAqICAgICBzaXplXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UmVkaXJlY3RzPTEwXSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmVkaXJlY3RzXG4gKiAgICAgYWxsb3dlZFxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm9yaWdpbl0gVmFsdWUgb2YgdGhlIGBPcmlnaW5gIG9yXG4gKiAgICAgYFNlYy1XZWJTb2NrZXQtT3JpZ2luYCBoZWFkZXJcbiAqIEBwYXJhbSB7KEJvb2xlYW58T2JqZWN0KX0gW29wdGlvbnMucGVyTWVzc2FnZURlZmxhdGU9dHJ1ZV0gRW5hYmxlL2Rpc2FibGVcbiAqICAgICBwZXJtZXNzYWdlLWRlZmxhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wcm90b2NvbFZlcnNpb249MTNdIFZhbHVlIG9mIHRoZVxuICogICAgIGBTZWMtV2ViU29ja2V0LVZlcnNpb25gIGhlYWRlclxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG4gKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluaXRBc0NsaWVudCh3ZWJzb2NrZXQsIGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0ge1xuICAgIGFsbG93U3luY2hyb25vdXNFdmVudHM6IHRydWUsXG4gICAgYXV0b1Bvbmc6IHRydWUsXG4gICAgY2xvc2VUaW1lb3V0OiBDTE9TRV9USU1FT1VULFxuICAgIHByb3RvY29sVmVyc2lvbjogcHJvdG9jb2xWZXJzaW9uc1sxXSxcbiAgICBtYXhQYXlsb2FkOiAxMDAgKiAxMDI0ICogMTAyNCxcbiAgICBza2lwVVRGOFZhbGlkYXRpb246IGZhbHNlLFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0cnVlLFxuICAgIGZvbGxvd1JlZGlyZWN0czogZmFsc2UsXG4gICAgbWF4UmVkaXJlY3RzOiAxMCxcbiAgICAuLi5vcHRpb25zLFxuICAgIHNvY2tldFBhdGg6IHVuZGVmaW5lZCxcbiAgICBob3N0bmFtZTogdW5kZWZpbmVkLFxuICAgIHByb3RvY29sOiB1bmRlZmluZWQsXG4gICAgdGltZW91dDogdW5kZWZpbmVkLFxuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgaG9zdDogdW5kZWZpbmVkLFxuICAgIHBhdGg6IHVuZGVmaW5lZCxcbiAgICBwb3J0OiB1bmRlZmluZWRcbiAgfTtcblxuICB3ZWJzb2NrZXQuX2F1dG9Qb25nID0gb3B0cy5hdXRvUG9uZztcbiAgd2Vic29ja2V0Ll9jbG9zZVRpbWVvdXQgPSBvcHRzLmNsb3NlVGltZW91dDtcblxuICBpZiAoIXByb3RvY29sVmVyc2lvbnMuaW5jbHVkZXMob3B0cy5wcm90b2NvbFZlcnNpb24pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICBgVW5zdXBwb3J0ZWQgcHJvdG9jb2wgdmVyc2lvbjogJHtvcHRzLnByb3RvY29sVmVyc2lvbn0gYCArXG4gICAgICAgIGAoc3VwcG9ydGVkIHZlcnNpb25zOiAke3Byb3RvY29sVmVyc2lvbnMuam9pbignLCAnKX0pYFxuICAgICk7XG4gIH1cblxuICBsZXQgcGFyc2VkVXJsO1xuXG4gIGlmIChhZGRyZXNzIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgcGFyc2VkVXJsID0gYWRkcmVzcztcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcGFyc2VkVXJsID0gbmV3IFVSTChhZGRyZXNzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgVVJMOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xuICAgIHBhcnNlZFVybC5wcm90b2NvbCA9ICd3czonO1xuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICBwYXJzZWRVcmwucHJvdG9jb2wgPSAnd3NzOic7XG4gIH1cblxuICB3ZWJzb2NrZXQuX3VybCA9IHBhcnNlZFVybC5ocmVmO1xuXG4gIGNvbnN0IGlzU2VjdXJlID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3NzOic7XG4gIGNvbnN0IGlzSXBjVXJsID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3MrdW5peDonO1xuICBsZXQgaW52YWxpZFVybE1lc3NhZ2U7XG5cbiAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ3dzOicgJiYgIWlzU2VjdXJlICYmICFpc0lwY1VybCkge1xuICAgIGludmFsaWRVcmxNZXNzYWdlID1cbiAgICAgICdUaGUgVVJMXFwncyBwcm90b2NvbCBtdXN0IGJlIG9uZSBvZiBcIndzOlwiLCBcIndzczpcIiwgJyArXG4gICAgICAnXCJodHRwOlwiLCBcImh0dHBzOlwiLCBvciBcIndzK3VuaXg6XCInO1xuICB9IGVsc2UgaWYgKGlzSXBjVXJsICYmICFwYXJzZWRVcmwucGF0aG5hbWUpIHtcbiAgICBpbnZhbGlkVXJsTWVzc2FnZSA9IFwiVGhlIFVSTCdzIHBhdGhuYW1lIGlzIGVtcHR5XCI7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLmhhc2gpIHtcbiAgICBpbnZhbGlkVXJsTWVzc2FnZSA9ICdUaGUgVVJMIGNvbnRhaW5zIGEgZnJhZ21lbnQgaWRlbnRpZmllcic7XG4gIH1cblxuICBpZiAoaW52YWxpZFVybE1lc3NhZ2UpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgU3ludGF4RXJyb3IoaW52YWxpZFVybE1lc3NhZ2UpO1xuXG4gICAgaWYgKHdlYnNvY2tldC5fcmVkaXJlY3RzID09PSAwKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBjb25zdCBkZWZhdWx0UG9ydCA9IGlzU2VjdXJlID8gNDQzIDogODA7XG4gIGNvbnN0IGtleSA9IHJhbmRvbUJ5dGVzKDE2KS50b1N0cmluZygnYmFzZTY0Jyk7XG4gIGNvbnN0IHJlcXVlc3QgPSBpc1NlY3VyZSA/IGh0dHBzLnJlcXVlc3QgOiBodHRwLnJlcXVlc3Q7XG4gIGNvbnN0IHByb3RvY29sU2V0ID0gbmV3IFNldCgpO1xuICBsZXQgcGVyTWVzc2FnZURlZmxhdGU7XG5cbiAgb3B0cy5jcmVhdGVDb25uZWN0aW9uID1cbiAgICBvcHRzLmNyZWF0ZUNvbm5lY3Rpb24gfHwgKGlzU2VjdXJlID8gdGxzQ29ubmVjdCA6IG5ldENvbm5lY3QpO1xuICBvcHRzLmRlZmF1bHRQb3J0ID0gb3B0cy5kZWZhdWx0UG9ydCB8fCBkZWZhdWx0UG9ydDtcbiAgb3B0cy5wb3J0ID0gcGFyc2VkVXJsLnBvcnQgfHwgZGVmYXVsdFBvcnQ7XG4gIG9wdHMuaG9zdCA9IHBhcnNlZFVybC5ob3N0bmFtZS5zdGFydHNXaXRoKCdbJylcbiAgICA/IHBhcnNlZFVybC5ob3N0bmFtZS5zbGljZSgxLCAtMSlcbiAgICA6IHBhcnNlZFVybC5ob3N0bmFtZTtcbiAgb3B0cy5oZWFkZXJzID0ge1xuICAgIC4uLm9wdHMuaGVhZGVycyxcbiAgICAnU2VjLVdlYlNvY2tldC1WZXJzaW9uJzogb3B0cy5wcm90b2NvbFZlcnNpb24sXG4gICAgJ1NlYy1XZWJTb2NrZXQtS2V5Jzoga2V5LFxuICAgIENvbm5lY3Rpb246ICdVcGdyYWRlJyxcbiAgICBVcGdyYWRlOiAnd2Vic29ja2V0J1xuICB9O1xuICBvcHRzLnBhdGggPSBwYXJzZWRVcmwucGF0aG5hbWUgKyBwYXJzZWRVcmwuc2VhcmNoO1xuICBvcHRzLnRpbWVvdXQgPSBvcHRzLmhhbmRzaGFrZVRpbWVvdXQ7XG5cbiAgaWYgKG9wdHMucGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcbiAgICAgIG9wdHMucGVyTWVzc2FnZURlZmxhdGUgIT09IHRydWUgPyBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlIDoge30sXG4gICAgICBmYWxzZSxcbiAgICAgIG9wdHMubWF4UGF5bG9hZFxuICAgICk7XG4gICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMnXSA9IGZvcm1hdCh7XG4gICAgICBbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV06IHBlck1lc3NhZ2VEZWZsYXRlLm9mZmVyKClcbiAgICB9KTtcbiAgfVxuICBpZiAocHJvdG9jb2xzLmxlbmd0aCkge1xuICAgIGZvciAoY29uc3QgcHJvdG9jb2wgb2YgcHJvdG9jb2xzKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBwcm90b2NvbCAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgIXN1YnByb3RvY29sUmVnZXgudGVzdChwcm90b2NvbCkgfHxcbiAgICAgICAgcHJvdG9jb2xTZXQuaGFzKHByb3RvY29sKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgICAnQW4gaW52YWxpZCBvciBkdXBsaWNhdGVkIHN1YnByb3RvY29sIHdhcyBzcGVjaWZpZWQnXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHByb3RvY29sU2V0LmFkZChwcm90b2NvbCk7XG4gICAgfVxuXG4gICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LVByb3RvY29sJ10gPSBwcm90b2NvbHMuam9pbignLCcpO1xuICB9XG4gIGlmIChvcHRzLm9yaWdpbikge1xuICAgIGlmIChvcHRzLnByb3RvY29sVmVyc2lvbiA8IDEzKSB7XG4gICAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtT3JpZ2luJ10gPSBvcHRzLm9yaWdpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0cy5oZWFkZXJzLk9yaWdpbiA9IG9wdHMub3JpZ2luO1xuICAgIH1cbiAgfVxuICBpZiAocGFyc2VkVXJsLnVzZXJuYW1lIHx8IHBhcnNlZFVybC5wYXNzd29yZCkge1xuICAgIG9wdHMuYXV0aCA9IGAke3BhcnNlZFVybC51c2VybmFtZX06JHtwYXJzZWRVcmwucGFzc3dvcmR9YDtcbiAgfVxuXG4gIGlmIChpc0lwY1VybCkge1xuICAgIGNvbnN0IHBhcnRzID0gb3B0cy5wYXRoLnNwbGl0KCc6Jyk7XG5cbiAgICBvcHRzLnNvY2tldFBhdGggPSBwYXJ0c1swXTtcbiAgICBvcHRzLnBhdGggPSBwYXJ0c1sxXTtcbiAgfVxuXG4gIGxldCByZXE7XG5cbiAgaWYgKG9wdHMuZm9sbG93UmVkaXJlY3RzKSB7XG4gICAgaWYgKHdlYnNvY2tldC5fcmVkaXJlY3RzID09PSAwKSB7XG4gICAgICB3ZWJzb2NrZXQuX29yaWdpbmFsSXBjID0gaXNJcGNVcmw7XG4gICAgICB3ZWJzb2NrZXQuX29yaWdpbmFsU2VjdXJlID0gaXNTZWN1cmU7XG4gICAgICB3ZWJzb2NrZXQuX29yaWdpbmFsSG9zdE9yU29ja2V0UGF0aCA9IGlzSXBjVXJsXG4gICAgICAgID8gb3B0cy5zb2NrZXRQYXRoXG4gICAgICAgIDogcGFyc2VkVXJsLmhvc3Q7XG5cbiAgICAgIGNvbnN0IGhlYWRlcnMgPSBvcHRpb25zICYmIG9wdGlvbnMuaGVhZGVycztcblxuICAgICAgLy9cbiAgICAgIC8vIFNoYWxsb3cgY29weSB0aGUgdXNlciBwcm92aWRlZCBvcHRpb25zIHNvIHRoYXQgaGVhZGVycyBjYW4gYmUgY2hhbmdlZFxuICAgICAgLy8gd2l0aG91dCBtdXRhdGluZyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgICAgLy9cbiAgICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGhlYWRlcnM6IHt9IH07XG5cbiAgICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgb3B0aW9ucy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh3ZWJzb2NrZXQubGlzdGVuZXJDb3VudCgncmVkaXJlY3QnKSA9PT0gMCkge1xuICAgICAgY29uc3QgaXNTYW1lSG9zdCA9IGlzSXBjVXJsXG4gICAgICAgID8gd2Vic29ja2V0Ll9vcmlnaW5hbElwY1xuICAgICAgICAgID8gb3B0cy5zb2NrZXRQYXRoID09PSB3ZWJzb2NrZXQuX29yaWdpbmFsSG9zdE9yU29ja2V0UGF0aFxuICAgICAgICAgIDogZmFsc2VcbiAgICAgICAgOiB3ZWJzb2NrZXQuX29yaWdpbmFsSXBjXG4gICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgIDogcGFyc2VkVXJsLmhvc3QgPT09IHdlYnNvY2tldC5fb3JpZ2luYWxIb3N0T3JTb2NrZXRQYXRoO1xuXG4gICAgICBpZiAoIWlzU2FtZUhvc3QgfHwgKHdlYnNvY2tldC5fb3JpZ2luYWxTZWN1cmUgJiYgIWlzU2VjdXJlKSkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBNYXRjaCBjdXJsIDcuNzcuMCBiZWhhdmlvciBhbmQgZHJvcCB0aGUgZm9sbG93aW5nIGhlYWRlcnMuIFRoZXNlXG4gICAgICAgIC8vIGhlYWRlcnMgYXJlIGFsc28gZHJvcHBlZCB3aGVuIGZvbGxvd2luZyBhIHJlZGlyZWN0IHRvIGEgc3ViZG9tYWluLlxuICAgICAgICAvL1xuICAgICAgICBkZWxldGUgb3B0cy5oZWFkZXJzLmF1dGhvcml6YXRpb247XG4gICAgICAgIGRlbGV0ZSBvcHRzLmhlYWRlcnMuY29va2llO1xuXG4gICAgICAgIGlmICghaXNTYW1lSG9zdCkgZGVsZXRlIG9wdHMuaGVhZGVycy5ob3N0O1xuXG4gICAgICAgIG9wdHMuYXV0aCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIE1hdGNoIGN1cmwgNy43Ny4wIGJlaGF2aW9yIGFuZCBtYWtlIHRoZSBmaXJzdCBgQXV0aG9yaXphdGlvbmAgaGVhZGVyIHdpbi5cbiAgICAvLyBJZiB0aGUgYEF1dGhvcml6YXRpb25gIGhlYWRlciBpcyBzZXQsIHRoZW4gdGhlcmUgaXMgbm90aGluZyB0byBkbyBhcyBpdFxuICAgIC8vIHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICAgIC8vXG4gICAgaWYgKG9wdHMuYXV0aCAmJiAhb3B0aW9ucy5oZWFkZXJzLmF1dGhvcml6YXRpb24pIHtcbiAgICAgIG9wdGlvbnMuaGVhZGVycy5hdXRob3JpemF0aW9uID1cbiAgICAgICAgJ0Jhc2ljICcgKyBCdWZmZXIuZnJvbShvcHRzLmF1dGgpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG5cbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IHJlcXVlc3Qob3B0cyk7XG5cbiAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMpIHtcbiAgICAgIC8vXG4gICAgICAvLyBVbmxpa2Ugd2hhdCBpcyBkb25lIGZvciB0aGUgYCd1cGdyYWRlJ2AgZXZlbnQsIG5vIGVhcmx5IGV4aXQgaXNcbiAgICAgIC8vIHRyaWdnZXJlZCBoZXJlIGlmIHRoZSB1c2VyIGNhbGxzIGB3ZWJzb2NrZXQuY2xvc2UoKWAgb3JcbiAgICAgIC8vIGB3ZWJzb2NrZXQudGVybWluYXRlKClgIGZyb20gYSBsaXN0ZW5lciBvZiB0aGUgYCdyZWRpcmVjdCdgIGV2ZW50LiBUaGlzXG4gICAgICAvLyBpcyBiZWNhdXNlIHRoZSB1c2VyIGNhbiBhbHNvIGNhbGwgYHJlcXVlc3QuZGVzdHJveSgpYCB3aXRoIGFuIGVycm9yXG4gICAgICAvLyBiZWZvcmUgY2FsbGluZyBgd2Vic29ja2V0LmNsb3NlKClgIG9yIGB3ZWJzb2NrZXQudGVybWluYXRlKClgIGFuZCB0aGlzXG4gICAgICAvLyB3b3VsZCByZXN1bHQgaW4gYW4gZXJyb3IgYmVpbmcgZW1pdHRlZCBvbiB0aGUgYHJlcXVlc3RgIG9iamVjdCB3aXRoIG5vXG4gICAgICAvLyBgJ2Vycm9yJ2AgZXZlbnQgbGlzdGVuZXJzIGF0dGFjaGVkLlxuICAgICAgLy9cbiAgICAgIHdlYnNvY2tldC5lbWl0KCdyZWRpcmVjdCcsIHdlYnNvY2tldC51cmwsIHJlcSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gcmVxdWVzdChvcHRzKTtcbiAgfVxuXG4gIGlmIChvcHRzLnRpbWVvdXQpIHtcbiAgICByZXEub24oJ3RpbWVvdXQnLCAoKSA9PiB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHJlcSwgJ09wZW5pbmcgaGFuZHNoYWtlIGhhcyB0aW1lZCBvdXQnKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlcS5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgaWYgKHJlcSA9PT0gbnVsbCB8fCByZXFba0Fib3J0ZWRdKSByZXR1cm47XG5cbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IG51bGw7XG4gICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xuICB9KTtcblxuICByZXEub24oJ3Jlc3BvbnNlJywgKHJlcykgPT4ge1xuICAgIGNvbnN0IGxvY2F0aW9uID0gcmVzLmhlYWRlcnMubG9jYXRpb247XG4gICAgY29uc3Qgc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXNDb2RlO1xuXG4gICAgaWYgKFxuICAgICAgbG9jYXRpb24gJiZcbiAgICAgIG9wdHMuZm9sbG93UmVkaXJlY3RzICYmXG4gICAgICBzdGF0dXNDb2RlID49IDMwMCAmJlxuICAgICAgc3RhdHVzQ29kZSA8IDQwMFxuICAgICkge1xuICAgICAgaWYgKCsrd2Vic29ja2V0Ll9yZWRpcmVjdHMgPiBvcHRzLm1heFJlZGlyZWN0cykge1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHJlcSwgJ01heGltdW0gcmVkaXJlY3RzIGV4Y2VlZGVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVxLmFib3J0KCk7XG5cbiAgICAgIGxldCBhZGRyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhZGRyID0gbmV3IFVSTChsb2NhdGlvbiwgYWRkcmVzcyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBVUkw6ICR7bG9jYXRpb259YCk7XG4gICAgICAgIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpbml0QXNDbGllbnQod2Vic29ja2V0LCBhZGRyLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoIXdlYnNvY2tldC5lbWl0KCd1bmV4cGVjdGVkLXJlc3BvbnNlJywgcmVxLCByZXMpKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZShcbiAgICAgICAgd2Vic29ja2V0LFxuICAgICAgICByZXEsXG4gICAgICAgIGBVbmV4cGVjdGVkIHNlcnZlciByZXNwb25zZTogJHtyZXMuc3RhdHVzQ29kZX1gXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgcmVxLm9uKCd1cGdyYWRlJywgKHJlcywgc29ja2V0LCBoZWFkKSA9PiB7XG4gICAgd2Vic29ja2V0LmVtaXQoJ3VwZ3JhZGUnLCByZXMpO1xuXG4gICAgLy9cbiAgICAvLyBUaGUgdXNlciBtYXkgaGF2ZSBjbG9zZWQgdGhlIGNvbm5lY3Rpb24gZnJvbSBhIGxpc3RlbmVyIG9mIHRoZVxuICAgIC8vIGAndXBncmFkZSdgIGV2ZW50LlxuICAgIC8vXG4gICAgaWYgKHdlYnNvY2tldC5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuQ09OTkVDVElORykgcmV0dXJuO1xuXG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSBudWxsO1xuXG4gICAgY29uc3QgdXBncmFkZSA9IHJlcy5oZWFkZXJzLnVwZ3JhZGU7XG5cbiAgICBpZiAodXBncmFkZSA9PT0gdW5kZWZpbmVkIHx8IHVwZ3JhZGUudG9Mb3dlckNhc2UoKSAhPT0gJ3dlYnNvY2tldCcpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCAnSW52YWxpZCBVcGdyYWRlIGhlYWRlcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRpZ2VzdCA9IGNyZWF0ZUhhc2goJ3NoYTEnKVxuICAgICAgLnVwZGF0ZShrZXkgKyBHVUlEKVxuICAgICAgLmRpZ2VzdCgnYmFzZTY0Jyk7XG5cbiAgICBpZiAocmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtYWNjZXB0J10gIT09IGRpZ2VzdCkge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtQWNjZXB0IGhlYWRlcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNlcnZlclByb3QgPSByZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuICAgIGxldCBwcm90RXJyb3I7XG5cbiAgICBpZiAoc2VydmVyUHJvdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXByb3RvY29sU2V0LnNpemUpIHtcbiAgICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IGEgc3VicHJvdG9jb2wgYnV0IG5vbmUgd2FzIHJlcXVlc3RlZCc7XG4gICAgICB9IGVsc2UgaWYgKCFwcm90b2NvbFNldC5oYXMoc2VydmVyUHJvdCkpIHtcbiAgICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IGFuIGludmFsaWQgc3VicHJvdG9jb2wnO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvdG9jb2xTZXQuc2l6ZSkge1xuICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IG5vIHN1YnByb3RvY29sJztcbiAgICB9XG5cbiAgICBpZiAocHJvdEVycm9yKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgcHJvdEVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2VydmVyUHJvdCkgd2Vic29ja2V0Ll9wcm90b2NvbCA9IHNlcnZlclByb3Q7XG5cbiAgICBjb25zdCBzZWNXZWJTb2NrZXRFeHRlbnNpb25zID0gcmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddO1xuXG4gICAgaWYgKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCFwZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICAgICAnU2VydmVyIHNlbnQgYSBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyIGJ1dCBubyBleHRlbnNpb24gJyArXG4gICAgICAgICAgJ3dhcyByZXF1ZXN0ZWQnO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGV4dGVuc2lvbnM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGV4dGVuc2lvbnMgPSBwYXJzZShzZWNXZWJTb2NrZXRFeHRlbnNpb25zKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBleHRlbnNpb25OYW1lcyA9IE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIGV4dGVuc2lvbk5hbWVzLmxlbmd0aCAhPT0gMSB8fFxuICAgICAgICBleHRlbnNpb25OYW1lc1swXSAhPT0gUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnU2VydmVyIGluZGljYXRlZCBhbiBleHRlbnNpb24gdGhhdCB3YXMgbm90IHJlcXVlc3RlZCc7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5hY2NlcHQoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXInO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2Vic29ja2V0Ll9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdID1cbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGU7XG4gICAgfVxuXG4gICAgd2Vic29ja2V0LnNldFNvY2tldChzb2NrZXQsIGhlYWQsIHtcbiAgICAgIGFsbG93U3luY2hyb25vdXNFdmVudHM6IG9wdHMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cyxcbiAgICAgIGdlbmVyYXRlTWFzazogb3B0cy5nZW5lcmF0ZU1hc2ssXG4gICAgICBtYXhQYXlsb2FkOiBvcHRzLm1heFBheWxvYWQsXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IG9wdHMuc2tpcFVURjhWYWxpZGF0aW9uXG4gICAgfSk7XG4gIH0pO1xuXG4gIGlmIChvcHRzLmZpbmlzaFJlcXVlc3QpIHtcbiAgICBvcHRzLmZpbmlzaFJlcXVlc3QocmVxLCB3ZWJzb2NrZXQpO1xuICB9IGVsc2Uge1xuICAgIHJlcS5lbmQoKTtcbiAgfVxufVxuXG4vKipcbiAqIEVtaXQgdGhlIGAnZXJyb3InYCBhbmQgYCdjbG9zZSdgIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7RXJyb3J9IFRoZSBlcnJvciB0byBlbWl0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQsIGVycikge1xuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgLy9cbiAgLy8gVGhlIGZvbGxvd2luZyBhc3NpZ25tZW50IGlzIHByYWN0aWNhbGx5IHVzZWxlc3MgYW5kIGlzIGRvbmUgb25seSBmb3JcbiAgLy8gY29uc2lzdGVuY3kuXG4gIC8vXG4gIHdlYnNvY2tldC5fZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgd2Vic29ja2V0LmVtaXRDbG9zZSgpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGBuZXQuU29ja2V0YCBhbmQgaW5pdGlhdGUgYSBjb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHJldHVybiB7bmV0LlNvY2tldH0gVGhlIG5ld2x5IGNyZWF0ZWQgc29ja2V0IHVzZWQgdG8gc3RhcnQgdGhlIGNvbm5lY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5ldENvbm5lY3Qob3B0aW9ucykge1xuICBvcHRpb25zLnBhdGggPSBvcHRpb25zLnNvY2tldFBhdGg7XG4gIHJldHVybiBuZXQuY29ubmVjdChvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgdGxzLlRMU1NvY2tldGAgYW5kIGluaXRpYXRlIGEgY29ubmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25uZWN0aW9uIG9wdGlvbnNcbiAqIEByZXR1cm4ge3Rscy5UTFNTb2NrZXR9IFRoZSBuZXdseSBjcmVhdGVkIHNvY2tldCB1c2VkIHRvIHN0YXJ0IHRoZSBjb25uZWN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0bHNDb25uZWN0KG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5wYXRoID0gdW5kZWZpbmVkO1xuXG4gIGlmICghb3B0aW9ucy5zZXJ2ZXJuYW1lICYmIG9wdGlvbnMuc2VydmVybmFtZSAhPT0gJycpIHtcbiAgICBvcHRpb25zLnNlcnZlcm5hbWUgPSBuZXQuaXNJUChvcHRpb25zLmhvc3QpID8gJycgOiBvcHRpb25zLmhvc3Q7XG4gIH1cblxuICByZXR1cm4gdGxzLmNvbm5lY3Qob3B0aW9ucyk7XG59XG5cbi8qKlxuICogQWJvcnQgdGhlIGhhbmRzaGFrZSBhbmQgZW1pdCBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7KGh0dHAuQ2xpZW50UmVxdWVzdHxuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzdHJlYW0gVGhlIHJlcXVlc3QgdG9cbiAqICAgICBhYm9ydCBvciB0aGUgc29ja2V0IHRvIGRlc3Ryb3lcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHN0cmVhbSwgbWVzc2FnZSkge1xuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcblxuICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgYWJvcnRIYW5kc2hha2UpO1xuXG4gIGlmIChzdHJlYW0uc2V0SGVhZGVyKSB7XG4gICAgc3RyZWFtW2tBYm9ydGVkXSA9IHRydWU7XG4gICAgc3RyZWFtLmFib3J0KCk7XG5cbiAgICBpZiAoc3RyZWFtLnNvY2tldCAmJiAhc3RyZWFtLnNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgIC8vXG4gICAgICAvLyBPbiBOb2RlLmpzID49IDE0LjMuMCBgcmVxdWVzdC5hYm9ydCgpYCBkb2VzIG5vdCBkZXN0cm95IHRoZSBzb2NrZXQgaWZcbiAgICAgIC8vIGNhbGxlZCBhZnRlciB0aGUgcmVxdWVzdCBjb21wbGV0ZWQuIFNlZVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvaXNzdWVzLzE4NjkuXG4gICAgICAvL1xuICAgICAgc3RyZWFtLnNvY2tldC5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZSwgd2Vic29ja2V0LCBlcnIpO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5kZXN0cm95KGVycik7XG4gICAgc3RyZWFtLm9uY2UoJ2Vycm9yJywgd2Vic29ja2V0LmVtaXQuYmluZCh3ZWJzb2NrZXQsICdlcnJvcicpKTtcbiAgICBzdHJlYW0ub25jZSgnY2xvc2UnLCB3ZWJzb2NrZXQuZW1pdENsb3NlLmJpbmQod2Vic29ja2V0KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgY2FzZXMgd2hlcmUgdGhlIGBwaW5nKClgLCBgcG9uZygpYCwgb3IgYHNlbmQoKWAgbWV0aG9kcyBhcmUgY2FsbGVkXG4gKiB3aGVuIHRoZSBgcmVhZHlTdGF0ZWAgYXR0cmlidXRlIGlzIGBDTE9TSU5HYCBvciBgQ0xPU0VEYC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNlbmRBZnRlckNsb3NlKHdlYnNvY2tldCwgZGF0YSwgY2IpIHtcbiAgaWYgKGRhdGEpIHtcbiAgICBjb25zdCBsZW5ndGggPSBpc0Jsb2IoZGF0YSkgPyBkYXRhLnNpemUgOiB0b0J1ZmZlcihkYXRhKS5sZW5ndGg7XG5cbiAgICAvL1xuICAgIC8vIFRoZSBgX2J1ZmZlcmVkQW1vdW50YCBwcm9wZXJ0eSBpcyB1c2VkIG9ubHkgd2hlbiB0aGUgcGVlciBpcyBhIGNsaWVudCBhbmRcbiAgICAvLyB0aGUgb3BlbmluZyBoYW5kc2hha2UgZmFpbHMuIFVuZGVyIHRoZXNlIGNpcmN1bXN0YW5jZXMsIGluIGZhY3QsIHRoZVxuICAgIC8vIGBzZXRTb2NrZXQoKWAgbWV0aG9kIGlzIG5vdCBjYWxsZWQsIHNvIHRoZSBgX3NvY2tldGAgYW5kIGBfc2VuZGVyYFxuICAgIC8vIHByb3BlcnRpZXMgYXJlIHNldCB0byBgbnVsbGAuXG4gICAgLy9cbiAgICBpZiAod2Vic29ja2V0Ll9zb2NrZXQpIHdlYnNvY2tldC5fc2VuZGVyLl9idWZmZXJlZEJ5dGVzICs9IGxlbmd0aDtcbiAgICBlbHNlIHdlYnNvY2tldC5fYnVmZmVyZWRBbW91bnQgKz0gbGVuZ3RoO1xuICB9XG5cbiAgaWYgKGNiKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgYFdlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAke3dlYnNvY2tldC5yZWFkeVN0YXRlfSBgICtcbiAgICAgICAgYCgke3JlYWR5U3RhdGVzW3dlYnNvY2tldC5yZWFkeVN0YXRlXX0pYFxuICAgICk7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2NvbmNsdWRlJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIHN0YXR1cyBjb2RlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcmVhc29uIFRoZSByZWFzb24gZm9yIGNsb3NpbmdcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25Db25jbHVkZShjb2RlLCByZWFzb24pIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB3ZWJzb2NrZXQuX2Nsb3NlRnJhbWVSZWNlaXZlZCA9IHRydWU7XG4gIHdlYnNvY2tldC5fY2xvc2VNZXNzYWdlID0gcmVhc29uO1xuICB3ZWJzb2NrZXQuX2Nsb3NlQ29kZSA9IGNvZGU7XG5cbiAgaWYgKHdlYnNvY2tldC5fc29ja2V0W2tXZWJTb2NrZXRdID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICB3ZWJzb2NrZXQuX3NvY2tldC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB3ZWJzb2NrZXQuX3NvY2tldCk7XG5cbiAgaWYgKGNvZGUgPT09IDEwMDUpIHdlYnNvY2tldC5jbG9zZSgpO1xuICBlbHNlIHdlYnNvY2tldC5jbG9zZShjb2RlLCByZWFzb24pO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2RyYWluJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkRyYWluKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIGlmICghd2Vic29ja2V0LmlzUGF1c2VkKSB3ZWJzb2NrZXQuX3NvY2tldC5yZXN1bWUoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFJhbmdlRXJyb3J8RXJyb3IpfSBlcnIgVGhlIGVtaXR0ZWQgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25FcnJvcihlcnIpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICBpZiAod2Vic29ja2V0Ll9zb2NrZXRba1dlYlNvY2tldF0gIT09IHVuZGVmaW5lZCkge1xuICAgIHdlYnNvY2tldC5fc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcblxuICAgIC8vXG4gICAgLy8gT24gTm9kZS5qcyA8IDE0LjAuMCB0aGUgYCdlcnJvcidgIGV2ZW50IGlzIGVtaXR0ZWQgc3luY2hyb25vdXNseS4gU2VlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvaXNzdWVzLzE5NDAuXG4gICAgLy9cbiAgICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZSwgd2Vic29ja2V0Ll9zb2NrZXQpO1xuXG4gICAgd2Vic29ja2V0LmNsb3NlKGVycltrU3RhdHVzQ29kZV0pO1xuICB9XG5cbiAgaWYgKCF3ZWJzb2NrZXQuX2Vycm9yRW1pdHRlZCkge1xuICAgIHdlYnNvY2tldC5fZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnZmluaXNoJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkZpbmlzaCgpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0Q2xvc2UoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdtZXNzYWdlJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXlCdWZmZXJ8QnVmZmVyW10pfSBkYXRhIFRoZSBtZXNzYWdlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQmluYXJ5IFNwZWNpZmllcyB3aGV0aGVyIHRoZSBtZXNzYWdlIGlzIGJpbmFyeSBvciBub3RcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25NZXNzYWdlKGRhdGEsIGlzQmluYXJ5KSB7XG4gIHRoaXNba1dlYlNvY2tldF0uZW1pdCgnbWVzc2FnZScsIGRhdGEsIGlzQmluYXJ5KTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdwaW5nJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIGRhdGEgaW5jbHVkZWQgaW4gdGhlIHBpbmcgZnJhbWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25QaW5nKGRhdGEpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICBpZiAod2Vic29ja2V0Ll9hdXRvUG9uZykgd2Vic29ja2V0LnBvbmcoZGF0YSwgIXRoaXMuX2lzU2VydmVyLCBOT09QKTtcbiAgd2Vic29ja2V0LmVtaXQoJ3BpbmcnLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdwb25nJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIGRhdGEgaW5jbHVkZWQgaW4gdGhlIHBvbmcgZnJhbWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25Qb25nKGRhdGEpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0KCdwb25nJywgZGF0YSk7XG59XG5cbi8qKlxuICogUmVzdW1lIGEgcmVhZGFibGUgc3RyZWFtXG4gKlxuICogQHBhcmFtIHtSZWFkYWJsZX0gc3RyZWFtIFRoZSByZWFkYWJsZSBzdHJlYW1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0pIHtcbiAgc3RyZWFtLnJlc3VtZSgpO1xufVxuXG4vKipcbiAqIFRoZSBgU2VuZGVyYCBlcnJvciBldmVudCBoYW5kbGVyLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IFRoZSBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2VuZGVyT25FcnJvcihlcnIpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICBpZiAod2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHJldHVybjtcbiAgaWYgKHdlYnNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgIHNldENsb3NlVGltZXIod2Vic29ja2V0KTtcbiAgfVxuXG4gIC8vXG4gIC8vIGBzb2NrZXQuZW5kKClgIGlzIHVzZWQgaW5zdGVhZCBvZiBgc29ja2V0LmRlc3Ryb3koKWAgdG8gYWxsb3cgdGhlIG90aGVyXG4gIC8vIHBlZXIgdG8gZmluaXNoIHNlbmRpbmcgcXVldWVkIGRhdGEuIFRoZXJlIGlzIG5vIG5lZWQgdG8gc2V0IGEgdGltZXIgaGVyZVxuICAvLyBiZWNhdXNlIGBDTE9TSU5HYCBtZWFucyB0aGF0IGl0IGlzIGFscmVhZHkgc2V0IG9yIG5vdCBuZWVkZWQuXG4gIC8vXG4gIHRoaXMuX3NvY2tldC5lbmQoKTtcblxuICBpZiAoIXdlYnNvY2tldC5fZXJyb3JFbWl0dGVkKSB7XG4gICAgd2Vic29ja2V0Ll9lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHdlYnNvY2tldC5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgYSB0aW1lciB0byBkZXN0cm95IHRoZSB1bmRlcmx5aW5nIHJhdyBzb2NrZXQgb2YgYSBXZWJTb2NrZXQuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXRDbG9zZVRpbWVyKHdlYnNvY2tldCkge1xuICB3ZWJzb2NrZXQuX2Nsb3NlVGltZXIgPSBzZXRUaW1lb3V0KFxuICAgIHdlYnNvY2tldC5fc29ja2V0LmRlc3Ryb3kuYmluZCh3ZWJzb2NrZXQuX3NvY2tldCksXG4gICAgd2Vic29ja2V0Ll9jbG9zZVRpbWVvdXRcbiAgKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIHNvY2tldCBgJ2Nsb3NlJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25DbG9zZSgpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIHNvY2tldE9uQ2xvc2UpO1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZW5kJywgc29ja2V0T25FbmQpO1xuXG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXG4gIC8vXG4gIC8vIFRoZSBjbG9zZSBmcmFtZSBtaWdodCBub3QgaGF2ZSBiZWVuIHJlY2VpdmVkIG9yIHRoZSBgJ2VuZCdgIGV2ZW50IGVtaXR0ZWQsXG4gIC8vIGZvciBleGFtcGxlLCBpZiB0aGUgc29ja2V0IHdhcyBkZXN0cm95ZWQgZHVlIHRvIGFuIGVycm9yLiBFbnN1cmUgdGhhdCB0aGVcbiAgLy8gYHJlY2VpdmVyYCBzdHJlYW0gaXMgY2xvc2VkIGFmdGVyIHdyaXRpbmcgYW55IHJlbWFpbmluZyBidWZmZXJlZCBkYXRhIHRvXG4gIC8vIGl0LiBJZiB0aGUgcmVhZGFibGUgc2lkZSBvZiB0aGUgc29ja2V0IGlzIGluIGZsb3dpbmcgbW9kZSB0aGVuIHRoZXJlIGlzIG5vXG4gIC8vIGJ1ZmZlcmVkIGRhdGEgYXMgZXZlcnl0aGluZyBoYXMgYmVlbiBhbHJlYWR5IHdyaXR0ZW4uIElmIGluc3RlYWQsIHRoZVxuICAvLyBzb2NrZXQgaXMgcGF1c2VkLCBhbnkgcG9zc2libGUgYnVmZmVyZWQgZGF0YSB3aWxsIGJlIHJlYWQgYXMgYSBzaW5nbGVcbiAgLy8gY2h1bmsuXG4gIC8vXG4gIGlmIChcbiAgICAhdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkICYmXG4gICAgIXdlYnNvY2tldC5fY2xvc2VGcmFtZVJlY2VpdmVkICYmXG4gICAgIXdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkICYmXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGggIT09IDBcbiAgKSB7XG4gICAgY29uc3QgY2h1bmsgPSB0aGlzLnJlYWQodGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGgpO1xuXG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci53cml0ZShjaHVuayk7XG4gIH1cblxuICB3ZWJzb2NrZXQuX3JlY2VpdmVyLmVuZCgpO1xuXG4gIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG5cbiAgY2xlYXJUaW1lb3V0KHdlYnNvY2tldC5fY2xvc2VUaW1lcik7XG5cbiAgaWYgKFxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgfHxcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZFxuICApIHtcbiAgICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5vbignZXJyb3InLCByZWNlaXZlck9uRmluaXNoKTtcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLm9uKCdmaW5pc2gnLCByZWNlaXZlck9uRmluaXNoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgc29ja2V0IGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRGF0YShjaHVuaykge1xuICBpZiAoIXRoaXNba1dlYlNvY2tldF0uX3JlY2VpdmVyLndyaXRlKGNodW5rKSkge1xuICAgIHRoaXMucGF1c2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgc29ja2V0IGAnZW5kJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25FbmQoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gIHdlYnNvY2tldC5fcmVjZWl2ZXIuZW5kKCk7XG4gIHRoaXMuZW5kKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBzb2NrZXQgYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcbiAgdGhpcy5vbignZXJyb3InLCBOT09QKTtcblxuICBpZiAod2Vic29ja2V0KSB7XG4gICAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbn1cbiIsICIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5XZWJTb2NrZXQkXCIgfV0gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgV2ViU29ja2V0ID0gcmVxdWlyZSgnLi93ZWJzb2NrZXQnKTtcbmNvbnN0IHsgRHVwbGV4IH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuLyoqXG4gKiBFbWl0cyB0aGUgYCdjbG9zZSdgIGV2ZW50IG9uIGEgc3RyZWFtLlxuICpcbiAqIEBwYXJhbSB7RHVwbGV4fSBzdHJlYW0gVGhlIHN0cmVhbS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVtaXRDbG9zZShzdHJlYW0pIHtcbiAgc3RyZWFtLmVtaXQoJ2Nsb3NlJyk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgJ2VuZCdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGR1cGxleE9uRW5kKCkge1xuICBpZiAoIXRoaXMuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQpIHtcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGR1cGxleE9uRXJyb3IoZXJyKSB7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZHVwbGV4T25FcnJvcik7XG4gIHRoaXMuZGVzdHJveSgpO1xuICBpZiAodGhpcy5saXN0ZW5lckNvdW50KCdlcnJvcicpID09PSAwKSB7XG4gICAgLy8gRG8gbm90IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvci5cbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIFdyYXBzIGEgYFdlYlNvY2tldGAgaW4gYSBkdXBsZXggc3RyZWFtLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3cyBUaGUgYFdlYlNvY2tldGAgdG8gd3JhcFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBmb3IgdGhlIGBEdXBsZXhgIGNvbnN0cnVjdG9yXG4gKiBAcmV0dXJuIHtEdXBsZXh9IFRoZSBkdXBsZXggc3RyZWFtXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVdlYlNvY2tldFN0cmVhbSh3cywgb3B0aW9ucykge1xuICBsZXQgdGVybWluYXRlT25EZXN0cm95ID0gdHJ1ZTtcblxuICBjb25zdCBkdXBsZXggPSBuZXcgRHVwbGV4KHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGF1dG9EZXN0cm95OiBmYWxzZSxcbiAgICBlbWl0Q2xvc2U6IGZhbHNlLFxuICAgIG9iamVjdE1vZGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlT2JqZWN0TW9kZTogZmFsc2VcbiAgfSk7XG5cbiAgd3Mub24oJ21lc3NhZ2UnLCBmdW5jdGlvbiBtZXNzYWdlKG1zZywgaXNCaW5hcnkpIHtcbiAgICBjb25zdCBkYXRhID1cbiAgICAgICFpc0JpbmFyeSAmJiBkdXBsZXguX3JlYWRhYmxlU3RhdGUub2JqZWN0TW9kZSA/IG1zZy50b1N0cmluZygpIDogbXNnO1xuXG4gICAgaWYgKCFkdXBsZXgucHVzaChkYXRhKSkgd3MucGF1c2UoKTtcbiAgfSk7XG5cbiAgd3Mub25jZSgnZXJyb3InLCBmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgICBpZiAoZHVwbGV4LmRlc3Ryb3llZCkgcmV0dXJuO1xuXG4gICAgLy8gUHJldmVudCBgd3MudGVybWluYXRlKClgIGZyb20gYmVpbmcgY2FsbGVkIGJ5IGBkdXBsZXguX2Rlc3Ryb3koKWAuXG4gICAgLy9cbiAgICAvLyAtIElmIHRoZSBgJ2Vycm9yJ2AgZXZlbnQgaXMgZW1pdHRlZCBiZWZvcmUgdGhlIGAnb3BlbidgIGV2ZW50LCB0aGVuXG4gICAgLy8gICBgd3MudGVybWluYXRlKClgIGlzIGEgbm9vcCBhcyBubyBzb2NrZXQgaXMgYXNzaWduZWQuXG4gICAgLy8gLSBPdGhlcndpc2UsIHRoZSBlcnJvciBpcyByZS1lbWl0dGVkIGJ5IHRoZSBsaXN0ZW5lciBvZiB0aGUgYCdlcnJvcidgXG4gICAgLy8gICBldmVudCBvZiB0aGUgYFJlY2VpdmVyYCBvYmplY3QuIFRoZSBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlcyB0aGVcbiAgICAvLyAgIGNvbm5lY3Rpb24gYnkgY2FsbGluZyBgd3MuY2xvc2UoKWAuIFRoaXMgYWxsb3dzIGEgY2xvc2UgZnJhbWUgdG8gYmVcbiAgICAvLyAgIHNlbnQgdG8gdGhlIG90aGVyIHBlZXIuIElmIGB3cy50ZXJtaW5hdGUoKWAgaXMgY2FsbGVkIHJpZ2h0IGFmdGVyIHRoaXMsXG4gICAgLy8gICB0aGVuIHRoZSBjbG9zZSBmcmFtZSBtaWdodCBub3QgYmUgc2VudC5cbiAgICB0ZXJtaW5hdGVPbkRlc3Ryb3kgPSBmYWxzZTtcbiAgICBkdXBsZXguZGVzdHJveShlcnIpO1xuICB9KTtcblxuICB3cy5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGlmIChkdXBsZXguZGVzdHJveWVkKSByZXR1cm47XG5cbiAgICBkdXBsZXgucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgZHVwbGV4Ll9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2FsbGJhY2spIHtcbiAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gd3MuQ0xPU0VEKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIGR1cGxleCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuXG4gICAgd3Mub25jZSgnZXJyb3InLCBmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xuXG4gICAgd3Mub25jZSgnY2xvc2UnLCBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIGlmICghY2FsbGVkKSBjYWxsYmFjayhlcnIpO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIGR1cGxleCk7XG4gICAgfSk7XG5cbiAgICBpZiAodGVybWluYXRlT25EZXN0cm95KSB3cy50ZXJtaW5hdGUoKTtcbiAgfTtcblxuICBkdXBsZXguX2ZpbmFsID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNPTk5FQ1RJTkcpIHtcbiAgICAgIHdzLm9uY2UoJ29wZW4nLCBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICBkdXBsZXguX2ZpbmFsKGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSB2YWx1ZSBvZiB0aGUgYF9zb2NrZXRgIHByb3BlcnR5IGlzIGBudWxsYCBpdCBtZWFucyB0aGF0IGB3c2AgaXMgYVxuICAgIC8vIGNsaWVudCB3ZWJzb2NrZXQgYW5kIHRoZSBoYW5kc2hha2UgZmFpbGVkLiBJbiBmYWN0LCB3aGVuIHRoaXMgaGFwcGVucywgYVxuICAgIC8vIHNvY2tldCBpcyBuZXZlciBhc3NpZ25lZCB0byB0aGUgd2Vic29ja2V0LiBXYWl0IGZvciB0aGUgYCdlcnJvcidgIGV2ZW50XG4gICAgLy8gdGhhdCB3aWxsIGJlIGVtaXR0ZWQgYnkgdGhlIHdlYnNvY2tldC5cbiAgICBpZiAod3MuX3NvY2tldCA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgaWYgKHdzLl9zb2NrZXQuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQpIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICBpZiAoZHVwbGV4Ll9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIGR1cGxleC5kZXN0cm95KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdzLl9zb2NrZXQub25jZSgnZmluaXNoJywgZnVuY3Rpb24gZmluaXNoKCkge1xuICAgICAgICAvLyBgZHVwbGV4YCBpcyBub3QgZGVzdHJveWVkIGhlcmUgYmVjYXVzZSB0aGUgYCdlbmQnYCBldmVudCB3aWxsIGJlXG4gICAgICAgIC8vIGVtaXR0ZWQgb24gYGR1cGxleGAgYWZ0ZXIgdGhpcyBgJ2ZpbmlzaCdgIGV2ZW50LiBUaGUgRU9GIHNpZ25hbGluZ1xuICAgICAgICAvLyBgbnVsbGAgY2h1bmsgaXMsIGluIGZhY3QsIHB1c2hlZCB3aGVuIHRoZSB3ZWJzb2NrZXQgZW1pdHMgYCdjbG9zZSdgLlxuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgICB3cy5jbG9zZSgpO1xuICAgIH1cbiAgfTtcblxuICBkdXBsZXguX3JlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHdzLmlzUGF1c2VkKSB3cy5yZXN1bWUoKTtcbiAgfTtcblxuICBkdXBsZXguX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gd3MuQ09OTkVDVElORykge1xuICAgICAgd3Mub25jZSgnb3BlbicsIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICAgIGR1cGxleC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3cy5zZW5kKGNodW5rLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgZHVwbGV4Lm9uKCdlbmQnLCBkdXBsZXhPbkVuZCk7XG4gIGR1cGxleC5vbignZXJyb3InLCBkdXBsZXhPbkVycm9yKTtcbiAgcmV0dXJuIGR1cGxleDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVXZWJTb2NrZXRTdHJlYW07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IHRva2VuQ2hhcnMgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2xgIGhlYWRlciBpbnRvIGEgc2V0IG9mIHN1YnByb3RvY29sIG5hbWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGZpZWxkIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAqIEByZXR1cm4ge1NldH0gVGhlIHN1YnByb3RvY29sIG5hbWVzXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKGhlYWRlcikge1xuICBjb25zdCBwcm90b2NvbHMgPSBuZXcgU2V0KCk7XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgZW5kID0gLTE7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKGk7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGkgIT09IDAgJiZcbiAgICAgIChjb2RlID09PSAweDIwIC8qICcgJyAqLyB8fCBjb2RlID09PSAweDA5KSAvKiAnXFx0JyAqL1xuICAgICkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyYyAvKiAnLCcgKi8pIHtcbiAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuXG4gICAgICBjb25zdCBwcm90b2NvbCA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcblxuICAgICAgaWYgKHByb3RvY29scy5oYXMocHJvdG9jb2wpKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIFwiJHtwcm90b2NvbH1cIiBzdWJwcm90b2NvbCBpcyBkdXBsaWNhdGVkYCk7XG4gICAgICB9XG5cbiAgICAgIHByb3RvY29scy5hZGQocHJvdG9jb2wpO1xuICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgIT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuICB9XG5cbiAgY29uc3QgcHJvdG9jb2wgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGkpO1xuXG4gIGlmIChwcm90b2NvbHMuaGFzKHByb3RvY29sKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIFwiJHtwcm90b2NvbH1cIiBzdWJwcm90b2NvbCBpcyBkdXBsaWNhdGVkYCk7XG4gIH1cblxuICBwcm90b2NvbHMuYWRkKHByb3RvY29sKTtcbiAgcmV0dXJuIHByb3RvY29scztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IHBhcnNlIH07XG4iLCAiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJeRHVwbGV4JFwiLCBcImNhdWdodEVycm9yc1wiOiBcIm5vbmVcIiB9XSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IHsgRHVwbGV4IH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgY3JlYXRlSGFzaCB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbmNvbnN0IGV4dGVuc2lvbiA9IHJlcXVpcmUoJy4vZXh0ZW5zaW9uJyk7XG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBzdWJwcm90b2NvbCA9IHJlcXVpcmUoJy4vc3VicHJvdG9jb2wnKTtcbmNvbnN0IFdlYlNvY2tldCA9IHJlcXVpcmUoJy4vd2Vic29ja2V0Jyk7XG5jb25zdCB7IENMT1NFX1RJTUVPVVQsIEdVSUQsIGtXZWJTb2NrZXQgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IGtleVJlZ2V4ID0gL15bKy8wLTlBLVphLXpdezIyfT09JC87XG5cbmNvbnN0IFJVTk5JTkcgPSAwO1xuY29uc3QgQ0xPU0lORyA9IDE7XG5jb25zdCBDTE9TRUQgPSAyO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIFdlYlNvY2tldCBzZXJ2ZXIuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFdlYlNvY2tldFNlcnZlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBgV2ViU29ja2V0U2VydmVyYCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cz10cnVlXSBTcGVjaWZpZXMgd2hldGhlclxuICAgKiAgICAgYW55IG9mIHRoZSBgJ21lc3NhZ2UnYCwgYCdwaW5nJ2AsIGFuZCBgJ3BvbmcnYCBldmVudHMgY2FuIGJlIGVtaXR0ZWRcbiAgICogICAgIG11bHRpcGxlIHRpbWVzIGluIHRoZSBzYW1lIHRpY2tcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvUG9uZz10cnVlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG9cbiAgICogICAgIGF1dG9tYXRpY2FsbHkgc2VuZCBhIHBvbmcgaW4gcmVzcG9uc2UgdG8gYSBwaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5iYWNrbG9nPTUxMV0gVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBxdWV1ZSBvZlxuICAgKiAgICAgcGVuZGluZyBjb25uZWN0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsaWVudFRyYWNraW5nPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICAgKiAgICAgdHJhY2sgY2xpZW50c1xuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY2xvc2VUaW1lb3V0PTMwMDAwXSBEdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgdG9cbiAgICogICAgIHdhaXQgZm9yIHRoZSBjbG9zaW5nIGhhbmRzaGFrZSB0byBmaW5pc2ggYWZ0ZXIgYHdlYnNvY2tldC5jbG9zZSgpYCBpc1xuICAgKiAgICAgY2FsbGVkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmhhbmRsZVByb3RvY29sc10gQSBob29rIHRvIGhhbmRsZSBwcm90b2NvbHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmhvc3RdIFRoZSBob3N0bmFtZSB3aGVyZSB0byBiaW5kIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MTA0ODU3NjAwXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2VcbiAgICogICAgIHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ub1NlcnZlcj1mYWxzZV0gRW5hYmxlIG5vIHNlcnZlciBtb2RlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXRoXSBBY2NlcHQgb25seSBjb25uZWN0aW9ucyBtYXRjaGluZyB0aGlzIHBhdGhcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxPYmplY3QpfSBbb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZT1mYWxzZV0gRW5hYmxlL2Rpc2FibGVcbiAgICogICAgIHBlcm1lc3NhZ2UtZGVmbGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucG9ydF0gVGhlIHBvcnQgd2hlcmUgdG8gYmluZCB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7KGh0dHAuU2VydmVyfGh0dHBzLlNlcnZlcil9IFtvcHRpb25zLnNlcnZlcl0gQSBwcmUtY3JlYXRlZCBIVFRQL1NcbiAgICogICAgIHNlcnZlciB0byB1c2VcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG4gICAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy52ZXJpZnlDbGllbnRdIEEgaG9vayB0byByZWplY3QgY29ubmVjdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuV2ViU29ja2V0PVdlYlNvY2tldF0gU3BlY2lmaWVzIHRoZSBgV2ViU29ja2V0YFxuICAgKiAgICAgY2xhc3MgdG8gdXNlLiBJdCBtdXN0IGJlIHRoZSBgV2ViU29ja2V0YCBjbGFzcyBvciBjbGFzcyB0aGF0IGV4dGVuZHMgaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBBIGxpc3RlbmVyIGZvciB0aGUgYGxpc3RlbmluZ2AgZXZlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIG9wdGlvbnMgPSB7XG4gICAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiB0cnVlLFxuICAgICAgYXV0b1Bvbmc6IHRydWUsXG4gICAgICBtYXhQYXlsb2FkOiAxMDAgKiAxMDI0ICogMTAyNCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogZmFsc2UsXG4gICAgICBwZXJNZXNzYWdlRGVmbGF0ZTogZmFsc2UsXG4gICAgICBoYW5kbGVQcm90b2NvbHM6IG51bGwsXG4gICAgICBjbGllbnRUcmFja2luZzogdHJ1ZSxcbiAgICAgIGNsb3NlVGltZW91dDogQ0xPU0VfVElNRU9VVCxcbiAgICAgIHZlcmlmeUNsaWVudDogbnVsbCxcbiAgICAgIG5vU2VydmVyOiBmYWxzZSxcbiAgICAgIGJhY2tsb2c6IG51bGwsIC8vIHVzZSBkZWZhdWx0ICg1MTEgYXMgaW1wbGVtZW50ZWQgaW4gbmV0LmpzKVxuICAgICAgc2VydmVyOiBudWxsLFxuICAgICAgaG9zdDogbnVsbCxcbiAgICAgIHBhdGg6IG51bGwsXG4gICAgICBwb3J0OiBudWxsLFxuICAgICAgV2ViU29ja2V0LFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICBpZiAoXG4gICAgICAob3B0aW9ucy5wb3J0ID09IG51bGwgJiYgIW9wdGlvbnMuc2VydmVyICYmICFvcHRpb25zLm5vU2VydmVyKSB8fFxuICAgICAgKG9wdGlvbnMucG9ydCAhPSBudWxsICYmIChvcHRpb25zLnNlcnZlciB8fCBvcHRpb25zLm5vU2VydmVyKSkgfHxcbiAgICAgIChvcHRpb25zLnNlcnZlciAmJiBvcHRpb25zLm5vU2VydmVyKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ09uZSBhbmQgb25seSBvbmUgb2YgdGhlIFwicG9ydFwiLCBcInNlcnZlclwiLCBvciBcIm5vU2VydmVyXCIgb3B0aW9ucyAnICtcbiAgICAgICAgICAnbXVzdCBiZSBzcGVjaWZpZWQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnBvcnQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5fc2VydmVyID0gaHR0cC5jcmVhdGVTZXJ2ZXIoKHJlcSwgcmVzKSA9PiB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBodHRwLlNUQVRVU19DT0RFU1s0MjZdO1xuXG4gICAgICAgIHJlcy53cml0ZUhlYWQoNDI2LCB7XG4gICAgICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogYm9keS5sZW5ndGgsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L3BsYWluJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzLmVuZChib2R5KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2VydmVyLmxpc3RlbihcbiAgICAgICAgb3B0aW9ucy5wb3J0LFxuICAgICAgICBvcHRpb25zLmhvc3QsXG4gICAgICAgIG9wdGlvbnMuYmFja2xvZyxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnNlcnZlcikge1xuICAgICAgdGhpcy5fc2VydmVyID0gb3B0aW9ucy5zZXJ2ZXI7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NlcnZlcikge1xuICAgICAgY29uc3QgZW1pdENvbm5lY3Rpb24gPSB0aGlzLmVtaXQuYmluZCh0aGlzLCAnY29ubmVjdGlvbicpO1xuXG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSBhZGRMaXN0ZW5lcnModGhpcy5fc2VydmVyLCB7XG4gICAgICAgIGxpc3RlbmluZzogdGhpcy5lbWl0LmJpbmQodGhpcywgJ2xpc3RlbmluZycpLFxuICAgICAgICBlcnJvcjogdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Vycm9yJyksXG4gICAgICAgIHVwZ3JhZGU6IChyZXEsIHNvY2tldCwgaGVhZCkgPT4ge1xuICAgICAgICAgIHRoaXMuaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgZW1pdENvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9PT0gdHJ1ZSkgb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xuICAgIGlmIChvcHRpb25zLmNsaWVudFRyYWNraW5nKSB7XG4gICAgICB0aGlzLmNsaWVudHMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLl9zaG91bGRFbWl0Q2xvc2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX3N0YXRlID0gUlVOTklORztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBib3VuZCBhZGRyZXNzLCB0aGUgYWRkcmVzcyBmYW1pbHkgbmFtZSwgYW5kIHBvcnQgb2YgdGhlIHNlcnZlclxuICAgKiBhcyByZXBvcnRlZCBieSB0aGUgb3BlcmF0aW5nIHN5c3RlbSBpZiBsaXN0ZW5pbmcgb24gYW4gSVAgc29ja2V0LlxuICAgKiBJZiB0aGUgc2VydmVyIGlzIGxpc3RlbmluZyBvbiBhIHBpcGUgb3IgVU5JWCBkb21haW4gc29ja2V0LCB0aGUgbmFtZSBpc1xuICAgKiByZXR1cm5lZCBhcyBhIHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybiB7KE9iamVjdHxTdHJpbmd8bnVsbCl9IFRoZSBhZGRyZXNzIG9mIHRoZSBzZXJ2ZXJcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWRkcmVzcygpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm5vU2VydmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzZXJ2ZXIgaXMgb3BlcmF0aW5nIGluIFwibm9TZXJ2ZXJcIiBtb2RlJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9zZXJ2ZXIpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLl9zZXJ2ZXIuYWRkcmVzcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgdGhlIHNlcnZlciBmcm9tIGFjY2VwdGluZyBuZXcgY29ubmVjdGlvbnMgYW5kIGVtaXQgdGhlIGAnY2xvc2UnYCBldmVudFxuICAgKiB3aGVuIGFsbCBleGlzdGluZyBjb25uZWN0aW9ucyBhcmUgY2xvc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIEEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIHRoZSBgJ2Nsb3NlJ2AgZXZlbnRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY2IpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IENMT1NFRCkge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRoaXMub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgY2IobmV3IEVycm9yKCdUaGUgc2VydmVyIGlzIG5vdCBydW5uaW5nJykpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjYikgdGhpcy5vbmNlKCdjbG9zZScsIGNiKTtcblxuICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gQ0xPU0lORykgcmV0dXJuO1xuICAgIHRoaXMuX3N0YXRlID0gQ0xPU0lORztcblxuICAgIGlmICh0aGlzLm9wdGlvbnMubm9TZXJ2ZXIgfHwgdGhpcy5vcHRpb25zLnNlcnZlcikge1xuICAgICAgaWYgKHRoaXMuX3NlcnZlcikge1xuICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gdGhpcy5fc2VydmVyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2xpZW50cykge1xuICAgICAgICBpZiAoIXRoaXMuY2xpZW50cy5zaXplKSB7XG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3Nob3VsZEVtaXRDbG9zZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2VydmVyID0gdGhpcy5fc2VydmVyO1xuXG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3NlcnZlciA9IG51bGw7XG5cbiAgICAgIC8vXG4gICAgICAvLyBUaGUgSFRUUC9TIHNlcnZlciB3YXMgY3JlYXRlZCBpbnRlcm5hbGx5LiBDbG9zZSBpdCwgYW5kIHJlbHkgb24gaXRzXG4gICAgICAvLyBgJ2Nsb3NlJ2AgZXZlbnQuXG4gICAgICAvL1xuICAgICAgc2VydmVyLmNsb3NlKCgpID0+IHtcbiAgICAgICAgZW1pdENsb3NlKHRoaXMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlZSBpZiBhIGdpdmVuIHJlcXVlc3Qgc2hvdWxkIGJlIGhhbmRsZWQgYnkgdGhpcyBzZXJ2ZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBSZXF1ZXN0IG9iamVjdCB0byBpbnNwZWN0XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcmVxdWVzdCBpcyB2YWxpZCwgZWxzZSBgZmFsc2VgXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNob3VsZEhhbmRsZShyZXEpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnBhdGgpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gcmVxLnVybC5pbmRleE9mKCc/Jyk7XG4gICAgICBjb25zdCBwYXRobmFtZSA9IGluZGV4ICE9PSAtMSA/IHJlcS51cmwuc2xpY2UoMCwgaW5kZXgpIDogcmVxLnVybDtcblxuICAgICAgaWYgKHBhdGhuYW1lICE9PSB0aGlzLm9wdGlvbnMucGF0aCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIEhUVFAgVXBncmFkZSByZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBoYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIGNvbnN0IGtleSA9IHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWtleSddO1xuICAgIGNvbnN0IHVwZ3JhZGUgPSByZXEuaGVhZGVycy51cGdyYWRlO1xuICAgIGNvbnN0IHZlcnNpb24gPSArcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtdmVyc2lvbiddO1xuXG4gICAgaWYgKHJlcS5tZXRob2QgIT09ICdHRVQnKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgSFRUUCBtZXRob2QnO1xuICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDUsIG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh1cGdyYWRlID09PSB1bmRlZmluZWQgfHwgdXBncmFkZS50b0xvd2VyQ2FzZSgpICE9PSAnd2Vic29ja2V0Jykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIFVwZ3JhZGUgaGVhZGVyJztcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQgfHwgIWtleVJlZ2V4LnRlc3Qoa2V5KSkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdNaXNzaW5nIG9yIGludmFsaWQgU2VjLVdlYlNvY2tldC1LZXkgaGVhZGVyJztcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbiAhPT0gMTMgJiYgdmVyc2lvbiAhPT0gOCkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdNaXNzaW5nIG9yIGludmFsaWQgU2VjLVdlYlNvY2tldC1WZXJzaW9uIGhlYWRlcic7XG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSwge1xuICAgICAgICAnU2VjLVdlYlNvY2tldC1WZXJzaW9uJzogJzEzLCA4J1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnNob3VsZEhhbmRsZShyZXEpKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2VjV2ViU29ja2V0UHJvdG9jb2wgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuICAgIGxldCBwcm90b2NvbHMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAoc2VjV2ViU29ja2V0UHJvdG9jb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcHJvdG9jb2xzID0gc3VicHJvdG9jb2wucGFyc2Uoc2VjV2ViU29ja2V0UHJvdG9jb2wpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBTZWMtV2ViU29ja2V0LVByb3RvY29sIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJ107XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5vcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlICYmXG4gICAgICBzZWNXZWJTb2NrZXRFeHRlbnNpb25zICE9PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gbmV3IFBlck1lc3NhZ2VEZWZsYXRlKFxuICAgICAgICB0aGlzLm9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUsXG4gICAgICAgIHRydWUsXG4gICAgICAgIHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkXG4gICAgICApO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvZmZlcnMgPSBleHRlbnNpb24ucGFyc2Uoc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyk7XG5cbiAgICAgICAgaWYgKG9mZmVyc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLmFjY2VwdChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pO1xuICAgICAgICAgIGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0gPSBwZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPVxuICAgICAgICAgICdJbnZhbGlkIG9yIHVuYWNjZXB0YWJsZSBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyJztcbiAgICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDAsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBPcHRpb25hbGx5IGNhbGwgZXh0ZXJuYWwgY2xpZW50IHZlcmlmaWNhdGlvbiBoYW5kbGVyLlxuICAgIC8vXG4gICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQpIHtcbiAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgIG9yaWdpbjpcbiAgICAgICAgICByZXEuaGVhZGVyc1tgJHt2ZXJzaW9uID09PSA4ID8gJ3NlYy13ZWJzb2NrZXQtb3JpZ2luJyA6ICdvcmlnaW4nfWBdLFxuICAgICAgICBzZWN1cmU6ICEhKHJlcS5zb2NrZXQuYXV0aG9yaXplZCB8fCByZXEuc29ja2V0LmVuY3J5cHRlZCksXG4gICAgICAgIHJlcVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbywgKHZlcmlmaWVkLCBjb2RlLCBtZXNzYWdlLCBoZWFkZXJzKSA9PiB7XG4gICAgICAgICAgaWYgKCF2ZXJpZmllZCkge1xuICAgICAgICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSB8fCA0MDEsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuY29tcGxldGVVcGdyYWRlKFxuICAgICAgICAgICAgZXh0ZW5zaW9ucyxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHByb3RvY29scyxcbiAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgIHNvY2tldCxcbiAgICAgICAgICAgIGhlYWQsXG4gICAgICAgICAgICBjYlxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnZlcmlmeUNsaWVudChpbmZvKSkgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNDAxKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBsZXRlVXBncmFkZShleHRlbnNpb25zLCBrZXksIHByb3RvY29scywgcmVxLCBzb2NrZXQsIGhlYWQsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGdyYWRlIHRoZSBjb25uZWN0aW9uIHRvIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dGVuc2lvbnMgVGhlIGFjY2VwdGVkIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgdmFsdWUgb2YgdGhlIGBTZWMtV2ViU29ja2V0LUtleWAgaGVhZGVyXG4gICAqIEBwYXJhbSB7U2V0fSBwcm90b2NvbHMgVGhlIHN1YnByb3RvY29sc1xuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlIHNlcnZlciBhbmQgY2xpZW50XG4gICAqIEBwYXJhbSB7QnVmZmVyfSBoZWFkIFRoZSBmaXJzdCBwYWNrZXQgb2YgdGhlIHVwZ3JhZGVkIHN0cmVhbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIHdpdGggdGhlIHNhbWUgc29ja2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb21wbGV0ZVVwZ3JhZGUoZXh0ZW5zaW9ucywga2V5LCBwcm90b2NvbHMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYikge1xuICAgIC8vXG4gICAgLy8gRGVzdHJveSB0aGUgc29ja2V0IGlmIHRoZSBjbGllbnQgaGFzIGFscmVhZHkgc2VudCBhIEZJTiBwYWNrZXQuXG4gICAgLy9cbiAgICBpZiAoIXNvY2tldC5yZWFkYWJsZSB8fCAhc29ja2V0LndyaXRhYmxlKSByZXR1cm4gc29ja2V0LmRlc3Ryb3koKTtcblxuICAgIGlmIChzb2NrZXRba1dlYlNvY2tldF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3NlcnZlci5oYW5kbGVVcGdyYWRlKCkgd2FzIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB3aXRoIHRoZSBzYW1lICcgK1xuICAgICAgICAgICdzb2NrZXQsIHBvc3NpYmx5IGR1ZSB0byBhIG1pc2NvbmZpZ3VyYXRpb24nXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdGF0ZSA+IFJVTk5JTkcpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDUwMyk7XG5cbiAgICBjb25zdCBkaWdlc3QgPSBjcmVhdGVIYXNoKCdzaGExJylcbiAgICAgIC51cGRhdGUoa2V5ICsgR1VJRClcbiAgICAgIC5kaWdlc3QoJ2Jhc2U2NCcpO1xuXG4gICAgY29uc3QgaGVhZGVycyA9IFtcbiAgICAgICdIVFRQLzEuMSAxMDEgU3dpdGNoaW5nIFByb3RvY29scycsXG4gICAgICAnVXBncmFkZTogd2Vic29ja2V0JyxcbiAgICAgICdDb25uZWN0aW9uOiBVcGdyYWRlJyxcbiAgICAgIGBTZWMtV2ViU29ja2V0LUFjY2VwdDogJHtkaWdlc3R9YFxuICAgIF07XG5cbiAgICBjb25zdCB3cyA9IG5ldyB0aGlzLm9wdGlvbnMuV2ViU29ja2V0KG51bGwsIHVuZGVmaW5lZCwgdGhpcy5vcHRpb25zKTtcblxuICAgIGlmIChwcm90b2NvbHMuc2l6ZSkge1xuICAgICAgLy9cbiAgICAgIC8vIE9wdGlvbmFsbHkgY2FsbCBleHRlcm5hbCBwcm90b2NvbCBzZWxlY3Rpb24gaGFuZGxlci5cbiAgICAgIC8vXG4gICAgICBjb25zdCBwcm90b2NvbCA9IHRoaXMub3B0aW9ucy5oYW5kbGVQcm90b2NvbHNcbiAgICAgICAgPyB0aGlzLm9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzKHByb3RvY29scywgcmVxKVxuICAgICAgICA6IHByb3RvY29scy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG5cbiAgICAgIGlmIChwcm90b2NvbCkge1xuICAgICAgICBoZWFkZXJzLnB1c2goYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2w6ICR7cHJvdG9jb2x9YCk7XG4gICAgICAgIHdzLl9wcm90b2NvbCA9IHByb3RvY29sO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdLnBhcmFtcztcbiAgICAgIGNvbnN0IHZhbHVlID0gZXh0ZW5zaW9uLmZvcm1hdCh7XG4gICAgICAgIFtQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTogW3BhcmFtc11cbiAgICAgIH0pO1xuICAgICAgaGVhZGVycy5wdXNoKGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnM6ICR7dmFsdWV9YCk7XG4gICAgICB3cy5fZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBBbGxvdyBleHRlcm5hbCBtb2RpZmljYXRpb24vaW5zcGVjdGlvbiBvZiBoYW5kc2hha2UgaGVhZGVycy5cbiAgICAvL1xuICAgIHRoaXMuZW1pdCgnaGVhZGVycycsIGhlYWRlcnMsIHJlcSk7XG5cbiAgICBzb2NrZXQud3JpdGUoaGVhZGVycy5jb25jYXQoJ1xcclxcbicpLmpvaW4oJ1xcclxcbicpKTtcbiAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICB3cy5zZXRTb2NrZXQoc29ja2V0LCBoZWFkLCB7XG4gICAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiB0aGlzLm9wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cyxcbiAgICAgIG1heFBheWxvYWQ6IHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkLFxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiB0aGlzLm9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5jbGllbnRzKSB7XG4gICAgICB0aGlzLmNsaWVudHMuYWRkKHdzKTtcbiAgICAgIHdzLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgdGhpcy5jbGllbnRzLmRlbGV0ZSh3cyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZEVtaXRDbG9zZSAmJiAhdGhpcy5jbGllbnRzLnNpemUpIHtcbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNiKHdzLCByZXEpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0U2VydmVyO1xuXG4vKipcbiAqIEFkZCBldmVudCBsaXN0ZW5lcnMgb24gYW4gYEV2ZW50RW1pdHRlcmAgdXNpbmcgYSBtYXAgb2YgPGV2ZW50LCBsaXN0ZW5lcj5cbiAqIHBhaXJzLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBzZXJ2ZXIgVGhlIGV2ZW50IGVtaXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0LjxTdHJpbmcsIEZ1bmN0aW9uPn0gbWFwIFRoZSBsaXN0ZW5lcnMgdG8gYWRkXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgcmVtb3ZlIHRoZSBhZGRlZCBsaXN0ZW5lcnMgd2hlblxuICogICAgIGNhbGxlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXJzKHNlcnZlciwgbWFwKSB7XG4gIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkgc2VydmVyLm9uKGV2ZW50LCBtYXBbZXZlbnRdKTtcblxuICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkge1xuICAgICAgc2VydmVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBtYXBbZXZlbnRdKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogRW1pdCBhIGAnY2xvc2UnYCBldmVudCBvbiBhbiBgRXZlbnRFbWl0dGVyYC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0Q2xvc2Uoc2VydmVyKSB7XG4gIHNlcnZlci5fc3RhdGUgPSBDTE9TRUQ7XG4gIHNlcnZlci5lbWl0KCdjbG9zZScpO1xufVxuXG4vKipcbiAqIEhhbmRsZSBzb2NrZXQgZXJyb3JzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XG4gIHRoaXMuZGVzdHJveSgpO1xufVxuXG4vKipcbiAqIENsb3NlIHRoZSBjb25uZWN0aW9uIHdoZW4gcHJlY29uZGl0aW9ucyBhcmUgbm90IGZ1bGZpbGxlZC5cbiAqXG4gKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBzb2NrZXQgb2YgdGhlIHVwZ3JhZGUgcmVxdWVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gVGhlIEhUVFAgcmVzcG9uc2UgYm9keVxuICogQHBhcmFtIHtPYmplY3R9IFtoZWFkZXJzXSBBZGRpdGlvbmFsIEhUVFAgcmVzcG9uc2UgaGVhZGVyc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlLCBtZXNzYWdlLCBoZWFkZXJzKSB7XG4gIC8vXG4gIC8vIFRoZSBzb2NrZXQgaXMgd3JpdGFibGUgdW5sZXNzIHRoZSB1c2VyIGRlc3Ryb3llZCBvciBlbmRlZCBpdCBiZWZvcmUgY2FsbGluZ1xuICAvLyBgc2VydmVyLmhhbmRsZVVwZ3JhZGUoKWAgb3IgaW4gdGhlIGB2ZXJpZnlDbGllbnRgIGZ1bmN0aW9uLCB3aGljaCBpcyBhIHVzZXJcbiAgLy8gZXJyb3IuIEhhbmRsaW5nIHRoaXMgZG9lcyBub3QgbWFrZSBtdWNoIHNlbnNlIGFzIHRoZSB3b3JzdCB0aGF0IGNhbiBoYXBwZW5cbiAgLy8gaXMgdGhhdCBzb21lIG9mIHRoZSBkYXRhIHdyaXR0ZW4gYnkgdGhlIHVzZXIgbWlnaHQgYmUgZGlzY2FyZGVkIGR1ZSB0byB0aGVcbiAgLy8gY2FsbCB0byBgc29ja2V0LmVuZCgpYCBiZWxvdywgd2hpY2ggdHJpZ2dlcnMgYW4gYCdlcnJvcidgIGV2ZW50IHRoYXQgaW5cbiAgLy8gdHVybiBjYXVzZXMgdGhlIHNvY2tldCB0byBiZSBkZXN0cm95ZWQuXG4gIC8vXG4gIG1lc3NhZ2UgPSBtZXNzYWdlIHx8IGh0dHAuU1RBVFVTX0NPREVTW2NvZGVdO1xuICBoZWFkZXJzID0ge1xuICAgIENvbm5lY3Rpb246ICdjbG9zZScsXG4gICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L2h0bWwnLFxuICAgICdDb250ZW50LUxlbmd0aCc6IEJ1ZmZlci5ieXRlTGVuZ3RoKG1lc3NhZ2UpLFxuICAgIC4uLmhlYWRlcnNcbiAgfTtcblxuICBzb2NrZXQub25jZSgnZmluaXNoJywgc29ja2V0LmRlc3Ryb3kpO1xuXG4gIHNvY2tldC5lbmQoXG4gICAgYEhUVFAvMS4xICR7Y29kZX0gJHtodHRwLlNUQVRVU19DT0RFU1tjb2RlXX1cXHJcXG5gICtcbiAgICAgIE9iamVjdC5rZXlzKGhlYWRlcnMpXG4gICAgICAgIC5tYXAoKGgpID0+IGAke2h9OiAke2hlYWRlcnNbaF19YClcbiAgICAgICAgLmpvaW4oJ1xcclxcbicpICtcbiAgICAgICdcXHJcXG5cXHJcXG4nICtcbiAgICAgIG1lc3NhZ2VcbiAgKTtcbn1cblxuLyoqXG4gKiBFbWl0IGEgYCd3c0NsaWVudEVycm9yJ2AgZXZlbnQgb24gYSBgV2ViU29ja2V0U2VydmVyYCBpZiB0aGVyZSBpcyBhdCBsZWFzdFxuICogb25lIGxpc3RlbmVyIGZvciBpdCwgb3RoZXJ3aXNlIGNhbGwgYGFib3J0SGFuZHNoYWtlKClgLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0U2VydmVyfSBzZXJ2ZXIgVGhlIFdlYlNvY2tldCBzZXJ2ZXJcbiAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcSBUaGUgcmVxdWVzdCBvYmplY3RcbiAqIEBwYXJhbSB7RHVwbGV4fSBzb2NrZXQgVGhlIHNvY2tldCBvZiB0aGUgdXBncmFkZSByZXF1ZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIEhUVFAgcmVzcG9uc2UgYm9keVxuICogQHBhcmFtIHtPYmplY3R9IFtoZWFkZXJzXSBUaGUgSFRUUCByZXNwb25zZSBoZWFkZXJzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IoXG4gIHNlcnZlcixcbiAgcmVxLFxuICBzb2NrZXQsXG4gIGNvZGUsXG4gIG1lc3NhZ2UsXG4gIGhlYWRlcnNcbikge1xuICBpZiAoc2VydmVyLmxpc3RlbmVyQ291bnQoJ3dzQ2xpZW50RXJyb3InKSkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcik7XG5cbiAgICBzZXJ2ZXIuZW1pdCgnd3NDbGllbnRFcnJvcicsIGVyciwgc29ja2V0LCByZXEpO1xuICB9IGVsc2Uge1xuICAgIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycyk7XG4gIH1cbn1cbiIsICJpbXBvcnQgY3JlYXRlV2ViU29ja2V0U3RyZWFtIGZyb20gJy4vbGliL3N0cmVhbS5qcyc7XG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSAnLi9saWIvcmVjZWl2ZXIuanMnO1xuaW1wb3J0IFNlbmRlciBmcm9tICcuL2xpYi9zZW5kZXIuanMnO1xuaW1wb3J0IFdlYlNvY2tldCBmcm9tICcuL2xpYi93ZWJzb2NrZXQuanMnO1xuaW1wb3J0IFdlYlNvY2tldFNlcnZlciBmcm9tICcuL2xpYi93ZWJzb2NrZXQtc2VydmVyLmpzJztcblxuZXhwb3J0IHsgY3JlYXRlV2ViU29ja2V0U3RyZWFtLCBSZWNlaXZlciwgU2VuZGVyLCBXZWJTb2NrZXQsIFdlYlNvY2tldFNlcnZlciB9O1xuZXhwb3J0IGRlZmF1bHQgV2ViU29ja2V0O1xuIiwgIi8qKlxuICogV2ViU29ja2V0IE1lc3NhZ2UgVHlwZXNcbiAqIERlZmluZXMgYWxsIG1lc3NhZ2UgdHlwZXMgZXhjaGFuZ2VkIGJldHdlZW4gT2JzaWRpYW4gcGx1Z2luIGFuZCBSZWxheSBTZXJ2ZXJcbiAqL1xuXG4vKipcbiAqIENvbm5lY3Rpb24gc3RhdGUgZW51bVxuICovXG5leHBvcnQgZW51bSBDb25uZWN0aW9uU3RhdGUge1xuICAgIERJU0NPTk5FQ1RFRCA9ICdkaXNjb25uZWN0ZWQnLFxuICAgIENPTk5FQ1RJTkcgPSAnY29ubmVjdGluZycsXG4gICAgQ09OTkVDVEVEID0gJ2Nvbm5lY3RlZCcsXG4gICAgUkVDT05ORUNUSU5HID0gJ3JlY29ubmVjdGluZycsXG4gICAgRVJST1IgPSAnZXJyb3InXG59XG5cbi8qKlxuICogQmFzZSBXZWJTb2NrZXQgbWVzc2FnZSBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBXU01lc3NhZ2Uge1xuICAgIHR5cGU6IHN0cmluZztcbiAgICBba2V5OiBzdHJpbmddOiBhbnk7XG59XG5cbi8qKlxuICogQ29ubmVjdGlvbiBjb25maXJtYXRpb24gbWVzc2FnZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbm5lY3RlZE1lc3NhZ2UgZXh0ZW5kcyBXU01lc3NhZ2Uge1xuICAgIHR5cGU6ICdjb25uZWN0ZWQnO1xuICAgIGNvbnZlcnNhdGlvbklkOiBzdHJpbmc7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJlY29ubmVjdGlvbiBjb25maXJtYXRpb24gbWVzc2FnZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlY29ubmVjdGVkTWVzc2FnZSBleHRlbmRzIFdTTWVzc2FnZSB7XG4gICAgdHlwZTogJ3JlY29ubmVjdGVkJztcbiAgICBjb252ZXJzYXRpb25JZDogc3RyaW5nO1xuICAgIG1lc3NhZ2U6IHN0cmluZztcbn1cblxuLyoqXG4gKiBVc2VyIG1lc3NhZ2UgZnJvbSBPYnNpZGlhbiB0byBDbGF1ZGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVc2VyTWVzc2FnZSBleHRlbmRzIFdTTWVzc2FnZSB7XG4gICAgdHlwZTogJ3VzZXJfbWVzc2FnZSc7XG4gICAgY29udmVyc2F0aW9uSWQ6IHN0cmluZztcbiAgICBjb250ZW50OiBzdHJpbmc7XG4gICAgY29udGV4dD86IE5vdGVDb250ZXh0O1xufVxuXG4vKipcbiAqIEFJIHN0cmVhbWluZyByZXNwb25zZSBmcm9tIENsYXVkZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFJU3RyZWFtTWVzc2FnZSBleHRlbmRzIFdTTWVzc2FnZSB7XG4gICAgdHlwZTogJ2FpX3N0cmVhbSc7XG4gICAgY29udmVyc2F0aW9uSWQ6IHN0cmluZztcbiAgICBjb250ZW50OiBzdHJpbmc7XG4gICAgaXNTdHJlYW1pbmc6IHRydWU7XG59XG5cbi8qKlxuICogQUkgY29tcGxldGlvbiBtZXNzYWdlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQUlEb25lTWVzc2FnZSBleHRlbmRzIFdTTWVzc2FnZSB7XG4gICAgdHlwZTogJ2FpX2RvbmUnO1xuICAgIGNvbnZlcnNhdGlvbklkOiBzdHJpbmc7XG4gICAgZmluYWxPdXRwdXQ6IHN0cmluZztcbn1cblxuLyoqXG4gKiBBSSBlcnJvciBtZXNzYWdlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQUlFcnJvck1lc3NhZ2UgZXh0ZW5kcyBXU01lc3NhZ2Uge1xuICAgIHR5cGU6ICdhaV9lcnJvcic7XG4gICAgY29udmVyc2F0aW9uSWQ6IHN0cmluZztcbiAgICBlcnJvcjogc3RyaW5nO1xufVxuXG4vKipcbiAqIE1DUCByZXF1ZXN0IG1lc3NhZ2UgKHRvb2wgY2FsbClcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNQ1BSZXF1ZXN0TWVzc2FnZSBleHRlbmRzIFdTTWVzc2FnZSB7XG4gICAgdHlwZTogJ21jcF9yZXF1ZXN0JztcbiAgICByZXF1ZXN0SWQ6IHN0cmluZztcbiAgICBtY3A6IE1DUFJlcXVlc3Q7XG59XG5cbi8qKlxuICogTUNQIHJlc3BvbnNlIG1lc3NhZ2UgKHRvb2wgcmVzdWx0KVxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1DUFJlc3BvbnNlTWVzc2FnZSBleHRlbmRzIFdTTWVzc2FnZSB7XG4gICAgdHlwZTogJ21jcF9yZXNwb25zZSc7XG4gICAgcmVxdWVzdElkOiBzdHJpbmc7XG4gICAgbWNwOiBNQ1BSZXNwb25zZTtcbn1cblxuLyoqXG4gKiBNQ1Agbm90aWZpY2F0aW9uIG1lc3NhZ2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNQ1BOb3RpZmljYXRpb25NZXNzYWdlIGV4dGVuZHMgV1NNZXNzYWdlIHtcbiAgICB0eXBlOiAnbWNwX25vdGlmaWNhdGlvbic7XG4gICAgbWNwOiBNQ1BOb3RpZmljYXRpb247XG59XG5cbi8qKlxuICogRXJyb3IgbWVzc2FnZSBmcm9tIHNlcnZlclxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVycm9yTWVzc2FnZSBleHRlbmRzIFdTTWVzc2FnZSB7XG4gICAgdHlwZTogJ2Vycm9yJztcbiAgICBtZXNzYWdlOiBzdHJpbmc7XG59XG5cbi8qKlxuICogTm90ZSBjb250ZXh0IGZvciB1c2VyIG1lc3NhZ2VzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTm90ZUNvbnRleHQge1xuICAgIGN1cnJlbnRGaWxlPzogc3RyaW5nO1xuICAgIHNlbGVjdGlvbj86IHN0cmluZztcbiAgICBmcm9udG1hdHRlcj86IGFueTtcbiAgICB0YWdzPzogc3RyaW5nW107XG59XG5cbi8qKlxuICogTUNQIFJlcXVlc3QgKEpTT04tUlBDIDIuMClcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNQ1BSZXF1ZXN0IHtcbiAgICBqc29ucnBjOiAnMi4wJztcbiAgICBpZDogc3RyaW5nIHwgbnVtYmVyO1xuICAgIG1ldGhvZDogc3RyaW5nO1xuICAgIHBhcmFtcz86IGFueTtcbn1cblxuLyoqXG4gKiBNQ1AgUmVzcG9uc2UgKEpTT04tUlBDIDIuMClcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNQ1BSZXNwb25zZSB7XG4gICAganNvbnJwYzogJzIuMCc7XG4gICAgaWQ6IHN0cmluZyB8IG51bWJlcjtcbiAgICByZXN1bHQ/OiBhbnk7XG4gICAgZXJyb3I/OiBNQ1BFcnJvcjtcbn1cblxuLyoqXG4gKiBNQ1AgTm90aWZpY2F0aW9uIChubyBpZClcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNQ1BOb3RpZmljYXRpb24ge1xuICAgIGpzb25ycGM6ICcyLjAnO1xuICAgIG1ldGhvZDogc3RyaW5nO1xuICAgIHBhcmFtcz86IGFueTtcbn1cblxuLyoqXG4gKiBNQ1AgRXJyb3JcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNQ1BFcnJvciB7XG4gICAgY29kZTogbnVtYmVyO1xuICAgIG1lc3NhZ2U6IHN0cmluZztcbiAgICBkYXRhPzogYW55O1xufVxuXG4vKipcbiAqIFdlYlNvY2tldCBDbGllbnQgRXZlbnRzXG4gKi9cbmV4cG9ydCB0eXBlIFdlYlNvY2tldEV2ZW50ID1cbiAgICB8IHsgZXZlbnQ6ICdvcGVuJzsgZGF0YTogdm9pZCB9XG4gICAgfCB7IGV2ZW50OiAnbWVzc2FnZSc7IGRhdGE6IFdTTWVzc2FnZSB9XG4gICAgfCB7IGV2ZW50OiAnZXJyb3InOyBkYXRhOiBFcnJvciB9XG4gICAgfCB7IGV2ZW50OiAnY2xvc2UnOyBkYXRhOiB7IGNvZGU6IG51bWJlcjsgcmVhc29uOiBzdHJpbmcgfSB9XG4gICAgfCB7IGV2ZW50OiAnc3RhdGVDaGFuZ2UnOyBkYXRhOiBDb25uZWN0aW9uU3RhdGUgfTtcblxuLyoqXG4gKiBXZWJTb2NrZXQgQ2xpZW50IENvbmZpZ3VyYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBXZWJTb2NrZXRDb25maWcge1xuICAgIHVybDogc3RyaW5nO1xuICAgIGNvbnZlcnNhdGlvbklkOiBzdHJpbmc7XG4gICAgYXV0b1JlY29ubmVjdD86IGJvb2xlYW47XG4gICAgcmVjb25uZWN0SW50ZXJ2YWw/OiBudW1iZXI7XG4gICAgbWF4UmV0cmllcz86IG51bWJlcjtcbiAgICBjb25uZWN0VGltZW91dD86IG51bWJlcjtcbn1cblxuLyoqXG4gKiBNZXNzYWdlIGNhbGxiYWNrIHR5cGVcbiAqL1xuZXhwb3J0IHR5cGUgTWVzc2FnZUNhbGxiYWNrID0gKG1lc3NhZ2U6IFdTTWVzc2FnZSkgPT4gdm9pZDtcblxuLyoqXG4gKiBFcnJvciBjYWxsYmFjayB0eXBlXG4gKi9cbmV4cG9ydCB0eXBlIEVycm9yQ2FsbGJhY2sgPSAoZXJyb3I6IEVycm9yKSA9PiB2b2lkO1xuXG4vKipcbiAqIFN0YXRlIGNoYW5nZSBjYWxsYmFjayB0eXBlXG4gKi9cbmV4cG9ydCB0eXBlIFN0YXRlQ2hhbmdlQ2FsbGJhY2sgPSAoc3RhdGU6IENvbm5lY3Rpb25TdGF0ZSkgPT4gdm9pZDtcbiIsICIvKipcbiAqIFdlYlNvY2tldCBDbGllbnRcbiAqIE1hbmFnZXMgV2ViU29ja2V0IGNvbm5lY3Rpb24gdG8gUmVsYXkgU2VydmVyIHdpdGggYXV0by1yZWNvbm5lY3RcbiAqL1xuXG5pbXBvcnQgeyBXZWJTb2NrZXQgfSBmcm9tICd3cyc7XG5pbXBvcnQge1xuICAgIENvbm5lY3Rpb25TdGF0ZSxcbiAgICBXU01lc3NhZ2UsXG4gICAgV2ViU29ja2V0Q29uZmlnLFxuICAgIE1lc3NhZ2VDYWxsYmFjayxcbiAgICBFcnJvckNhbGxiYWNrLFxuICAgIFN0YXRlQ2hhbmdlQ2FsbGJhY2tcbn0gZnJvbSAnLi93ZWJzb2NrZXQtdHlwZXMnO1xuXG4vKipcbiAqIFdlYlNvY2tldCBDbGllbnQgSW1wbGVtZW50YXRpb25cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYlNvY2tldENsaWVudCB7XG4gICAgcHJpdmF0ZSB3czogV2ViU29ja2V0IHwgbnVsbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBjb25maWc6IFdlYlNvY2tldENvbmZpZztcbiAgICBwcml2YXRlIHN0YXRlOiBDb25uZWN0aW9uU3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVEVEO1xuICAgIHByaXZhdGUgbWVzc2FnZUNhbGxiYWNrczogU2V0PE1lc3NhZ2VDYWxsYmFjaz4gPSBuZXcgU2V0KCk7XG4gICAgcHJpdmF0ZSBlcnJvckNhbGxiYWNrczogU2V0PEVycm9yQ2FsbGJhY2s+ID0gbmV3IFNldCgpO1xuICAgIHByaXZhdGUgc3RhdGVDaGFuZ2VDYWxsYmFja3M6IFNldDxTdGF0ZUNoYW5nZUNhbGxiYWNrPiA9IG5ldyBTZXQoKTtcbiAgICBwcml2YXRlIHJlY29ubmVjdFRpbWVyOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xuICAgIHByaXZhdGUgcmVjb25uZWN0QXR0ZW1wdHM6IG51bWJlciA9IDA7XG4gICAgcHJpdmF0ZSBpc01hbnVhbERpc2Nvbm5lY3Q6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZzogV2ViU29ja2V0Q29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAgICAgYXV0b1JlY29ubmVjdDogdHJ1ZSxcbiAgICAgICAgICAgIHJlY29ubmVjdEludGVydmFsOiA1MDAwLFxuICAgICAgICAgICAgbWF4UmV0cmllczogMTAsXG4gICAgICAgICAgICBjb25uZWN0VGltZW91dDogMTAwMDAsXG4gICAgICAgICAgICAuLi5jb25maWdcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25uZWN0IHRvIFdlYlNvY2tldCBzZXJ2ZXJcbiAgICAgKi9cbiAgICBhc3luYyBjb25uZWN0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRCB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RJTkcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNNYW51YWxEaXNjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RJTkcpO1xuXG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodGhpcy5jb25maWcudXJsKTtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2NvbnZlcnNhdGlvbklkJywgdGhpcy5jb25maWcuY29udmVyc2F0aW9uSWQpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgQ29ubmVjdGlvbiB0aW1lb3V0IGFmdGVyICR7dGhpcy5jb25maWcuY29ubmVjdFRpbWVvdXR9bXNgKSk7XG4gICAgICAgICAgICB9LCB0aGlzLmNvbmZpZy5jb25uZWN0VGltZW91dCk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cyA9IG5ldyBXZWJTb2NrZXQodXJsLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy53cy5vbignb3BlbicsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShDb25uZWN0aW9uU3RhdGUuQ09OTkVDVEVEKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFx1MjcwNSBXZWJTb2NrZXQgY29ubmVjdGVkIHRvICR7dGhpcy5jb25maWcudXJsfWApO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLndzLm9uKCdtZXNzYWdlJywgKGRhdGE6IEJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU1lc3NhZ2UoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLndzLm9uKCdlcnJvcicsIChlcnJvcjogRXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRoaXMud3Mub24oJ2Nsb3NlJywgKGNvZGU6IG51bWJlciwgcmVhc29uOiBCdWZmZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNsb3NlKGNvZGUsIHJlYXNvbi50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnJvciBhcyBFcnJvcik7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdCBmcm9tIHNlcnZlclxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaXNNYW51YWxEaXNjb25uZWN0ID0gdHJ1ZTtcblxuICAgICAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZXIpO1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy53cykge1xuICAgICAgICAgICAgdGhpcy53cy5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy53cyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFN0YXRlKENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNURUQpO1xuICAgICAgICBjb25zb2xlLmxvZygnXHVEODNEXHVERDBDIFdlYlNvY2tldCBkaXNjb25uZWN0ZWQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kIG1lc3NhZ2UgdG8gc2VydmVyXG4gICAgICovXG4gICAgc2VuZChtZXNzYWdlOiBXU01lc3NhZ2UpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNlbmQgbWVzc2FnZTogbm90IGNvbm5lY3RlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VTdHIgPSBKU09OLnN0cmluZ2lmeShtZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMud3MhLnNlbmQobWVzc2FnZVN0cik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgXHVEODNEXHVEQ0U0IFNlbnQ6ICR7bWVzc2FnZS50eXBlfWApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignXHUyNzRDIEZhaWxlZCB0byBzZW5kIG1lc3NhZ2U6JywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjb25uZWN0ZWRcbiAgICAgKi9cbiAgICBpc0Nvbm5lY3RlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5DT05ORUNURUQgJiZcbiAgICAgICAgICAgICAgIHRoaXMud3MgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgIHRoaXMud3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGN1cnJlbnQgY29ubmVjdGlvbiBzdGF0ZVxuICAgICAqL1xuICAgIGdldENvbm5lY3Rpb25TdGF0ZSgpOiBDb25uZWN0aW9uU3RhdGUge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCBjb25uZWN0aW9uIHN0YXRlIChhbGlhcyBmb3IgY29tcGF0aWJpbGl0eSlcbiAgICAgKi9cbiAgICBnZXRTdGF0ZSgpOiBDb25uZWN0aW9uU3RhdGUge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBtZXNzYWdlIGNhbGxiYWNrXG4gICAgICovXG4gICAgb25NZXNzYWdlKGNhbGxiYWNrOiBNZXNzYWdlQ2FsbGJhY2spOiAoKSA9PiB2b2lkIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlQ2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiB0aGlzLm1lc3NhZ2VDYWxsYmFja3MuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBlcnJvciBjYWxsYmFja1xuICAgICAqL1xuICAgIG9uRXJyb3IoY2FsbGJhY2s6IEVycm9yQ2FsbGJhY2spOiAoKSA9PiB2b2lkIHtcbiAgICAgICAgdGhpcy5lcnJvckNhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4gdGhpcy5lcnJvckNhbGxiYWNrcy5kZWxldGUoY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIHN0YXRlIGNoYW5nZSBjYWxsYmFja1xuICAgICAqL1xuICAgIG9uU3RhdGVDaGFuZ2UoY2FsbGJhY2s6IFN0YXRlQ2hhbmdlQ2FsbGJhY2spOiAoKSA9PiB2b2lkIHtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuXG4gICAgICAgIC8vIEltbWVkaWF0ZWx5IGNhbGwgd2l0aCBjdXJyZW50IHN0YXRlXG4gICAgICAgIGNhbGxiYWNrKHRoaXMuc3RhdGUpO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGluY29taW5nIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBwcml2YXRlIGhhbmRsZU1lc3NhZ2UoZGF0YTogQnVmZmVyKTogdm9pZCB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlOiBXU01lc3NhZ2UgPSBKU09OLnBhcnNlKGRhdGEudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgXHVEODNEXHVEQ0U1IFJlY2VpdmVkOiAke21lc3NhZ2UudHlwZX1gKTtcblxuICAgICAgICAgICAgLy8gTm90aWZ5IGFsbCBjYWxsYmFja3NcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZUNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdcdTI3NEMgRXJyb3IgaW4gbWVzc2FnZSBjYWxsYmFjazonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdcdTI3NEMgRmFpbGVkIHRvIHBhcnNlIG1lc3NhZ2U6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGNvbm5lY3Rpb24gZXJyb3JcbiAgICAgKi9cbiAgICBwcml2YXRlIGhhbmRsZUVycm9yKGVycm9yOiBFcnJvcik6IHZvaWQge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdcdTI3NEMgV2ViU29ja2V0IGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShDb25uZWN0aW9uU3RhdGUuRVJST1IpO1xuXG4gICAgICAgIHRoaXMuZXJyb3JDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1x1Mjc0QyBFcnJvciBpbiBlcnJvciBjYWxsYmFjazonLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgY29ubmVjdGlvbiBjbG9zZVxuICAgICAqL1xuICAgIHByaXZhdGUgaGFuZGxlQ2xvc2UoY29kZTogbnVtYmVyLCByZWFzb246IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBjb25zb2xlLmxvZyhgXHVEODNEXHVERDBDIFdlYlNvY2tldCBjbG9zZWQ6ICR7Y29kZX0gLSAke3JlYXNvbn1gKTtcblxuICAgICAgICBpZiAodGhpcy5pc01hbnVhbERpc2Nvbm5lY3QpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RFRCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFN0YXRlKENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNURUQpO1xuXG4gICAgICAgIC8vIEF1dG8gcmVjb25uZWN0IGlmIGVuYWJsZWRcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmF1dG9SZWNvbm5lY3QhICYmXG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzIDwgKHRoaXMuY29uZmlnLm1heFJldHJpZXMgfHwgMTApKSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZSByZWNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBwcml2YXRlIHNjaGVkdWxlUmVjb25uZWN0KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lcikge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBBbHJlYWR5IHNjaGVkdWxlZFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGVsYXkgPSAodGhpcy5jb25maWcucmVjb25uZWN0SW50ZXJ2YWwgfHwgNTAwMCkgKlxuICAgICAgICAgICAgTWF0aC5wb3coMiwgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyk7IC8vIEV4cG9uZW50aWFsIGJhY2tvZmZcblxuICAgICAgICBjb25zb2xlLmxvZyhgXHVEODNEXHVERDA0IFJlY29ubmVjdGluZyBpbiAke2RlbGF5fW1zIChhdHRlbXB0ICR7dGhpcy5yZWNvbm5lY3RBdHRlbXB0cyArIDF9KWApO1xuICAgICAgICB0aGlzLnNldFN0YXRlKENvbm5lY3Rpb25TdGF0ZS5SRUNPTk5FQ1RJTkcpO1xuXG4gICAgICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cysrO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignXHUyNzRDIFJlY29ubmVjdCBmYWlsZWQ6JywgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBjb25uZWN0aW9uIHN0YXRlIGFuZCBub3RpZnkgbGlzdGVuZXJzXG4gICAgICovXG4gICAgcHJpdmF0ZSBzZXRTdGF0ZShuZXdTdGF0ZTogQ29ubmVjdGlvblN0YXRlKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBuZXdTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFx1RDgzRFx1RENFMSBTdGF0ZSBjaGFuZ2VkOiAke25ld1N0YXRlfWApO1xuXG4gICAgICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ld1N0YXRlKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdcdTI3NEMgRXJyb3IgaW4gc3RhdGUgY2hhbmdlIGNhbGxiYWNrOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBQbHVnaW4sIFdvcmtzcGFjZUxlYWYgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBDbGF1ZGVDb2RlVmlldyB9IGZyb20gJy4vdWkvdmlldyc7XG5pbXBvcnQgeyBWSUVXX1RZUEVfQ0xBVURFX0NPREUgfSBmcm9tICcuL2NvcmUvdHlwZXMnO1xuaW1wb3J0IHsgQ2xhdWRlQ29kZVNldHRpbmdzLCBERUZBVUxUX1NFVFRJTkdTLCBDbGF1ZGVDb2RlU2V0dGluZ1RhYiB9IGZyb20gJy4vY29yZS9zZXR0aW5ncyc7XG5pbXBvcnQgeyBpbml0STE4biB9IGZyb20gJy4vaTE4bic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENsYXVkZUNvZGVQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuICAgIHNldHRpbmdzOiBDbGF1ZGVDb2RlU2V0dGluZ3M7XG5cbiAgICBhc3luYyBvbmxvYWQoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBpMThuIHdpdGggc2F2ZWQgbGFuZ3VhZ2UgcHJlZmVyZW5jZVxuICAgICAgICBpbml0STE4bih0aGlzLnNldHRpbmdzLmxhbmd1YWdlKTtcblxuICAgICAgICAvLyBSZWdpc3RlciB0aGUgQ2xhdWRlIENvZGUgdmlld1xuICAgICAgICB0aGlzLnJlZ2lzdGVyVmlldyhcbiAgICAgICAgICAgIFZJRVdfVFlQRV9DTEFVREVfQ09ERSxcbiAgICAgICAgICAgIChsZWFmKSA9PiBuZXcgQ2xhdWRlQ29kZVZpZXcobGVhZiwgdGhpcylcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBBZGQgcmliYm9uIGljb25cbiAgICAgICAgdGhpcy5hZGRSaWJib25JY29uKCdib3QnLCAnT3BlbiBDbGF1ZGUgQ29kZScsICgpID0+IHtcbiAgICAgICAgICAgIHZvaWQgdGhpcy5hY3RpdmF0ZVZpZXcoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWRkIGNvbW1hbmQgdG8gb3BlbiBDbGF1ZGUgQ29kZSB2aWV3XG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICAgICAgICBpZDogJ29wZW4tY2xhdWRlLWNvZGUtdmlldycsXG4gICAgICAgICAgICBuYW1lOiAnT3BlbiBDbGF1ZGUgQ29kZSBwYW5lbCcsXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5hY3RpdmF0ZVZpZXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWRkIGNvbW1hbmQgdG8gcnVuIENsYXVkZSBDb2RlIG9uIGN1cnJlbnQgbm90ZVxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6ICdydW4tY2xhdWRlLWNvZGUtcXVpY2snLFxuICAgICAgICAgICAgbmFtZTogJ1F1aWNrIHJ1biBDbGF1ZGUgQ29kZSAod2l0aCBkZWZhdWx0IHByb21wdCknLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFjdGl2YXRlVmlldygpO1xuICAgICAgICAgICAgICAgIC8vIFRoZSB2aWV3IHdpbGwgYmUgcmVhZHkgZm9yIHVzZXIgaW5wdXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWRkIGNvbW1hbmQgdG8gcnVuIENsYXVkZSBDb2RlIG9uIHNlbGVjdGVkIHRleHRcbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgICAgICAgIGlkOiAncnVuLWNsYXVkZS1jb2RlLXNlbGVjdGlvbicsXG4gICAgICAgICAgICBuYW1lOiAnUnVuIENsYXVkZSBDb2RlIG9uIHNlbGVjdGVkIHRleHQnLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFjdGl2YXRlVmlldygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlYXZlcyA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWF2ZXNPZlR5cGUoVklFV19UWVBFX0NMQVVERV9DT0RFKTtcbiAgICAgICAgICAgICAgICBpZiAobGVhdmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmlldyA9IGxlYXZlc1swXS52aWV3IGFzIENsYXVkZUNvZGVWaWV3O1xuICAgICAgICAgICAgICAgICAgICAvLyBFbmFibGUgXCJzZWxlY3RlZCB0ZXh0IG9ubHlcIiBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hlY2tib3ggPSB2aWV3LmNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3IoJy5jbGF1ZGUtY29kZS1vcHRpb25zIGlucHV0W3R5cGU9XCJjaGVja2JveFwiXScpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVja2JveCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFkZCBzZXR0aW5ncyB0YWJcbiAgICAgICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBDbGF1ZGVDb2RlU2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xuICAgIH1cblxuICAgIG9udW5sb2FkKCkge1xuICAgICAgICAvLyBWaWV3cyBhcmUgY2xlYW5lZCB1cCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIHBsdWdpbiBpcyB1bmxvYWRlZFxuICAgIH1cblxuICAgIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIGF3YWl0IHRoaXMubG9hZERhdGEoKSBhcyBDbGF1ZGVDb2RlU2V0dGluZ3MgfCB1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcblxuICAgICAgICAvLyBVcGRhdGUgc2V0dGluZ3MgaW4gYWxsIGFjdGl2ZSBDbGF1ZGUgQ29kZSB2aWV3c1xuICAgICAgICBjb25zdCBsZWF2ZXMgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhdmVzT2ZUeXBlKFZJRVdfVFlQRV9DTEFVREVfQ09ERSk7XG4gICAgICAgIGxlYXZlcy5mb3JFYWNoKGxlYWYgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmlldyA9IGxlYWYudmlldyBhcyBDbGF1ZGVDb2RlVmlldztcbiAgICAgICAgICAgIHZpZXcudXBkYXRlU2V0dGluZ3MoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgYWN0aXZhdGVWaWV3KCkge1xuICAgICAgICBjb25zdCB7IHdvcmtzcGFjZSB9ID0gdGhpcy5hcHA7XG5cbiAgICAgICAgbGV0IGxlYWY6IFdvcmtzcGFjZUxlYWYgfCBudWxsID0gbnVsbDtcbiAgICAgICAgY29uc3QgbGVhdmVzID0gd29ya3NwYWNlLmdldExlYXZlc09mVHlwZShWSUVXX1RZUEVfQ0xBVURFX0NPREUpO1xuXG4gICAgICAgIGlmIChsZWF2ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gQSBsZWFmIHdpdGggb3VyIHZpZXcgYWxyZWFkeSBleGlzdHMsIHVzZSB0aGF0XG4gICAgICAgICAgICBsZWFmID0gbGVhdmVzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGxlYWYgaW4gdGhlIHJpZ2h0IHNpZGViYXJcbiAgICAgICAgICAgIGxlYWYgPSB3b3Jrc3BhY2UuZ2V0UmlnaHRMZWFmKGZhbHNlKTtcbiAgICAgICAgICAgIGF3YWl0IGxlYWY/LnNldFZpZXdTdGF0ZSh7IHR5cGU6IFZJRVdfVFlQRV9DTEFVREVfQ09ERSwgYWN0aXZlOiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV2ZWFsIHRoZSBsZWFmIGluIGNhc2UgaXQncyBpbiBhIGNvbGxhcHNlZCBzaWRlYmFyXG4gICAgICAgIGlmIChsZWFmKSB7XG4gICAgICAgICAgICB2b2lkIHdvcmtzcGFjZS5yZXZlYWxMZWFmKGxlYWYpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwgIi8qKlxuICogQ2xhdWRlIENvZGUgVmlldyAtIFJlZmFjdG9yZWQgdG8gdXNlIG1vZHVsYXIgY29tcG9uZW50c1xuICovXG5cbmltcG9ydCB7IEl0ZW1WaWV3LCBXb3Jrc3BhY2VMZWFmLCBNYXJrZG93blZpZXcsIE5vdGljZSwgTWFya2Rvd25SZW5kZXJlciwgRWRpdG9yLCBGaWxlU3lzdGVtQWRhcHRlciB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCBDbGF1ZGVDb2RlUGx1Z2luIGZyb20gJy4uL21haW4nO1xuaW1wb3J0IHsgQ2xhdWRlQ29kZVJlcXVlc3QgfSBmcm9tICcuLi9jb3JlL2NsYXVkZS1jb2RlLXJ1bm5lcic7XG5pbXBvcnQgeyBWSUVXX1RZUEVfQ0xBVURFX0NPREUsIFNlc3Npb25IaXN0b3J5SXRlbSwgTm90ZUNvbnRleHQgfSBmcm9tICcuLi9jb3JlL3R5cGVzJztcbmltcG9ydCB7IFVJQnVpbGRlciB9IGZyb20gJy4vdWktYnVpbGRlcic7XG5pbXBvcnQgeyB0IH0gZnJvbSAnLi4vaTE4bic7XG5cbi8qKiBJbnRlcmZhY2UgZm9yIHN0cmVhbWluZyBlbGVtZW50IHdpdGggYWNjdW11bGF0ZWQgdGV4dCAqL1xuaW50ZXJmYWNlIFN0cmVhbWluZ0VsZW1lbnREYXRhIHtcbiAgICBhY2N1bXVsYXRlZFRleHQ6IHN0cmluZztcbiAgICBmdWxsVGV4dD86IHN0cmluZztcbn1cblxuLyoqIEludGVyZmFjZSBmb3IgcGFyc2VkIHRvb2wgaW5wdXQgd2l0aCB0b2RvcyAqL1xuaW50ZXJmYWNlIFRvZG9Ub29sSW5wdXQge1xuICAgIHRvZG9zPzogQXJyYXk8eyBjb250ZW50OiBzdHJpbmc7IHN0YXR1czogc3RyaW5nOyBhY3RpdmVGb3JtOiBzdHJpbmcgfT47XG59XG5pbXBvcnQgeyBPdXRwdXRSZW5kZXJlciB9IGZyb20gJy4vb3V0cHV0LXJlbmRlcmVyJztcbmltcG9ydCB7IEFnZW50QWN0aXZpdHlUcmFja2VyIH0gZnJvbSAnLi9hZ2VudC1hY3Rpdml0eS10cmFja2VyJztcbmltcG9ydCB7IE5vdGVDb250ZXh0TWFuYWdlciB9IGZyb20gJy4uL21hbmFnZXJzL25vdGUtY29udGV4dC1tYW5hZ2VyJztcbmltcG9ydCB7IE91dHB1dFN0YXR1c01hbmFnZXIgfSBmcm9tICcuL3BhcnNlcnMvb3V0cHV0LXN0YXR1cy1tYW5hZ2VyJztcbmltcG9ydCB7IERpZmZHZW5lcmF0b3IgfSBmcm9tICcuL3JlbmRlcmVycy9kaWZmLWdlbmVyYXRvcic7XG5pbXBvcnQgeyBUb29sQ2FsbFRyYWNrZXIgfSBmcm9tICcuL3Rvb2wtY2FsbC10cmFja2VyJztcbmltcG9ydCB7IFRvb2xDYWxsRGlzcGxheSB9IGZyb20gJy4vY29tcG9uZW50cy90b29sLWNhbGwtZGlzcGxheSc7XG5pbXBvcnQgeyBTdHJlYW1pbmdSZW5kZXJlciB9IGZyb20gJy4vc3RyZWFtaW5nLXJlbmRlcmVyJztcblxuZXhwb3J0IGNsYXNzIENsYXVkZUNvZGVWaWV3IGV4dGVuZHMgSXRlbVZpZXcge1xuICAgIHBsdWdpbjogQ2xhdWRlQ29kZVBsdWdpbjtcblxuICAgIC8vIFVJIEVsZW1lbnRzIChyZWZlcmVuY2VzKVxuICAgIHByaXZhdGUgcHJvbXB0SW5wdXQ6IEhUTUxUZXh0QXJlYUVsZW1lbnQ7XG4gICAgcHJpdmF0ZSBydW5CdXR0b246IEhUTUxCdXR0b25FbGVtZW50O1xuICAgIHByaXZhdGUgY2FuY2VsQnV0dG9uOiBIVE1MQnV0dG9uRWxlbWVudDtcbiAgICBwcml2YXRlIG91dHB1dEFyZWE6IEhUTUxEaXZFbGVtZW50O1xuICAgIHByaXZhdGUgb3V0cHV0U2VjdGlvbjogSFRNTERpdkVsZW1lbnQ7XG4gICAgcHJpdmF0ZSByZXN1bHRBcmVhOiBIVE1MRGl2RWxlbWVudDtcbiAgICBwcml2YXRlIGxhc3RQcm9tcHRBcmVhOiBIVE1MRGl2RWxlbWVudDtcbiAgICBwcml2YXRlIGN1cnJlbnRSZXN1bHRTdHJlYW1pbmdFbGVtZW50OiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsO1xuICAgIHByaXZhdGUgaGl0RmluYWxDb250ZW50TWFya2VyOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSB1c2VySGFzU2Nyb2xsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIGxhc3RSZW5kZXJlZFRleHQ6IHN0cmluZyA9ICcnOyAvLyBUcmFjayB3aGF0IHdlJ3ZlIGFscmVhZHkgcmVuZGVyZWRcbiAgICBwcml2YXRlIHByZXZpZXdBcmVhOiBIVE1MRGl2RWxlbWVudDtcbiAgICBwcml2YXRlIHByZXZpZXdDb250ZW50Q29udGFpbmVyOiBIVE1MRGl2RWxlbWVudDtcbiAgICBwcml2YXRlIHNlbGVjdGVkVGV4dE9ubHlDaGVja2JveDogSFRNTElucHV0RWxlbWVudDtcbiAgICBwcml2YXRlIGF1dG9BY2NlcHRDaGVja2JveDogSFRNTElucHV0RWxlbWVudDtcbiAgICBwcml2YXRlIGNvbnZlcnNhdGlvbmFsTW9kZUNoZWNrYm94OiBIVE1MSW5wdXRFbGVtZW50O1xuICAgIHByaXZhdGUgbW9kZWxTZWxlY3Q6IEhUTUxTZWxlY3RFbGVtZW50O1xuICAgIHByaXZhdGUgY3VycmVudE5vdGVMYWJlbDogSFRNTEVsZW1lbnQ7XG4gICAgcHJpdmF0ZSBzdGF0dXNJbmRpY2F0b3I6IEhUTUxFbGVtZW50O1xuICAgIHByaXZhdGUgc3RhdHVzVGV4dDogSFRNTFNwYW5FbGVtZW50O1xuICAgIHByaXZhdGUgcGVybWlzc2lvbkFwcHJvdmFsU2VjdGlvbjogSFRNTEVsZW1lbnQ7XG4gICAgcHJpdmF0ZSBoaXN0b3J5TGlzdDogSFRNTFVMaXN0RWxlbWVudDtcblxuICAgIC8vIE1hbmFnZXJzIGFuZCBSZW5kZXJlcnNcbiAgICBwcml2YXRlIGNvbnRleHRNYW5hZ2VyOiBOb3RlQ29udGV4dE1hbmFnZXI7XG4gICAgcHJpdmF0ZSBvdXRwdXRSZW5kZXJlcjogT3V0cHV0UmVuZGVyZXI7XG4gICAgcHJpdmF0ZSBhZ2VudFRyYWNrZXI6IEFnZW50QWN0aXZpdHlUcmFja2VyO1xuICAgIHByaXZhdGUgdG9vbENhbGxUcmFja2VyOiBUb29sQ2FsbFRyYWNrZXI7XG4gICAgcHJpdmF0ZSB0b29sQ2FsbERpc3BsYXk6IFRvb2xDYWxsRGlzcGxheSB8IG51bGwgPSBudWxsO1xuICAgIHByaXZhdGUgc3RyZWFtaW5nUmVuZGVyZXI6IFN0cmVhbWluZ1JlbmRlcmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICAvLyBTdGF0ZVxuICAgIHByaXZhdGUgY3VycmVudE5vdGVQYXRoOiBzdHJpbmcgPSAnJztcblxuICAgIC8vIFRvb2wgdGltaW5nIHRyYWNraW5nXG4gICAgcHJpdmF0ZSB0b29sU3RhcnRUaW1lczogTWFwPHN0cmluZywgbnVtYmVyPiA9IG5ldyBNYXAoKTtcbiAgICBwcml2YXRlIGxhc3RUb29sS2V5OiBzdHJpbmcgfCBudWxsID0gbnVsbDtcblxuICAgIC8vIEV4ZWN1dGlvbiB0aW1pbmcgdHJhY2tpbmcgKGludGVydmFsIGlzIHZpZXctbGV2ZWwsIGJ1dCBzdGFydCB0aW1lIGlzIHBlci1ub3RlIGluIGNvbnRleHQpXG4gICAgcHJpdmF0ZSBlbGFwc2VkVGltZUludGVydmFsOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xuXG4gICAgLy8gRXZlbnQgbGlzdGVuZXIgY2xlYW51cCB0cmFja2luZ1xuICAgIHByaXZhdGUgZXZlbnRMaXN0ZW5lcnM6IEFycmF5PHtcbiAgICAgICAgZWxlbWVudDogSFRNTEVsZW1lbnQgfCBXaW5kb3c7XG4gICAgICAgIGV2ZW50OiBzdHJpbmc7XG4gICAgICAgIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXI7XG4gICAgfT4gPSBbXTtcbiAgICBwcml2YXRlIHByb21wdElucHV0S2V5ZG93bkhhbmRsZXI6ICgoZTogS2V5Ym9hcmRFdmVudCkgPT4gdm9pZCkgfCBudWxsID0gbnVsbDtcblxuICAgIGNvbnN0cnVjdG9yKGxlYWY6IFdvcmtzcGFjZUxlYWYsIHBsdWdpbjogQ2xhdWRlQ29kZVBsdWdpbikge1xuICAgICAgICBzdXBlcihsZWFmKTtcbiAgICAgICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBtYW5hZ2Vyc1xuICAgICAgICB0aGlzLmNvbnRleHRNYW5hZ2VyID0gbmV3IE5vdGVDb250ZXh0TWFuYWdlcihcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLFxuICAgICAgICAgICAgYCR7dGhpcy5hcHAudmF1bHQuY29uZmlnRGlyfS9jbGF1ZGUtY29kZS1zZXNzaW9uc2BcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5hZ2VudFRyYWNrZXIgPSBuZXcgQWdlbnRBY3Rpdml0eVRyYWNrZXIoKTtcbiAgICAgICAgdGhpcy50b29sQ2FsbFRyYWNrZXIgPSBuZXcgVG9vbENhbGxUcmFja2VyKCk7XG5cbiAgICAgICAgLy8gTGlzdGVuIGZvciBhY3RpdmUgZmlsZSBjaGFuZ2VzXG4gICAgICAgIHRoaXMucmVnaXN0ZXJFdmVudChcbiAgICAgICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5vbignYWN0aXZlLWxlYWYtY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25BY3RpdmVOb3RlQ2hhbmdlKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGdldFZpZXdUeXBlKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBWSUVXX1RZUEVfQ0xBVURFX0NPREU7XG4gICAgfVxuXG4gICAgZ2V0RGlzcGxheVRleHQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuICdDbGF1ZGUgQ29kZSc7XG4gICAgfVxuXG4gICAgZ2V0SWNvbigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ2JvdCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0b29sIGNhbGwgdHJhY2tlciBpbnN0YW5jZVxuICAgICAqL1xuICAgIGdldFRvb2xDYWxsVHJhY2tlcigpOiBUb29sQ2FsbFRyYWNrZXIge1xuICAgICAgICByZXR1cm4gdGhpcy50b29sQ2FsbFRyYWNrZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdHJlYW1pbmcgcmVuZGVyZXIgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBnZXRTdHJlYW1pbmdSZW5kZXJlcigpOiBTdHJlYW1pbmdSZW5kZXJlciB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1pbmdSZW5kZXJlcjtcbiAgICB9XG5cbiAgICBhc3luYyBvbk9wZW4oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyRWwuY2hpbGRyZW5bMV0gYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgIGNvbnRhaW5lci5lbXB0eSgpO1xuICAgICAgICBjb250YWluZXIuYWRkQ2xhc3MoJ2NsYXVkZS1jb2RlLXZpZXcnKTtcblxuICAgICAgICAvLyBMb2FkIHBlcnNpc3RlZCBjb250ZXh0cyBmcm9tIGRpc2tcbiAgICAgICAgY29uc3QgdmF1bHRQYXRoID0gKHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIgYXMgRmlsZVN5c3RlbUFkYXB0ZXIpLmdldEJhc2VQYXRoKCk7XG4gICAgICAgIGlmICh2YXVsdFBhdGgpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dE1hbmFnZXIubG9hZENvbnRleHRzKHZhdWx0UGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgY3VycmVudCBhY3RpdmUgbm90ZVxuICAgICAgICBjb25zdCBhY3RpdmVGaWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcbiAgICAgICAgaWYgKGFjdGl2ZUZpbGUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE5vdGVQYXRoID0gYWN0aXZlRmlsZS5wYXRoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQnVpbGQgVUkgdXNpbmcgbW9kdWxhciBjb21wb25lbnRzXG4gICAgICAgIHRoaXMuYnVpbGRVSShjb250YWluZXIpO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgb3V0cHV0IHJlbmRlcmVyIG5vdyB0aGF0IG91dHB1dEFyZWEgZXhpc3RzXG4gICAgICAgIHRoaXMub3V0cHV0UmVuZGVyZXIgPSBuZXcgT3V0cHV0UmVuZGVyZXIodGhpcy5vdXRwdXRBcmVhLCB0aGlzLCB0aGlzLmFwcCwgdGhpcy5jdXJyZW50Tm90ZVBhdGgsIHRoaXMub3V0cHV0U2VjdGlvbik7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBzdHJlYW1pbmcgcmVuZGVyZXIgZm9yIFdlYlNvY2tldCBtb2RlXG4gICAgICAgIHRoaXMuc3RyZWFtaW5nUmVuZGVyZXIgPSBuZXcgU3RyZWFtaW5nUmVuZGVyZXIodGhpcywgdGhpcy5vdXRwdXRBcmVhKTtcblxuICAgICAgICAvLyBMb2FkIGNvbnRleHQgZm9yIGN1cnJlbnQgbm90ZVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Tm90ZVBhdGgpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZE5vdGVDb250ZXh0KHRoaXMuY3VycmVudE5vdGVQYXRoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ1aWxkIHRoZSBlbnRpcmUgVUkgdXNpbmcgbW9kdWxhciBjb21wb25lbnRzXG4gICAgICovXG4gICAgcHJpdmF0ZSBidWlsZFVJKGNvbnRhaW5lcjogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgLy8gSGVhZGVyXG4gICAgICAgIHRoaXMuY3VycmVudE5vdGVMYWJlbCA9IFVJQnVpbGRlci5idWlsZEhlYWRlcihjb250YWluZXIpO1xuICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnROb3RlTGFiZWwoKTtcblxuICAgICAgICAvLyBJbnB1dCBzZWN0aW9uXG4gICAgICAgIGNvbnN0IGlucHV0RWxlbWVudHMgPSBVSUJ1aWxkZXIuYnVpbGRJbnB1dFNlY3Rpb24oXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5hdXRvQWNjZXB0Q2hhbmdlcyxcbiAgICAgICAgICAgICgpID0+IHZvaWQgdGhpcy5oYW5kbGVSdW5DbGF1ZGVDb2RlKCksXG4gICAgICAgICAgICAoKSA9PiB0aGlzLmhhbmRsZUNhbmNlbCgpXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucHJvbXB0SW5wdXQgPSBpbnB1dEVsZW1lbnRzLnByb21wdElucHV0O1xuICAgICAgICB0aGlzLnNlbGVjdGVkVGV4dE9ubHlDaGVja2JveCA9IGlucHV0RWxlbWVudHMuc2VsZWN0ZWRUZXh0T25seUNoZWNrYm94O1xuICAgICAgICB0aGlzLmF1dG9BY2NlcHRDaGVja2JveCA9IGlucHV0RWxlbWVudHMuYXV0b0FjY2VwdENoZWNrYm94O1xuICAgICAgICB0aGlzLmNvbnZlcnNhdGlvbmFsTW9kZUNoZWNrYm94ID0gaW5wdXRFbGVtZW50cy5jb252ZXJzYXRpb25hbE1vZGVDaGVja2JveDtcbiAgICAgICAgdGhpcy5tb2RlbFNlbGVjdCA9IGlucHV0RWxlbWVudHMubW9kZWxTZWxlY3Q7XG4gICAgICAgIHRoaXMucnVuQnV0dG9uID0gaW5wdXRFbGVtZW50cy5ydW5CdXR0b247XG4gICAgICAgIHRoaXMuY2FuY2VsQnV0dG9uID0gaW5wdXRFbGVtZW50cy5jYW5jZWxCdXR0b247XG5cbiAgICAgICAgLy8gV2hlbiBjb252ZXJzYXRpb25hbCBtb2RlIGlzIHRvZ2dsZWQsIGRpc2FibGUgZmlsZS1yZWxhdGVkIG9wdGlvbnNcbiAgICAgICAgdGhpcy5jb252ZXJzYXRpb25hbE1vZGVDaGVja2JveC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc0NvbnZlcnNhdGlvbmFsID0gdGhpcy5jb252ZXJzYXRpb25hbE1vZGVDaGVja2JveC5jaGVja2VkO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFRleHRPbmx5Q2hlY2tib3guZGlzYWJsZWQgPSBpc0NvbnZlcnNhdGlvbmFsO1xuICAgICAgICAgICAgdGhpcy5hdXRvQWNjZXB0Q2hlY2tib3guZGlzYWJsZWQgPSBpc0NvbnZlcnNhdGlvbmFsO1xuICAgICAgICAgICAgaWYgKGlzQ29udmVyc2F0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkVGV4dE9ubHlDaGVja2JveC5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvQWNjZXB0Q2hlY2tib3guY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gTm90ZTogc3RhdHVzSW5kaWNhdG9yIGFuZCBzdGF0dXNUZXh0IGFyZSBub3cgcGFydCBvZiBSZXN1bHQgc2VjdGlvbiAoc2VlIGJlbG93KVxuXG4gICAgICAgIC8vIFNhdmUgbW9kZWwgc2VsZWN0aW9uIHdoZW4gY2hhbmdlZFxuICAgICAgICB0aGlzLm1vZGVsU2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldEN1cnJlbnRDb250ZXh0KCk7XG4gICAgICAgICAgICBjb250ZXh0LnNlbGVjdGVkTW9kZWwgPSB0aGlzLm1vZGVsU2VsZWN0LnZhbHVlO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBZGQga2V5Ym9hcmQgc2hvcnRjdXQgdG8gcHJvbXB0IGlucHV0XG4gICAgICAgIHRoaXMucHJvbXB0SW5wdXRLZXlkb3duSGFuZGxlciA9IChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZS5rZXkgPT09ICdFbnRlcicgJiYgIWUuc2hpZnRLZXkgJiYgIWUuY3RybEtleSAmJiAhZS5tZXRhS2V5KSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5oYW5kbGVSdW5DbGF1ZGVDb2RlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUua2V5ID09PSAnRW50ZXInICYmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMucHJvbXB0SW5wdXQuc2VsZWN0aW9uU3RhcnQgPz8gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSB0aGlzLnByb21wdElucHV0LnNlbGVjdGlvbkVuZCA/PyAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5wcm9tcHRJbnB1dC52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb21wdElucHV0LnZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHN0YXJ0KSArICdcXG4nICsgdmFsdWUuc3Vic3RyaW5nKGVuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9tcHRJbnB1dC5zZWxlY3Rpb25TdGFydCA9IHRoaXMucHJvbXB0SW5wdXQuc2VsZWN0aW9uRW5kID0gc3RhcnQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb21wdElucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLnByb21wdElucHV0S2V5ZG93bkhhbmRsZXIpO1xuXG4gICAgICAgIC8vIEludGVyYWN0aXZlIHByb21wdCBzZWN0aW9uXG4gICAgICAgICBVSUJ1aWxkZXIuYnVpbGRJbnRlcmFjdGl2ZVByb21wdFNlY3Rpb24oXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICAocmVzcG9uc2UpID0+IHRoaXMucmVzcG9uZFRvUHJvbXB0KHJlc3BvbnNlKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFJlc3VsdCBzZWN0aW9uIChmaXJzdCkgLSBpbmNsdWRlcyBzdGF0dXMgaW5kaWNhdG9yXG4gICAgICAgIGNvbnN0IHJlc3VsdEVsZW1lbnRzID0gVUlCdWlsZGVyLmJ1aWxkUmVzdWx0U2VjdGlvbihjb250YWluZXIpO1xuICAgICAgICB0aGlzLnJlc3VsdEFyZWEgPSByZXN1bHRFbGVtZW50cy5yZXN1bHRBcmVhO1xuICAgICAgICB0aGlzLnN0YXR1c0luZGljYXRvciA9IHJlc3VsdEVsZW1lbnRzLnN0YXR1c0FyZWE7XG4gICAgICAgIHRoaXMuc3RhdHVzVGV4dCA9IHJlc3VsdEVsZW1lbnRzLnN0YXR1c1RleHQ7XG4gICAgICAgIHRoaXMubGFzdFByb21wdEFyZWEgPSByZXN1bHRFbGVtZW50cy5sYXN0UHJvbXB0QXJlYTtcblxuICAgICAgICAvLyBTZXR1cCBzbWFydCBhdXRvLXNjcm9sbCBkZXRlY3Rpb25cbiAgICAgICAgdGhpcy5zZXR1cFNtYXJ0QXV0b1Njcm9sbCgpO1xuXG4gICAgICAgIC8vIFBlcm1pc3Npb24gYXBwcm92YWwgc2VjdGlvbiAoYWZ0ZXIgcmVzdWx0KVxuICAgICAgICBjb25zdCBwZXJtaXNzaW9uRWxlbWVudHMgPSBVSUJ1aWxkZXIuYnVpbGRQZXJtaXNzaW9uQXBwcm92YWxTZWN0aW9uKFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgKCkgPT4gdm9pZCB0aGlzLmhhbmRsZUFwcHJvdmVQZXJtaXNzaW9uKCksXG4gICAgICAgICAgICAoKSA9PiB0aGlzLmhhbmRsZURlbnlQZXJtaXNzaW9uKClcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wZXJtaXNzaW9uQXBwcm92YWxTZWN0aW9uID0gcGVybWlzc2lvbkVsZW1lbnRzLnBlcm1pc3Npb25BcHByb3ZhbFNlY3Rpb247XG5cbiAgICAgICAgLy8gUHJldmlldyBzZWN0aW9uIChzZWNvbmQgLSBhZnRlciByZXN1bHQpXG4gICAgICAgIGNvbnN0IHByZXZpZXdFbGVtZW50cyA9IFVJQnVpbGRlci5idWlsZFByZXZpZXdTZWN0aW9uKFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgKCkgPT4gdGhpcy5oYW5kbGVBcHBseUNoYW5nZXMoKSxcbiAgICAgICAgICAgICgpID0+IHRoaXMuaGFuZGxlUmVqZWN0Q2hhbmdlcygpXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMucHJldmlld0FyZWEgPSBwcmV2aWV3RWxlbWVudHMucHJldmlld0FyZWE7XG4gICAgICAgIHRoaXMucHJldmlld0NvbnRlbnRDb250YWluZXIgPSBwcmV2aWV3RWxlbWVudHMucHJldmlld0NvbnRlbnRDb250YWluZXI7XG5cbiAgICAgICAgLy8gQ29tYmluZWQgYWdlbnQgc2VjdGlvbiAocGxhbiArIGFjdGl2aXR5KSAodGhpcmQpXG4gICAgICAgIFVJQnVpbGRlci5idWlsZEFnZW50U2VjdGlvbihjb250YWluZXIpO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgYWdlbnQgdHJhY2tlciB3aXRoIHRoZSBhY3Rpdml0eSBjb2x1bW5cbiAgICAgICAgY29uc3QgYWN0aXZpdHlDb2x1bW4gPSBjb250YWluZXIucXVlcnlTZWxlY3RvcignLmNsYXVkZS1jb2RlLWFjdGl2aXR5LWNvbHVtbicpO1xuICAgICAgICBpZiAoYWN0aXZpdHlDb2x1bW4pIHtcbiAgICAgICAgICAgIHRoaXMuYWdlbnRUcmFja2VyLmluaXRpYWxpemUoYWN0aXZpdHlDb2x1bW4gYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVG9vbCBDYWxsIERpc3BsYXkgc2VjdGlvbiAoZm91cnRoKVxuICAgICAgICBjb25zdCB0b29sQ2FsbFNlY3Rpb24gPSBjb250YWluZXIuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgICAgICAgIGNsczogJ2NsYXVkZS1jb2RlLXRvb2wtY2FsbC1zZWN0aW9uJ1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b29sQ2FsbERpc3BsYXkgPSBuZXcgVG9vbENhbGxEaXNwbGF5KHRvb2xDYWxsU2VjdGlvbiwgdGhpcy50b29sQ2FsbFRyYWNrZXIpO1xuXG4gICAgICAgIC8vIE91dHB1dCBzZWN0aW9uIChmaWZ0aClcbiAgICAgICAgY29uc3Qgb3V0cHV0U2VjdGlvblJlc3VsdCA9IFVJQnVpbGRlci5idWlsZE91dHB1dFNlY3Rpb24oY29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5vdXRwdXRBcmVhID0gb3V0cHV0U2VjdGlvblJlc3VsdC5vdXRwdXRBcmVhO1xuICAgICAgICB0aGlzLm91dHB1dFNlY3Rpb24gPSBvdXRwdXRTZWN0aW9uUmVzdWx0Lm91dHB1dFNlY3Rpb247XG5cbiAgICAgICAgLy8gSGlzdG9yeSBzZWN0aW9uIChzaXh0aClcbiAgICAgICAgdGhpcy5oaXN0b3J5TGlzdCA9IFVJQnVpbGRlci5idWlsZEhpc3RvcnlTZWN0aW9uKFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgKCkgPT4gdGhpcy5jbGVhckhpc3RvcnkoKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgY3VycmVudCBub3RlIGxhYmVsXG4gICAgICovXG4gICAgcHJpdmF0ZSB1cGRhdGVDdXJyZW50Tm90ZUxhYmVsKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50Tm90ZVBhdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gdGhpcy5jdXJyZW50Tm90ZVBhdGguc3BsaXQoJy8nKS5wb3AoKSB8fCAnVW5rbm93bic7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0TWFuYWdlci5nZXRDb250ZXh0KHRoaXMuY3VycmVudE5vdGVQYXRoKTtcbiAgICAgICAgICAgIGNvbnN0IHJ1bm5pbmdJbmRpY2F0b3IgPSBjb250ZXh0LmlzUnVubmluZyA/ICcgXHVEODNEXHVERDA0JyA6ICcnO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Tm90ZUxhYmVsLnRleHRDb250ZW50ID0gYFx1RDgzRFx1RENERCAke2ZpbGVOYW1lfSR7cnVubmluZ0luZGljYXRvcn1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Tm90ZUxhYmVsLnRleHRDb250ZW50ID0gJ1x1RDgzRFx1RENERCAnICsgdCgnaGVhZGVyLm5vTm90ZVNlbGVjdGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaG93IGNvdW50IG9mIG90aGVyIHJ1bm5pbmcgcHJvY2Vzc2VzXG4gICAgICAgIHRoaXMudXBkYXRlUnVubmluZ0luZGljYXRvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgaW5kaWNhdG9yIHNob3dpbmcgaG93IG1hbnkgb3RoZXIgbm90ZXMgaGF2ZSBydW5uaW5nIHByb2Nlc3Nlc1xuICAgICAqL1xuICAgIHByaXZhdGUgdXBkYXRlUnVubmluZ0luZGljYXRvcigpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgcnVubmluZ1BhdGhzID0gdGhpcy5jb250ZXh0TWFuYWdlci5nZXRSdW5uaW5nTm90ZVBhdGhzKCk7XG4gICAgICAgIGNvbnN0IG90aGVyUnVubmluZyA9IHJ1bm5pbmdQYXRocy5maWx0ZXIocCA9PiBwICE9PSB0aGlzLmN1cnJlbnROb3RlUGF0aCk7XG5cbiAgICAgICAgLy8gRmluZCBvciBjcmVhdGUgaW5kaWNhdG9yIGVsZW1lbnRcbiAgICAgICAgbGV0IGluZGljYXRvciA9IHRoaXMuY3VycmVudE5vdGVMYWJlbC5wYXJlbnRFbGVtZW50Py5xdWVyeVNlbGVjdG9yKCcuY2xhdWRlLWNvZGUtcnVubmluZy1pbmRpY2F0b3InKSBhcyBIVE1MRWxlbWVudDtcblxuICAgICAgICBpZiAob3RoZXJSdW5uaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICghaW5kaWNhdG9yKSB7XG4gICAgICAgICAgICAgICAgaW5kaWNhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgICAgIGluZGljYXRvci5hZGRDbGFzcygnY2xhdWRlLWNvZGUtcnVubmluZy1pbmRpY2F0b3InKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnROb3RlTGFiZWwucGFyZW50RWxlbWVudD8uYXBwZW5kQ2hpbGQoaW5kaWNhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5vdGVOYW1lcyA9IG90aGVyUnVubmluZy5tYXAocCA9PiBwLnNwbGl0KCcvJykucG9wKCkgfHwgJ1Vua25vd24nKS5qb2luKCcsICcpO1xuICAgICAgICAgICAgaW5kaWNhdG9yLnRleHRDb250ZW50ID0gYCAoJHtvdGhlclJ1bm5pbmcubGVuZ3RofSBvdGhlciBydW5uaW5nKWA7XG4gICAgICAgICAgICBpbmRpY2F0b3Iuc2V0QXR0cmlidXRlKCd0aXRsZScsIGBSdW5uaW5nOiAke25vdGVOYW1lc31gKTtcbiAgICAgICAgICAgIGluZGljYXRvci5yZW1vdmVDbGFzcygnY2xhdWRlLWNvZGUtaGlkZGVuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kaWNhdG9yKSB7XG4gICAgICAgICAgICBpbmRpY2F0b3IuYWRkQ2xhc3MoJ2NsYXVkZS1jb2RlLWhpZGRlbicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFjdGl2ZSBub3RlIGNoYW5nZVxuICAgICAqL1xuICAgIHByaXZhdGUgb25BY3RpdmVOb3RlQ2hhbmdlKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBhY3RpdmVGaWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcbiAgICAgICAgaWYgKGFjdGl2ZUZpbGUgJiYgYWN0aXZlRmlsZS5wYXRoICE9PSB0aGlzLmN1cnJlbnROb3RlUGF0aCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Tm90ZVBhdGggPSBhY3RpdmVGaWxlLnBhdGg7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnROb3RlTGFiZWwoKTtcbiAgICAgICAgICAgIHRoaXMubG9hZE5vdGVDb250ZXh0KHRoaXMuY3VycmVudE5vdGVQYXRoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWQgY29udGV4dCBmb3IgYSBzcGVjaWZpYyBub3RlXG4gICAgICovXG4gICAgcHJpdmF0ZSBsb2FkTm90ZUNvbnRleHQobm90ZVBhdGg6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0TWFuYWdlci5nZXRDb250ZXh0KG5vdGVQYXRoKTtcblxuICAgICAgICAvLyBVcGRhdGUgb3V0cHV0IHJlbmRlcmVyIHdpdGggbmV3IG5vdGUgcGF0aFxuICAgICAgICB0aGlzLm91dHB1dFJlbmRlcmVyPy5zZXROb3RlUGF0aChub3RlUGF0aCk7XG5cbiAgICAgICAgLy8gUmVzdG9yZSBvdXRwdXRcbiAgICAgICAgdGhpcy5vdXRwdXRSZW5kZXJlcj8uY2xlYXIoKTtcbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGNvbnRleHQub3V0cHV0TGluZXMpIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0UmVuZGVyZXI/LmFwcGVuZExpbmUobGluZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXN0b3JlIGFnZW50IGFjdGl2aXR5XG4gICAgICAgIHRoaXMuYWdlbnRUcmFja2VyLnJlc3RvcmUoY29udGV4dC5hZ2VudFN0ZXBzKTtcblxuICAgICAgICAvLyBSZXN0b3JlIHRvZG9zIGZyb20gb3V0cHV0XG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ1tMb2FkIE5vdGUgQ29udGV4dF0gT3V0cHV0IGxpbmVzIGNvdW50OicsIGNvbnRleHQub3V0cHV0TGluZXMubGVuZ3RoKTtcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnW0xvYWQgTm90ZSBDb250ZXh0XSBBZ2VudCBzdGVwcyBjb3VudDonLCBjb250ZXh0LmFnZW50U3RlcHMubGVuZ3RoKTtcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnW0xvYWQgTm90ZSBDb250ZXh0XSBpc1J1bm5pbmc6JywgY29udGV4dC5pc1J1bm5pbmcpO1xuXG4gICAgICAgIGlmIChjb250ZXh0Lm91dHB1dExpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBwYXJzZSB0b2RvcyBmcm9tIHRoZSByZXN0b3JlZCBvdXRwdXRcbiAgICAgICAgICAgIHRoaXMucGFyc2VUb2Rvc0Zyb21PdXRwdXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIG91dHB1dCwgY2xlYXIgdGhlIHRvZG8gbGlzdFxuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnW0xvYWQgTm90ZSBDb250ZXh0XSBDbGVhcmluZyB0b2RvIGxpc3QgLSBubyBvdXRwdXQnKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUb2RvTGlzdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIGhpc3RvcnlcbiAgICAgICAgdGhpcy51cGRhdGVIaXN0b3J5RGlzcGxheShjb250ZXh0Lmhpc3RvcnkpO1xuXG4gICAgICAgIC8vIFJlc3RvcmUgbW9kZWwgc2VsZWN0aW9uXG4gICAgICAgIGlmIChjb250ZXh0LnNlbGVjdGVkTW9kZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5tb2RlbFNlbGVjdC52YWx1ZSA9IGNvbnRleHQuc2VsZWN0ZWRNb2RlbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW9kZWxTZWxlY3QudmFsdWUgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5tb2RlbEFsaWFzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzdG9yZSBsYXN0IHByb21wdCBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKGNvbnRleHQubGFzdFByb21wdCkge1xuICAgICAgICAgICAgdGhpcy5zaG93TGFzdFByb21wdChjb250ZXh0Lmxhc3RQcm9tcHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oaWRlTGFzdFByb21wdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIFVJIGJhc2VkIG9uIHJ1bm5pbmcgc3RhdGVcbiAgICAgICAgaWYgKGNvbnRleHQuaXNSdW5uaW5nKSB7XG4gICAgICAgICAgICAvLyBOb3RlIGlzIGN1cnJlbnRseSBydW5uaW5nIC0gc2hvdyBydW5uaW5nIHN0YXRlXG4gICAgICAgICAgICB0aGlzLnJ1bkJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnJ1bkJ1dHRvbi50ZXh0Q29udGVudCA9IHQoJ2lucHV0LnJ1bm5pbmdCdXR0b24nKTtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsQnV0dG9uLnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsQnV0dG9uLmFkZENsYXNzKCdjbGF1ZGUtY29kZS1pbmxpbmUtdmlzaWJsZScpO1xuXG4gICAgICAgICAgICAvLyBSZXN1bWUgZWxhcHNlZCB0aW1lIHRyYWNraW5nIHdpdGggdGhlIG5vdGUncyBvd24gc3RhcnQgdGltZVxuICAgICAgICAgICAgdGhpcy5yZXN1bWVFbGFwc2VkVGltZVRyYWNraW5nKCk7XG5cbiAgICAgICAgICAgIC8vIFJlc3RvcmUgYW55IGFjY3VtdWxhdGVkIHN0cmVhbWluZyByZXN1bHQgdGV4dFxuICAgICAgICAgICAgaWYgKGNvbnRleHQuY3VycmVudFJlc3VsdFRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmVTdHJlYW1pbmdSZXN1bHQoY29udGV4dC5jdXJyZW50UmVzdWx0VGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTdG9wIHRpbWVyIHdoZW4gc3dpdGNoaW5nIHRvIG5vbi1ydW5uaW5nIG5vdGVcbiAgICAgICAgICAgIHRoaXMuc3RvcEVsYXBzZWRUaW1lVHJhY2tpbmcoKTtcbiAgICAgICAgICAgIC8vIE5vdGUgaXMgbm90IHJ1bm5pbmcgLSBzaG93IGlkbGUgc3RhdGVcbiAgICAgICAgICAgIHRoaXMucnVuQnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJ1bkJ1dHRvbi50ZXh0Q29udGVudCA9IHQoJ2lucHV0LnJ1bkJ1dHRvbicpO1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxCdXR0b24uYWRkQ2xhc3MoJ2NsYXVkZS1jb2RlLWhpZGRlbicpO1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxCdXR0b24ucmVtb3ZlQ2xhc3MoJ2NsYXVkZS1jb2RlLWlubGluZS12aXNpYmxlJyk7XG5cbiAgICAgICAgICAgIC8vIEhpZGUgc3RhdHVzIGluZGljYXRvciBmb3Igbm9uLXJ1bm5pbmcgbm90ZXNcbiAgICAgICAgICAgIHRoaXMuaGlkZVN0YXR1cygpO1xuXG4gICAgICAgICAgICAvLyBDbGVhciByZXN1bHQgc2VjdGlvbiBpZiB0aGVyZSdzIG5vIGN1cnJlbnQgcmVzcG9uc2VcbiAgICAgICAgICAgIGlmICghY29udGV4dC5jdXJyZW50UmVzcG9uc2UgfHwgIWNvbnRleHQuY3VycmVudFJlc3BvbnNlLmFzc2lzdGFudE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVSZXN1bHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVzdG9yZSByZXN1bHQgaWYgZXhpc3RzXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93UmVzdWx0KGNvbnRleHQuY3VycmVudFJlc3BvbnNlLmFzc2lzdGFudE1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzdG9yZSBwcmV2aWV3IHNlY3Rpb24gaWYgdGhlcmUncyBwZW5kaW5nIGNvbnRlbnQsIG90aGVyd2lzZSBoaWRlXG4gICAgICAgIGlmIChjb250ZXh0LnBlbmRpbmdQcmV2aWV3Q29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5yZXN0b3JlUHJldmlldyhjb250ZXh0LnBlbmRpbmdQcmV2aWV3Q29udGVudCwgY29udGV4dC5vcmlnaW5hbFByZXZpZXdDb250ZW50IHx8ICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZVByZXZpZXdVSSgpOyAgLy8gSnVzdCBoaWRlIFVJLCBkb24ndCBjbGVhciBjb250ZXh0XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXN0b3JlIHBlcm1pc3Npb24gYXBwcm92YWwgc2VjdGlvbiBpZiB0aGVyZSdzIGEgcGVuZGluZyBwZXJtaXNzaW9uIHJlcXVlc3RcbiAgICAgICAgaWYgKGNvbnRleHQuY3VycmVudFJlc3BvbnNlPy5pc1Blcm1pc3Npb25SZXF1ZXN0ICYmICFjb250ZXh0LmlzUnVubmluZykge1xuICAgICAgICAgICAgdGhpcy5zaG93UGVybWlzc2lvbkFwcHJvdmFsU2VjdGlvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oaWRlUGVybWlzc2lvbkFwcHJvdmFsU2VjdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGN1cnJlbnQgbm90ZSdzIGNvbnRleHRcbiAgICAgKi9cbiAgICBwcml2YXRlIGdldEN1cnJlbnRDb250ZXh0KCk6IE5vdGVDb250ZXh0IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dE1hbmFnZXIuZ2V0Q29udGV4dCh0aGlzLmN1cnJlbnROb3RlUGF0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIFJ1biBDbGF1ZGUgQ29kZSBidXR0b24gY2xpY2tcbiAgICAgKi9cbiAgICBwcml2YXRlIGFzeW5jIGhhbmRsZVJ1bkNsYXVkZUNvZGUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldEN1cnJlbnRDb250ZXh0KCk7XG5cbiAgICAgICAgLy8gUHJldmVudCBjb25jdXJyZW50IHJ1bnMgb24gdGhlIHNhbWUgbm90ZVxuICAgICAgICBpZiAoY29udGV4dC5pc1J1bm5pbmcpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UodCgnbm90aWNlLmFscmVhZHlQcm9jZXNzaW5nJykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHJvbXB0ID0gdGhpcy5wcm9tcHRJbnB1dC52YWx1ZS50cmltKCk7XG4gICAgICAgIGlmICghcHJvbXB0KSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKHQoJ25vdGljZS5lbnRlclByb21wdCcpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc2V0IHNjcm9sbCBzdGF0ZSBmb3IgbmV3IHJlcXVlc3RcbiAgICAgICAgdGhpcy5yZXNldFNjcm9sbFN0YXRlKCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBwcm9tcHQgaW5wdXRcbiAgICAgICAgICAgIHRoaXMucHJvbXB0SW5wdXQudmFsdWUgPSAnJztcblxuICAgICAgICAgICAgLy8gR2V0IGFjdGl2ZSBmaWxlXG4gICAgICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcbiAgICAgICAgICAgIGlmICghZmlsZSkge1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UodCgnbm90aWNlLm5vQWN0aXZlTm90ZScpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGxlYWYgdGhhdCBjb250YWlucyB0aGlzIGZpbGVcbiAgICAgICAgICAgIGNvbnN0IGxlYXZlcyA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWF2ZXNPZlR5cGUoJ21hcmtkb3duJyk7XG4gICAgICAgICAgICBsZXQgYWN0aXZlVmlldzogTWFya2Rvd25WaWV3IHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIFRyeSB0byBmaW5kIHRoZSBsZWFmIHdpdGggdGhlIGFjdGl2ZSBmaWxlXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxlYWYgb2YgbGVhdmVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlldyA9IGxlYWYudmlldyBhcyBNYXJrZG93blZpZXc7XG4gICAgICAgICAgICAgICAgaWYgKHZpZXcuZmlsZSAmJiB2aWV3LmZpbGUucGF0aCA9PT0gZmlsZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZhbGxiYWNrOiBqdXN0IHVzZSB0aGUgZmlyc3QgbWFya2Rvd24gdmlldyBpZiB3ZSBjb3VsZG4ndCBtYXRjaCBieSBmaWxlXG4gICAgICAgICAgICBpZiAoIWFjdGl2ZVZpZXcgJiYgbGVhdmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVWaWV3ID0gbGVhdmVzWzBdLnZpZXcgYXMgTWFya2Rvd25WaWV3O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWFjdGl2ZVZpZXcgfHwgIWFjdGl2ZVZpZXcuZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZSh0KCdub3RpY2Uubm9FZGl0b3InKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBlZGl0b3IgPSBhY3RpdmVWaWV3LmVkaXRvcjtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkVGV4dCA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHVzZVNlbGVjdGVkVGV4dE9ubHkgPSB0aGlzLnNlbGVjdGVkVGV4dE9ubHlDaGVja2JveC5jaGVja2VkICYmIHNlbGVjdGVkVGV4dDtcbiAgICAgICAgICAgIGNvbnN0IG5vdGVDb250ZW50ID0gZWRpdG9yLmdldFZhbHVlKCk7XG5cbiAgICAgICAgICAgIC8vIEdldCB2YXVsdCBwYXRoXG4gICAgICAgICAgICBjb25zdCB2YXVsdFBhdGggPSAodGhpcy5hcHAudmF1bHQuYWRhcHRlciBhcyBGaWxlU3lzdGVtQWRhcHRlcikuZ2V0QmFzZVBhdGgoKTtcbiAgICAgICAgICAgIGlmICghdmF1bHRQYXRoKSB7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZSh0KCdub3RpY2Uubm9WYXVsdFBhdGgnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcmVwYXJlIHJlcXVlc3RcbiAgICAgICAgICAgIGNvbnRleHQuY3VycmVudFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgbm90ZUNvbnRlbnQsXG4gICAgICAgICAgICAgICAgdXNlclByb21wdDogcHJvbXB0LFxuICAgICAgICAgICAgICAgIG5vdGVQYXRoOiBmaWxlLnBhdGgsXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRUZXh0OiB1c2VTZWxlY3RlZFRleHRPbmx5ID8gc2VsZWN0ZWRUZXh0IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHZhdWx0UGF0aDogdmF1bHRQYXRoLFxuICAgICAgICAgICAgICAgIGNvbmZpZ0RpcjogdGhpcy5hcHAudmF1bHQuY29uZmlnRGlyLFxuICAgICAgICAgICAgICAgIHJ1bnRpbWVNb2RlbE92ZXJyaWRlOiB0aGlzLm1vZGVsU2VsZWN0LnZhbHVlIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBjb252ZXJzYXRpb25hbE1vZGU6IHRoaXMuY29udmVyc2F0aW9uYWxNb2RlQ2hlY2tib3guY2hlY2tlZFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIFVJXG4gICAgICAgICAgICB0aGlzLnJ1bkJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnJ1bkJ1dHRvbi50ZXh0Q29udGVudCA9IHQoJ2lucHV0LnJ1bm5pbmdCdXR0b24nKTtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsQnV0dG9uLnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsQnV0dG9uLmFkZENsYXNzKCdjbGF1ZGUtY29kZS1pbmxpbmUtdmlzaWJsZScpO1xuICAgICAgICAgICAgY29udGV4dC5vdXRwdXRMaW5lcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRSZW5kZXJlci5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5hZ2VudFRyYWNrZXIuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUb2RvTGlzdCgpO1xuICAgICAgICAgICAgdGhpcy5oaWRlUHJldmlldygpO1xuICAgICAgICAgICAgdGhpcy5oaWRlUmVzdWx0KCk7XG5cbiAgICAgICAgICAgIC8vIENsZWFyIHJlc3VsdCBhcmVhIGZvciBuZXcgc3RyZWFtaW5nIG1lc3NhZ2VzXG4gICAgICAgICAgICB0aGlzLnJlc3VsdEFyZWEuZW1wdHkoKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlc3VsdFN0cmVhbWluZ0VsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5oaXRGaW5hbENvbnRlbnRNYXJrZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRleHQuY3VycmVudFJlc3VsdFRleHQgPSB1bmRlZmluZWQ7ICAvLyBDbGVhciBwZXItbm90ZSByZXN1bHQgdGV4dFxuXG4gICAgICAgICAgICAvLyBTaG93IHRoZSBsYXN0IHByb21wdFxuICAgICAgICAgICAgdGhpcy5zaG93TGFzdFByb21wdChwcm9tcHQpO1xuXG4gICAgICAgICAgICAvLyBTaG93IGluaXRpYWwgc3RhdHVzIHdpdGggZWxhcHNlZCB0aW1lIHRyYWNraW5nXG4gICAgICAgICAgICB0aGlzLnNob3dTdGF0dXMoJ1x1RDgzRVx1REQxNCAnICsgdCgnc3RhdHVzLnByb2Nlc3NpbmcnKSArICcuLi4gMC4wcycpO1xuICAgICAgICAgICAgdGhpcy5zdGFydEVsYXBzZWRUaW1lVHJhY2tpbmcoJ1x1RDgzRVx1REQxNCAnICsgdCgnc3RhdHVzLnByb2Nlc3NpbmcnKSk7XG5cbiAgICAgICAgICAgIC8vIENhcHR1cmUgdGhlIG5vdGUgcGF0aCBmb3IgdGhpcyBzcGVjaWZpYyBydW5cbiAgICAgICAgICAgIGNvbnN0IHJ1bk5vdGVQYXRoID0gZmlsZS5wYXRoO1xuXG4gICAgICAgICAgICAvLyBSdW4gQ2xhdWRlIENvZGVcbiAgICAgICAgICAgIGNvbnRleHQuaXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ3VycmVudE5vdGVMYWJlbCgpOyAgLy8gVXBkYXRlIGhlYWRlciB0byBzaG93IHJ1bm5pbmcgc3RhdGVcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29udGV4dC5ydW5uZXIucnVuKFxuICAgICAgICAgICAgY29udGV4dC5jdXJyZW50UmVxdWVzdCxcbiAgICAgICAgICAgIChsaW5lOiBzdHJpbmcsIGlzTWFya2Rvd24/OiBib29sZWFuLCBpc1N0cmVhbWluZz86IGJvb2xlYW4gfCBzdHJpbmcsIGlzQXNzaXN0YW50TWVzc2FnZT86IGJvb2xlYW4pID0+IHtcbiAgICAgICAgICAgICAgICAvLyBBcHBlbmQgb3V0cHV0IHRvIHRoZSBTUEVDSUZJQyBub3RlIGNvbnRleHQgdGhhdCBzdGFydGVkIHRoaXMgcnVuXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRPdXRwdXRUb05vdGUocnVuTm90ZVBhdGgsIGxpbmUsIGlzTWFya2Rvd24sIGlzU3RyZWFtaW5nLCBpc0Fzc2lzdGFudE1lc3NhZ2UpO1xuXG4gICAgICAgICAgICAgICAgLy8gT25seSB1cGRhdGUgc3RhdHVzIGlmIHRoaXMgaXMgc3RpbGwgdGhlIGFjdGl2ZSBub3RlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vdGVQYXRoID09PSBydW5Ob3RlUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXR1c0Zyb21PdXRwdXQobGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29udGV4dC5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRleHQuY3VycmVudFJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgICAgICBjb250ZXh0LmV4ZWN1dGlvblN0YXJ0VGltZSA9IHVuZGVmaW5lZDsgIC8vIENsZWFyIHBlci1ub3RlIHRpbWluZ1xuICAgICAgICAgICAgY29udGV4dC5iYXNlU3RhdHVzTWVzc2FnZSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgLy8gSGlkZSBzdGF0dXNcbiAgICAgICAgICAgIHRoaXMuaGlkZVN0YXR1cygpO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgVUlcbiAgICAgICAgICAgIHRoaXMucnVuQnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJ1bkJ1dHRvbi50ZXh0Q29udGVudCA9IHQoJ2lucHV0LnJ1bkJ1dHRvbicpO1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxCdXR0b24uYWRkQ2xhc3MoJ2NsYXVkZS1jb2RlLWhpZGRlbicpO1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxCdXR0b24ucmVtb3ZlQ2xhc3MoJ2NsYXVkZS1jb2RlLWlubGluZS12aXNpYmxlJyk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBoZWFkZXIgdG8gcmVmbGVjdCBydW5uaW5nIHN0YXRlIGNoYW5nZVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDdXJyZW50Tm90ZUxhYmVsKCk7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSByZXNwb25zZVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIC8vIEFkZCB0byBoaXN0b3J5XG4gICAgICAgICAgICBjb250ZXh0Lmhpc3RvcnkucHVzaCh7XG4gICAgICAgICAgICAgICAgcHJvbXB0OiBwcm9tcHQsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgbm90ZVBhdGg6IGZpbGUucGF0aCxcbiAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogY29udGV4dC5jdXJyZW50UmVxdWVzdCxcbiAgICAgICAgICAgICAgICBvdXRwdXRMaW5lczogY29udGV4dC5vdXRwdXRMaW5lc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlSGlzdG9yeURpc3BsYXkoY29udGV4dC5oaXN0b3J5KTtcblxuICAgICAgICAgICAgLy8gU2F2ZSBjb250ZXh0IHdpdGggZXJyb3IgaGFuZGxpbmdcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0TWFuYWdlci5zYXZlQ29udGV4dChmaWxlLnBhdGgsIHZhdWx0UGF0aCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIGNvbnRleHQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTaG93IHByZXZpZXcgb3IgYXV0by1hcHBseVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm1vZGlmaWVkQ29udGVudCAmJiByZXNwb25zZS5tb2RpZmllZENvbnRlbnQudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXV0b0FjY2VwdENoZWNrYm94LmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSB1cGRhdGUgVUkgaWYgdGhpcyBpcyBzdGlsbCB0aGUgYWN0aXZlIG5vdGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vdGVQYXRoID09PSBydW5Ob3RlUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93U3RhdHVzKCdcdTI3MDUgJyArIHQoJ3N0YXR1cy5hdXRvQXBwbHlpbmcnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBseUNoYW5nZXNUb0VkaXRvcihyZXNwb25zZS5tb2RpZmllZENvbnRlbnQsIGVkaXRvcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhpZGUgc3RhdHVzIGFmdGVyIGF1dG8tYXBwbHlpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vdGVQYXRoID09PSBydW5Ob3RlUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlU3RhdHVzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnXHUyNzEzICcgKyB0KCdub3RpY2UuY2hhbmdlc0FwcGxpZWQnKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93UHJldmlldyhyZXNwb25zZS5tb2RpZmllZENvbnRlbnQsIHJ1bk5vdGVQYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBwZXJtaXNzaW9uIHJlcXVlc3RcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuaXNQZXJtaXNzaW9uUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHNob3cgVUkgaWYgdGhpcyBpcyBzdGlsbCB0aGUgYWN0aXZlIG5vdGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vdGVQYXRoID09PSBydW5Ob3RlUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdyBwZXJtaXNzaW9uIGFwcHJvdmFsIFVJXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dQZXJtaXNzaW9uQXBwcm92YWxTZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG93IHRoZSByZXF1ZXN0IGluIHRoZSByZXN1bHQgcGFuZWwgKG9ubHkgaWYgbm90IGFscmVhZHkgc3RyZWFtZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRTZWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NsYXVkZS1jb2RlLXJlc3VsdC1zZWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNTdHJlYW1lZENvbnRlbnQgPSByZXN1bHRTZWN0aW9uICYmIHJlc3VsdFNlY3Rpb24uaGFzQ2xhc3MoJ2NsYXVkZS1jb2RlLXZpc2libGUnKSAmJiB0aGlzLnJlc3VsdEFyZWEuY2hpbGRyZW4ubGVuZ3RoID4gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNTdHJlYW1lZENvbnRlbnQgJiYgcmVzcG9uc2UuYXNzaXN0YW50TWVzc2FnZSAmJiByZXNwb25zZS5hc3Npc3RhbnRNZXNzYWdlLnRyaW0oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd1Jlc3VsdChyZXNwb25zZS5hc3Npc3RhbnRNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdcdTI2QTBcdUZFMEYgJyArIHQoJ25vdGljZS5wZXJtaXNzaW9uUmVxdWVzdCcpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBmaWxlIGNoYW5nZXMgLSBzaG93IHJlc3VsdCBwYW5lbCB3aXRoIENsYXVkZSdzIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgdXBkYXRlIFVJIGlmIHRoaXMgaXMgc3RpbGwgdGhlIGFjdGl2ZSBub3RlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnROb3RlUGF0aCA9PT0gcnVuTm90ZVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgY2FsbCBzaG93UmVzdWx0IGlmIHdlIGhhdmVuJ3QgYmVlbiBzdHJlYW1pbmcgKHN0cmVhbWluZyBhbHJlYWR5IHJlbmRlcmVkIHRoZSByZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRTZWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NsYXVkZS1jb2RlLXJlc3VsdC1zZWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNTdHJlYW1lZENvbnRlbnQgPSByZXN1bHRTZWN0aW9uICYmIHJlc3VsdFNlY3Rpb24uaGFzQ2xhc3MoJ2NsYXVkZS1jb2RlLXZpc2libGUnKSAmJiB0aGlzLnJlc3VsdEFyZWEuY2hpbGRyZW4ubGVuZ3RoID4gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNTdHJlYW1lZENvbnRlbnQgJiYgcmVzcG9uc2UuYXNzaXN0YW50TWVzc2FnZSAmJiByZXNwb25zZS5hc3Npc3RhbnRNZXNzYWdlLnRyaW0oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd1Jlc3VsdChyZXNwb25zZS5hc3Npc3RhbnRNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdcdTI3MTMgJyArIHQoJ25vdGljZS5jb21wbGV0ZWQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhc1N0cmVhbWVkQ29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3VsdCB3YXMgYWxyZWFkeSBzdHJlYW1lZCwganVzdCBzaG93IG5vdGljZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1x1MjcxMyAnICsgdCgnbm90aWNlLmNvbXBsZXRlZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnXHUyNzEzICcgKyB0KCdub3RpY2UuY29tcGxldGVkTm9DaGFuZ2VzJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2lsZW50bHkgY29tcGxldGUgLSB1c2VyIGlzIG9uIGEgZGlmZmVyZW50IG5vdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1x1MjcxMyAnICsgdCgnbm90aWNlLmNvbXBsZXRlZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSBVSSBpZiB0aGlzIGlzIHN0aWxsIHRoZSBhY3RpdmUgbm90ZVxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vdGVQYXRoID09PSBydW5Ob3RlUGF0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Vycm9yU3RhdHVzKCdcdTI3NEMgJyArIHQoJ3N0YXR1cy5mYWlsZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXcgTm90aWNlKGBcdTI3MTcgJHtyZXNwb25zZS5lcnJvciB8fCAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICAgICAgICBjb250ZXh0Lmhpc3RvcnkucHVzaCh7XG4gICAgICAgICAgICAgICAgcHJvbXB0OiBwcm9tcHQsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG5vdGVQYXRoOiBmaWxlLnBhdGgsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IGNvbnRleHQuY3VycmVudFJlcXVlc3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVIaXN0b3J5RGlzcGxheShjb250ZXh0Lmhpc3RvcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gSWYgYW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIGV4ZWN1dGlvbiwgbWFrZSBzdXJlIHRvIHJlc2V0IHRoZSBydW5uaW5nIHN0YXRlXG4gICAgICAgICAgICBjb250ZXh0LmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgY29udGV4dC5leGVjdXRpb25TdGFydFRpbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb250ZXh0LmJhc2VTdGF0dXNNZXNzYWdlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmQgb3V0cHV0IHRvIGEgc3BlY2lmaWMgbm90ZSdzIGNvbnRleHRcbiAgICAgKi9cbiAgICBwcml2YXRlIGFwcGVuZE91dHB1dFRvTm90ZShub3RlUGF0aDogc3RyaW5nLCB0ZXh0OiBzdHJpbmcsIGlzTWFya2Rvd246IGJvb2xlYW4gPSBmYWxzZSwgaXNTdHJlYW1pbmc6IGJvb2xlYW4gfCBzdHJpbmcgPSBmYWxzZSwgaXNBc3Npc3RhbnRNZXNzYWdlOiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dE1hbmFnZXIuZ2V0Q29udGV4dChub3RlUGF0aCk7XG4gICAgICAgIGNvbnRleHQub3V0cHV0TGluZXMucHVzaCh0ZXh0KTtcblxuICAgICAgICAvLyBTdG9yZSBzdHJlYW1pbmcgcmVzdWx0IHRleHQgaW4gdGhlIENPUlJFQ1Qgbm90ZSdzIGNvbnRleHQgKG5vdCBjdXJyZW50IG5vdGUpXG4gICAgICAgIGlmIChpc0Fzc2lzdGFudE1lc3NhZ2UgJiYgaXNTdHJlYW1pbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIEFjY3VtdWxhdGUgcmVzdWx0IHRleHQgaW4gdGhlIHRhcmdldCBub3RlJ3MgY29udGV4dFxuICAgICAgICAgICAgY29udGV4dC5jdXJyZW50UmVzdWx0VGV4dCA9IChjb250ZXh0LmN1cnJlbnRSZXN1bHRUZXh0IHx8ICcnKSArIHRleHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQYXJzZSBhbmQgc3RvcmUgYWdlbnQgYWN0aXZpdHkgaW4gdGhlIG5vdGUncyBjb250ZXh0IChyZWdhcmRsZXNzIG9mIGN1cnJlbnQgdmlldylcbiAgICAgICAgLy8gU2tpcCBmb3Igc3RyZWFtaW5nIHBhcnRpYWwgdGV4dFxuICAgICAgICBpZiAoaXNTdHJlYW1pbmcgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFnZW50U3RlcCA9IE91dHB1dFJlbmRlcmVyLnBhcnNlQWdlbnRBY3Rpdml0eSh0ZXh0KTtcbiAgICAgICAgICAgIGlmIChhZ2VudFN0ZXApIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmFnZW50U3RlcHMucHVzaChhZ2VudFN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25seSB1cGRhdGUgVUkgaWYgdGhpcyBpcyB0aGUgY3VycmVudCBub3RlIGJlaW5nIHZpZXdlZFxuICAgICAgICBpZiAobm90ZVBhdGggPT09IHRoaXMuY3VycmVudE5vdGVQYXRoKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgc3RyZWFtaW5nIHRleHQgYWNjdW11bGF0aW9uXG4gICAgICAgICAgICBpZiAoaXNTdHJlYW1pbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFJlbmRlcmVyLmFwcGVuZFN0cmVhbWluZ1RleHQodGV4dCk7XG5cbiAgICAgICAgICAgICAgICAvLyBBbHNvIGFwcGVuZCB0byBSZXN1bHQgc2VjdGlvbiBpZiBpdCdzIGFuIGFzc2lzdGFudCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnW0FwcGVuZCBPdXRwdXRdIGlzU3RyZWFtaW5nPXRydWUsIGlzQXNzaXN0YW50TWVzc2FnZT0nLCBpc0Fzc2lzdGFudE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGlmIChpc0Fzc2lzdGFudE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRUb1Jlc3VsdFVJKHRleHQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gRG9uJ3QgcHJvY2VzcyBhZ2VudCBhY3Rpdml0eSBmb3IgcGFydGlhbCB0ZXh0XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyZWFtaW5nID09PSAnZmluaXNoJykge1xuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0UmVuZGVyZXIuZmluaXNoU3RyZWFtaW5nQmxvY2soKTtcblxuICAgICAgICAgICAgICAgIC8vIEFsc28gZmluaXNoIHJlc3VsdCBzdHJlYW1pbmcgaWYgdGhlcmUncyBhbiBhY3RpdmUgc3RyZWFtXG4gICAgICAgICAgICAgICAgaWYgKGlzQXNzaXN0YW50TWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaFJlc3VsdFN0cmVhbWluZygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZhbGwgdGhyb3VnaCB0byBwcm9jZXNzIHRoZSBuZXdsaW5lIG5vcm1hbGx5XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQXNzaXN0YW50TWVzc2FnZSAmJiAhaXNTdHJlYW1pbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgbm9uLXN0cmVhbWluZyBhc3Npc3RhbnQgbWVzc2FnZXMgKGUuZy4sIGZyb20gYXNzaXN0YW50IGV2ZW50cylcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGFkZCBpZiB3ZSBoYXZlbid0IGJlZW4gc3RyZWFtaW5nIChhdm9pZCBkdXBsaWNhdGVzKVxuICAgICAgICAgICAgICAgIGNvbnN0IGhhc1N0cmVhbWluZ0NvbnRlbnQgPSB0aGlzLmN1cnJlbnRSZXN1bHRTdHJlYW1pbmdFbGVtZW50ICE9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5yZXN1bHRBcmVhICYmIHRoaXMucmVzdWx0QXJlYS5jaGlsZHJlbi5sZW5ndGggPiAwKTtcblxuICAgICAgICAgICAgICAgIGlmICghaGFzU3RyZWFtaW5nQ29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdbQXBwZW5kIE91dHB1dF0gTm9uLXN0cmVhbWluZyBhc3Npc3RhbnQgbWVzc2FnZSwgYWRkaW5nIHRvIHJlc3VsdCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dSZXN1bHRNYXJrZG93bih0ZXh0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdbQXBwZW5kIE91dHB1dF0gTm9uLXN0cmVhbWluZyBhc3Npc3RhbnQgbWVzc2FnZSwgYnV0IGFscmVhZHkgaGF2ZSBzdHJlYW1pbmcgY29udGVudCAtIHNraXBwaW5nJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZhbGwgdGhyb3VnaCB0byBhbHNvIGFkZCB0byBvdXRwdXRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5vdXRwdXRSZW5kZXJlci5hcHBlbmRMaW5lKHRleHQsIGlzTWFya2Rvd24pO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgVUkgYWdlbnQgYWN0aXZpdHkgdHJhY2tlciB3aXRoIHRpbWluZyAoVUkgb25seSlcbiAgICAgICAgICAgIGNvbnN0IGFnZW50U3RlcCA9IE91dHB1dFJlbmRlcmVyLnBhcnNlQWdlbnRBY3Rpdml0eSh0ZXh0KTtcbiAgICAgICAgICAgIGlmIChhZ2VudFN0ZXApIHtcbiAgICAgICAgICAgICAgICAvLyBEZXRlY3QgaWYgdGhpcyBpcyBhIHRvb2wgc3RhcnRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1Rvb2xTdGFydCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSBzdGFydCB0aW1lIGFuZCByZW1lbWJlciB0aGlzIHRvb2wncyBrZXlcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b29sU3RhcnRUaW1lcy5zZXQoYWdlbnRTdGVwLmtleSwgbm93KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0VG9vbEtleSA9IGFnZW50U3RlcC5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGFnZW50U3RlcC5zdGFydFRpbWUgPSBub3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIERldGVjdCBpZiB0aGlzIGlzIGEgdG9vbCBjb21wbGV0aW9uXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc1Rvb2xDb21wbGV0ZSh0ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCB0byB0aGUgbGFzdCBzdGFydGVkIHRvb2xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGFzdFRvb2xLZXkgJiYgdGhpcy50b29sU3RhcnRUaW1lcy5oYXModGhpcy5sYXN0VG9vbEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHRoaXMudG9vbFN0YXJ0VGltZXMuZ2V0KHRoaXMubGFzdFRvb2xLZXkpITtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBvcmlnaW5hbCBzdGVwIHdpdGggZHVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWdlbnRUcmFja2VyLmFkZFN0ZXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmFnZW50U3RlcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHRoaXMubGFzdFRvb2xLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b29sU3RhcnRUaW1lcy5kZWxldGUodGhpcy5sYXN0VG9vbEtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RUb29sS2V5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuYWdlbnRUcmFja2VyLmFkZFN0ZXAoYWdlbnRTdGVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIG91dHB1dCBsaW5lIGluZGljYXRlcyBhIHRvb2wgaXMgc3RhcnRpbmdcbiAgICAgKi9cbiAgICBwcml2YXRlIGlzVG9vbFN0YXJ0KHRleHQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGV4dC5pbmNsdWRlcygnXHVEODNEXHVERDI3IFVzaW5nIHRvb2w6JykgfHxcbiAgICAgICAgICAgICAgIHRleHQuaW5jbHVkZXMoJyQgJykgfHxcbiAgICAgICAgICAgICAgIHRleHQuaW5jbHVkZXMoJ1x1RDgzRFx1REQwRCBHbG9iIHNlYXJjaGluZzonKSB8fFxuICAgICAgICAgICAgICAgdGV4dC5pbmNsdWRlcygnXHVEODNEXHVERDBFIEdyZXAgc2VhcmNoaW5nOicpIHx8XG4gICAgICAgICAgICAgICB0ZXh0LmluY2x1ZGVzKCdcdUQ4M0RcdURDRDYgUmVhZGluZyBmaWxlOicpIHx8XG4gICAgICAgICAgICAgICB0ZXh0LmluY2x1ZGVzKCdcdTI3MERcdUZFMEYgIFdyaXRpbmcgZmlsZTonKSB8fFxuICAgICAgICAgICAgICAgdGV4dC5pbmNsdWRlcygnXHUyNzBGXHVGRTBGICBFZGl0aW5nIGZpbGU6JykgfHxcbiAgICAgICAgICAgICAgIHRleHQuaW5jbHVkZXMoJ1x1RDgzQ1x1REYxMCBGZXRjaGluZyB3ZWJwYWdlOicpIHx8XG4gICAgICAgICAgICAgICB0ZXh0LmluY2x1ZGVzKCdcdUQ4M0RcdUREMEQgV2ViIHNlYXJjaGluZzonKSB8fFxuICAgICAgICAgICAgICAgdGV4dC5pbmNsdWRlcygnXHVEODNFXHVERDE2IExhdW5jaGluZyBhZ2VudDonKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBvdXRwdXQgbGluZSBpbmRpY2F0ZXMgYSB0b29sIGNvbXBsZXRlZFxuICAgICAqL1xuICAgIHByaXZhdGUgaXNUb29sQ29tcGxldGUodGV4dDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIC8vIE1hdGNoIHNwZWNpZmljIHRvb2wgY29tcGxldGlvbiBwYXR0ZXJucyBmcm9tIHN0cmVhbS1ldmVudC1wcm9jZXNzb3IudHNcbiAgICAgICAgcmV0dXJuIHRleHQuaW5jbHVkZXMoJ1x1MjcxMyBGb3VuZCcpIHx8ICAgICAgICAgICAvLyBHbG9iL0dyZXAgcmVzdWx0c1xuICAgICAgICAgICAgICAgdGV4dC5pbmNsdWRlcygnXHUyNzEzIE91dHB1dCcpIHx8ICAgICAgICAgIC8vIEJhc2ggb3V0cHV0XG4gICAgICAgICAgICAgICB0ZXh0LmluY2x1ZGVzKCdjb21wbGV0ZScpIHx8ICAgICAgICAgIC8vIEdlbmVyaWMgY29tcGxldGlvblxuICAgICAgICAgICAgICAgdGV4dC5pbmNsdWRlcygnXHVEODNEXHVEQ0U1IFRvb2wgcmVzdWx0Jyk7ICAgICAgLy8gVG9vbCByZXN1bHQgZXZlbnRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgc3RhdHVzIGJhc2VkIG9uIG91dHB1dCBsaW5lXG4gICAgICovXG4gICAgcHJpdmF0ZSB1cGRhdGVTdGF0dXNGcm9tT3V0cHV0KGxpbmU6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBPdXRwdXRTdGF0dXNNYW5hZ2VyLmV4dHJhY3RTdGF0dXMobGluZSk7XG4gICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd1N0YXR1cyhzdGF0dXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZWN0IFRvZG9Xcml0ZSB0b29sIHVzYWdlICh3aXRoIG9yIHdpdGhvdXQgZW1vamkpXG4gICAgICAgIGlmIChsaW5lLmluY2x1ZGVzKCdVc2luZyB0b29sOiBUb2RvV3JpdGUnKSB8fCBsaW5lLmluY2x1ZGVzKCdcdUQ4M0RcdUREMjcgVXNpbmcgdG9vbDogVG9kb1dyaXRlJykpIHtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIHBhcnNpbmcgYWZ0ZXIgYSBzaG9ydCBkZWxheSB0byBlbnN1cmUgYWxsIG91dHB1dCBpcyBjYXB0dXJlZFxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnBhcnNlVG9kb3NGcm9tT3V0cHV0KCksIDEwMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSB0b2RvcyBmcm9tIHRoZSBvdXRwdXQgbGluZXNcbiAgICAgKi9cbiAgICBwcml2YXRlIHBhcnNlVG9kb3NGcm9tT3V0cHV0KCk6IHZvaWQge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDdXJyZW50Q29udGV4dCgpO1xuXG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ1tQYXJzZSBUb2Rvc10gVG90YWwgb3V0cHV0IGxpbmVzOicsIGNvbnRleHQub3V0cHV0TGluZXMubGVuZ3RoKTtcblxuICAgICAgICAvLyBGaW5kIEFMTCBUb2RvV3JpdGUgdG9vbCB1c2FnZSBsaW5lc1xuICAgICAgICBjb25zdCB0b2RvV3JpdGVJbmRpY2VzOiBudW1iZXJbXSA9IFtdO1xuICAgICAgICBjb250ZXh0Lm91dHB1dExpbmVzLmZvckVhY2goKGxpbmUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAobGluZS5pbmNsdWRlcygnVXNpbmcgdG9vbDogVG9kb1dyaXRlJykpIHtcbiAgICAgICAgICAgICAgICB0b2RvV3JpdGVJbmRpY2VzLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zb2xlLmRlYnVnKCdbUGFyc2UgVG9kb3NdIEZvdW5kIFRvZG9Xcml0ZSBhdCBpbmRpY2VzOicsIHRvZG9Xcml0ZUluZGljZXMpO1xuXG4gICAgICAgIGlmICh0b2RvV3JpdGVJbmRpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnW1BhcnNlIFRvZG9zXSBObyBUb2RvV3JpdGUgZm91bmQgaW4gb3V0cHV0IGxpbmVzJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVc2UgdGhlIExBU1QgVG9kb1dyaXRlIChtb3N0IHJlY2VudCB1cGRhdGUpXG4gICAgICAgIGNvbnN0IGxhc3RUb2RvV3JpdGVJbmRleCA9IHRvZG9Xcml0ZUluZGljZXNbdG9kb1dyaXRlSW5kaWNlcy5sZW5ndGggLSAxXTtcblxuICAgICAgICBjb25zb2xlLmRlYnVnKCdbUGFyc2UgVG9kb3NdIFVzaW5nIGxhc3QgVG9kb1dyaXRlIGF0IGluZGV4OicsIGxhc3RUb2RvV3JpdGVJbmRleCk7XG5cbiAgICAgICAgaWYgKGxhc3RUb2RvV3JpdGVJbmRleCArIDEgPCBjb250ZXh0Lm91dHB1dExpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gVGhlIG5leHQgbGluZSBhZnRlciBcIlVzaW5nIHRvb2w6IFRvZG9Xcml0ZVwiIHNob3VsZCBjb250YWluIHRoZSBKU09OXG4gICAgICAgICAgICBjb25zdCBqc29uTGluZSA9IGNvbnRleHQub3V0cHV0TGluZXNbbGFzdFRvZG9Xcml0ZUluZGV4ICsgMV07XG5cbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1tQYXJzZSBUb2Rvc10gSlNPTiBsaW5lIGxlbmd0aDonLCBqc29uTGluZS5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnW1BhcnNlIFRvZG9zXSBKU09OIGxpbmUgcHJldmlldzonLCBqc29uTGluZS5zdWJzdHJpbmcoMCwgMzAwKSk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIEpTT04gaXMgdGhlIGVudGlyZSBsaW5lLCBqdXN0IHRyaW0gd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgIGNvbnN0IGpzb25TdHIgPSBqc29uTGluZS50cmltKCk7XG5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdbUGFyc2UgVG9kb3NdIFRyaW1tZWQgSlNPTiBsZW5ndGg6JywganNvblN0ci5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1tQYXJzZSBUb2Rvc10gRmlyc3QgY2hhcjonLCBqc29uU3RyWzBdLCAnTGFzdCBjaGFyOicsIGpzb25TdHJbanNvblN0ci5sZW5ndGggLSAxXSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB0b29sSW5wdXQgPSBKU09OLnBhcnNlKGpzb25TdHIpIGFzIFRvZG9Ub29sSW5wdXQ7XG5cbiAgICAgICAgICAgICAgICBpZiAodG9vbElucHV0LnRvZG9zICYmIEFycmF5LmlzQXJyYXkodG9vbElucHV0LnRvZG9zKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdbUGFyc2UgVG9kb3NdIEZvdW5kIHRvZG9zIGNvdW50OicsIHRvb2xJbnB1dC50b2Rvcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdbUGFyc2UgVG9kb3NdIFRvZG9zOicsIEpTT04uc3RyaW5naWZ5KHRvb2xJbnB1dC50b2RvcywgbnVsbCwgMikpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRvZG9MaXN0KHRvb2xJbnB1dC50b2Rvcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnW1BhcnNlIFRvZG9zXSBObyB0b2RvcyBhcnJheSBmb3VuZCBpbiBwYXJzZWQgSlNPTicpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdbUGFyc2UgVG9kb3NdIFBhcnNlZCBvYmplY3Qga2V5czonLCBPYmplY3Qua2V5cyh0b29sSW5wdXQgYXMgb2JqZWN0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbUGFyc2UgVG9kb3NdIEZhaWxlZCB0byBwYXJzZSB0b2RvcyBKU09OOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbUGFyc2UgVG9kb3NdIEVycm9yIGRldGFpbHM6JywgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBlcnJvcik7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHNob3cgd2hlcmUgdGhlIEpTT04gaXMgYnJlYWtpbmdcbiAgICAgICAgICAgICAgICBjb25zdCBqc29uU3RyID0ganNvbkxpbmUudHJpbSgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tQYXJzZSBUb2Rvc10gRnVsbCBKU09OIHN0cmluZzonLCBqc29uU3RyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3cgc3RhdHVzIGluZGljYXRvclxuICAgICAqL1xuICAgIHByaXZhdGUgc2hvd1N0YXR1cyhtZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgLy8gU2hvdyBSZXN1bHQgc2VjdGlvblxuICAgICAgICBjb25zdCByZXN1bHRTZWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NsYXVkZS1jb2RlLXJlc3VsdC1zZWN0aW9uJyk7XG4gICAgICAgIGlmIChyZXN1bHRTZWN0aW9uKSB7XG4gICAgICAgICAgICByZXN1bHRTZWN0aW9uLnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgICAgIHJlc3VsdFNlY3Rpb24uYWRkQ2xhc3MoJ2NsYXVkZS1jb2RlLXZpc2libGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNob3cgc3RhdHVzIGFyZWEsIGhpZGUgcmVzdWx0IGFyZWFcbiAgICAgICAgdGhpcy5zdGF0dXNJbmRpY2F0b3IucmVtb3ZlQ2xhc3MoJ2NsYXVkZS1jb2RlLWhpZGRlbicpO1xuICAgICAgICB0aGlzLnN0YXR1c0luZGljYXRvci5hZGRDbGFzcygnY2xhdWRlLWNvZGUtZmxleC12aXNpYmxlJyk7XG4gICAgICAgIHRoaXMucmVzdWx0QXJlYS5hZGRDbGFzcygnY2xhdWRlLWNvZGUtaGlkZGVuJyk7XG4gICAgICAgIHRoaXMucmVzdWx0QXJlYS5yZW1vdmVDbGFzcygnY2xhdWRlLWNvZGUtdmlzaWJsZScpO1xuICAgICAgICB0aGlzLnN0YXR1c1RleHQudGV4dENvbnRlbnQgPSBtZXNzYWdlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3cgZXJyb3Igc3RhdHVzIHdpdGhvdXQgcHJvZ3Jlc3MgYmFyIGFuaW1hdGlvblxuICAgICAqL1xuICAgIHByaXZhdGUgc2hvd0Vycm9yU3RhdHVzKG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLnN0b3BFbGFwc2VkVGltZVRyYWNraW5nKCk7XG5cbiAgICAgICAgLy8gU2hvdyBSZXN1bHQgc2VjdGlvblxuICAgICAgICBjb25zdCByZXN1bHRTZWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NsYXVkZS1jb2RlLXJlc3VsdC1zZWN0aW9uJyk7XG4gICAgICAgIGlmIChyZXN1bHRTZWN0aW9uKSB7XG4gICAgICAgICAgICByZXN1bHRTZWN0aW9uLnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgICAgIHJlc3VsdFNlY3Rpb24uYWRkQ2xhc3MoJ2NsYXVkZS1jb2RlLXZpc2libGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNob3cgc3RhdHVzIGFyZWEsIGhpZGUgcmVzdWx0IGFyZWFcbiAgICAgICAgdGhpcy5zdGF0dXNJbmRpY2F0b3IucmVtb3ZlQ2xhc3MoJ2NsYXVkZS1jb2RlLWhpZGRlbicpO1xuICAgICAgICB0aGlzLnN0YXR1c0luZGljYXRvci5hZGRDbGFzcygnY2xhdWRlLWNvZGUtZmxleC12aXNpYmxlJyk7XG4gICAgICAgIHRoaXMucmVzdWx0QXJlYS5hZGRDbGFzcygnY2xhdWRlLWNvZGUtaGlkZGVuJyk7XG4gICAgICAgIHRoaXMucmVzdWx0QXJlYS5yZW1vdmVDbGFzcygnY2xhdWRlLWNvZGUtdmlzaWJsZScpO1xuICAgICAgICB0aGlzLnN0YXR1c1RleHQudGV4dENvbnRlbnQgPSBtZXNzYWdlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGVsYXBzZWQgdGltZSB0cmFja2luZyAoc3RvcmVzIHRpbWluZyBpbiBwZXItbm90ZSBjb250ZXh0KVxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhcnRFbGFwc2VkVGltZVRyYWNraW5nKGJhc2VNZXNzYWdlPzogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldEN1cnJlbnRDb250ZXh0KCk7XG4gICAgICAgIGNvbnRleHQuZXhlY3V0aW9uU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29udGV4dC5iYXNlU3RhdHVzTWVzc2FnZSA9IGJhc2VNZXNzYWdlIHx8ICdcdUQ4M0VcdUREMTQgQ2xhdWRlIGlzIHByb2Nlc3NpbmcnO1xuXG4gICAgICAgIC8vIFN0b3AgYW55IGV4aXN0aW5nIGludGVydmFsIGJlZm9yZSBzdGFydGluZyBhIG5ldyBvbmVcbiAgICAgICAgdGhpcy5zdG9wRWxhcHNlZFRpbWVUcmFja2luZygpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0dXMgZXZlcnkgMTAwbXMgd2l0aCBlbGFwc2VkIHRpbWVcbiAgICAgICAgdGhpcy5lbGFwc2VkVGltZUludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5nZXRDdXJyZW50Q29udGV4dCgpO1xuICAgICAgICAgICAgaWYgKGN0eC5leGVjdXRpb25TdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIGN0eC5leGVjdXRpb25TdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vjb25kcyA9IChlbGFwc2VkIC8gMTAwMCkudG9GaXhlZCgxKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c1RleHQudGV4dENvbnRlbnQgPSBgJHtjdHguYmFzZVN0YXR1c01lc3NhZ2UgfHwgJ1x1RDgzRVx1REQxNCBQcm9jZXNzaW5nJ30uLi4gJHtzZWNvbmRzfXNgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAxMDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc3VtZSBlbGFwc2VkIHRpbWUgdHJhY2tpbmcgZm9yIGN1cnJlbnQgbm90ZSAodXNlZCB3aGVuIHN3aXRjaGluZyBiYWNrIHRvIGEgcnVubmluZyBub3RlKVxuICAgICAqL1xuICAgIHByaXZhdGUgcmVzdW1lRWxhcHNlZFRpbWVUcmFja2luZygpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q3VycmVudENvbnRleHQoKTtcbiAgICAgICAgaWYgKCFjb250ZXh0LmV4ZWN1dGlvblN0YXJ0VGltZSB8fCAhY29udGV4dC5pc1J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0b3AgYW55IGV4aXN0aW5nIGludGVydmFsXG4gICAgICAgIHRoaXMuc3RvcEVsYXBzZWRUaW1lVHJhY2tpbmcoKTtcblxuICAgICAgICAvLyBTdGFydCBpbnRlcnZhbCB1c2luZyB0aGUgbm90ZSdzIGV4aXN0aW5nIHN0YXJ0IHRpbWVcbiAgICAgICAgdGhpcy5lbGFwc2VkVGltZUludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5nZXRDdXJyZW50Q29udGV4dCgpO1xuICAgICAgICAgICAgaWYgKGN0eC5leGVjdXRpb25TdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIGN0eC5leGVjdXRpb25TdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vjb25kcyA9IChlbGFwc2VkIC8gMTAwMCkudG9GaXhlZCgxKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c1RleHQudGV4dENvbnRlbnQgPSBgJHtjdHguYmFzZVN0YXR1c01lc3NhZ2UgfHwgJ1x1RDgzRVx1REQxNCBQcm9jZXNzaW5nJ30uLi4gJHtzZWNvbmRzfXNgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAxMDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3AgZWxhcHNlZCB0aW1lIHRyYWNraW5nXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdG9wRWxhcHNlZFRpbWVUcmFja2luZygpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZWxhcHNlZFRpbWVJbnRlcnZhbCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmVsYXBzZWRUaW1lSW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhpcy5lbGFwc2VkVGltZUludGVydmFsID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhpZGUgc3RhdHVzIGluZGljYXRvclxuICAgICAqL1xuICAgIHByaXZhdGUgaGlkZVN0YXR1cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zdG9wRWxhcHNlZFRpbWVUcmFja2luZygpO1xuICAgICAgICB0aGlzLnN0YXR1c0luZGljYXRvci5hZGRDbGFzcygnY2xhdWRlLWNvZGUtaGlkZGVuJyk7XG4gICAgICAgIHRoaXMuc3RhdHVzSW5kaWNhdG9yLnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS1mbGV4LXZpc2libGUnKTtcblxuICAgICAgICAvLyBJZiB0aGVyZSdzIGNvbnRlbnQgaW4gdGhlIHJlc3VsdCBhcmVhLCBrZWVwIGl0IGFuZCB0aGUgc2VjdGlvbiB2aXNpYmxlXG4gICAgICAgIGlmICh0aGlzLnJlc3VsdEFyZWEuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRBcmVhLnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0QXJlYS5hZGRDbGFzcygnY2xhdWRlLWNvZGUtdmlzaWJsZScpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0U2VjdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjbGF1ZGUtY29kZS1yZXN1bHQtc2VjdGlvbicpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdFNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXN1bHRTZWN0aW9uLnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgICAgICAgICByZXN1bHRTZWN0aW9uLmFkZENsYXNzKCdjbGF1ZGUtY29kZS12aXNpYmxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG93IHRoZSBsYXN0IHByb21wdCB0aGF0IHdhcyBzZW50XG4gICAgICovXG4gICAgcHJpdmF0ZSBzaG93TGFzdFByb21wdChwcm9tcHQ6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDdXJyZW50Q29udGV4dCgpO1xuICAgICAgICBjb250ZXh0Lmxhc3RQcm9tcHQgPSBwcm9tcHQ7XG5cbiAgICAgICAgdGhpcy5sYXN0UHJvbXB0QXJlYS5lbXB0eSgpO1xuICAgICAgICB0aGlzLmxhc3RQcm9tcHRBcmVhLnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcblxuICAgICAgICAvLyBDcmVhdGUgdGhlIHByb21wdCBkaXNwbGF5IHdpdGggYSBsYWJlbFxuICAgICAgICB0aGlzLmxhc3RQcm9tcHRBcmVhLmNyZWF0ZUVsKCdzcGFuJywge1xuICAgICAgICAgICAgY2xzOiAnY2xhdWRlLWNvZGUtbGFzdC1wcm9tcHQtbGFiZWwnLFxuICAgICAgICAgICAgdGV4dDogJ1x1RDgzRFx1RENBQyAnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRydW5jYXRlIGxvbmcgcHJvbXB0cyBmb3IgZGlzcGxheVxuICAgICAgICBjb25zdCBkaXNwbGF5UHJvbXB0ID0gcHJvbXB0Lmxlbmd0aCA+IDIwMFxuICAgICAgICAgICAgPyBwcm9tcHQuc3Vic3RyaW5nKDAsIDIwMCkgKyAnLi4uJ1xuICAgICAgICAgICAgOiBwcm9tcHQ7XG5cbiAgICAgICAgdGhpcy5sYXN0UHJvbXB0QXJlYS5jcmVhdGVFbCgnc3BhbicsIHtcbiAgICAgICAgICAgIGNsczogJ2NsYXVkZS1jb2RlLWxhc3QtcHJvbXB0LXRleHQnLFxuICAgICAgICAgICAgdGV4dDogZGlzcGxheVByb21wdFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTaG93IGZ1bGwgcHJvbXB0IG9uIGhvdmVyIGlmIHRydW5jYXRlZFxuICAgICAgICBpZiAocHJvbXB0Lmxlbmd0aCA+IDIwMCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0UHJvbXB0QXJlYS5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgcHJvbXB0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhpZGUgdGhlIGxhc3QgcHJvbXB0IGRpc3BsYXlcbiAgICAgKi9cbiAgICBwcml2YXRlIGhpZGVMYXN0UHJvbXB0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmxhc3RQcm9tcHRBcmVhLmFkZENsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgdGhpcy5sYXN0UHJvbXB0QXJlYS5lbXB0eSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3cgcHJldmlldyBvZiBjaGFuZ2VzXG4gICAgICogQHBhcmFtIG1vZGlmaWVkQ29udGVudCBUaGUgbW9kaWZpZWQgY29udGVudCB0byBwcmV2aWV3XG4gICAgICogQHBhcmFtIGZvck5vdGVQYXRoIE9wdGlvbmFsOiB0aGUgbm90ZSBwYXRoIHRoaXMgcHJldmlldyBiZWxvbmdzIHRvIChkZWZhdWx0cyB0byBjdXJyZW50IG5vdGUpXG4gICAgICovXG4gICAgcHJpdmF0ZSBzaG93UHJldmlldyhtb2RpZmllZENvbnRlbnQ6IHN0cmluZywgZm9yTm90ZVBhdGg/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgLy8gR2V0IHRoZSBjb250ZXh0IGZvciB0aGUgc3BlY2lmaWVkIG5vdGUgKG9yIGN1cnJlbnQgbm90ZSBpZiBub3Qgc3BlY2lmaWVkKVxuICAgICAgICBjb25zdCB0YXJnZXROb3RlUGF0aCA9IGZvck5vdGVQYXRoIHx8IHRoaXMuY3VycmVudE5vdGVQYXRoO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0TWFuYWdlci5nZXRDb250ZXh0KHRhcmdldE5vdGVQYXRoKTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxDb250ZW50ID0gY29udGV4dC5jdXJyZW50UmVxdWVzdD8uc2VsZWN0ZWRUZXh0IHx8IGNvbnRleHQuY3VycmVudFJlcXVlc3Q/Lm5vdGVDb250ZW50IHx8ICcnO1xuXG4gICAgICAgIC8vIFN0b3JlIHByZXZpZXcgc3RhdGUgaW4gdGhlIFRBUkdFVCBub3RlJ3MgY29udGV4dFxuICAgICAgICBjb250ZXh0LnBlbmRpbmdQcmV2aWV3Q29udGVudCA9IG1vZGlmaWVkQ29udGVudDtcbiAgICAgICAgY29udGV4dC5vcmlnaW5hbFByZXZpZXdDb250ZW50ID0gb3JpZ2luYWxDb250ZW50O1xuXG4gICAgICAgIC8vIE9ubHkgc2hvdyB0aGUgVUkgaWYgdGhpcyBpcyBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgbm90ZVxuICAgICAgICBpZiAodGFyZ2V0Tm90ZVBhdGggIT09IHRoaXMuY3VycmVudE5vdGVQYXRoKSB7XG4gICAgICAgICAgICAvLyBQcmV2aWV3IHN0b3JlZCBpbiBjb250ZXh0LCBidXQgZG9uJ3Qgc2hvdyBVSSBzaW5jZSB1c2VyIGlzIG9uIGEgZGlmZmVyZW50IG5vdGVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByZXZpZXdTZWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NsYXVkZS1jb2RlLXByZXZpZXctc2VjdGlvbicpO1xuICAgICAgICBpZiAocHJldmlld1NlY3Rpb24pIHtcbiAgICAgICAgICAgIHByZXZpZXdTZWN0aW9uLnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgICAgIHByZXZpZXdTZWN0aW9uLmFkZENsYXNzKCdjbGF1ZGUtY29kZS12aXNpYmxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByZXZpZXdBcmVhLmVtcHR5KCk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIG9sZCByZW5kZXJlZCBhbmQgZGlmZiB2aWV3cyBpZiB0aGV5IGV4aXN0XG4gICAgICAgIGNvbnN0IG9sZFJlbmRlcmVkID0gdGhpcy5wcmV2aWV3Q29udGVudENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuY2xhdWRlLWNvZGUtcHJldmlldy1yZW5kZXJlZCcpO1xuICAgICAgICBpZiAob2xkUmVuZGVyZWQpIG9sZFJlbmRlcmVkLnJlbW92ZSgpO1xuICAgICAgICBjb25zdCBvbGREaWZmID0gdGhpcy5wcmV2aWV3Q29udGVudENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuY2xhdWRlLWNvZGUtcHJldmlldy1kaWZmJyk7XG4gICAgICAgIGlmIChvbGREaWZmKSBvbGREaWZmLnJlbW92ZSgpO1xuXG4gICAgICAgIC8vIFNob3cgY2hhcmFjdGVyIGNvdW50IGNvbXBhcmlzb25cbiAgICAgICAgY29uc3Qgc3RhdHNEaXYgPSB0aGlzLnByZXZpZXdBcmVhLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ2NsYXVkZS1jb2RlLXByZXZpZXctc3RhdHMnIH0pO1xuICAgICAgICBzdGF0c0Rpdi5jcmVhdGVFbCgnc3BhbicsIHsgdGV4dDogYCR7dCgncHJldmlldy5vcmlnaW5hbExhYmVsJyl9ICR7b3JpZ2luYWxDb250ZW50Lmxlbmd0aH0gJHt0KCdwcmV2aWV3LmNoYXJzTGFiZWwnKX1gIH0pO1xuICAgICAgICBzdGF0c0Rpdi5jcmVhdGVFbCgnc3BhbicsIHsgdGV4dDogYCBcdTIxOTIgJHt0KCdwcmV2aWV3Lm1vZGlmaWVkTGFiZWwnKX0gJHttb2RpZmllZENvbnRlbnQubGVuZ3RofSAke3QoJ3ByZXZpZXcuY2hhcnNMYWJlbCcpfWAgfSk7XG4gICAgICAgIHN0YXRzRGl2LmNyZWF0ZUVsKCdzcGFuJywgeyB0ZXh0OiBgICgke21vZGlmaWVkQ29udGVudC5sZW5ndGggLSBvcmlnaW5hbENvbnRlbnQubGVuZ3RoID49IDAgPyAnKycgOiAnJ30ke21vZGlmaWVkQ29udGVudC5sZW5ndGggLSBvcmlnaW5hbENvbnRlbnQubGVuZ3RofSlgIH0pO1xuXG4gICAgICAgIC8vIFNob3cgdGhlIG1vZGlmaWVkIGNvbnRlbnQgaW4gYSBjb2RlIGJsb2NrIChSYXcgdGFiKVxuICAgICAgICBjb25zdCBwcmV2aWV3Q29udGVudCA9IHRoaXMucHJldmlld0FyZWEuY3JlYXRlRWwoJ3ByZScsIHsgY2xzOiAnY2xhdWRlLWNvZGUtcHJldmlldy1jb250ZW50JyB9KTtcbiAgICAgICAgcHJldmlld0NvbnRlbnQuY3JlYXRlRWwoJ2NvZGUnLCB7IHRleHQ6IG1vZGlmaWVkQ29udGVudCB9KTtcbiAgICAgICAgdGhpcy5wcmV2aWV3QXJlYS5hZGRDbGFzcygnY2xhdWRlLWNvZGUtaGlkZGVuJyk7IC8vIEhpZGRlbiBieSBkZWZhdWx0LCBEaWZmIHRhYiBpcyBhY3RpdmVcblxuICAgICAgICAvLyBDcmVhdGUgZGlmZiB2aWV3IChzaG93biBieSBkZWZhdWx0KVxuICAgICAgICBjb25zdCBkaWZmQXJlYSA9IHRoaXMucHJldmlld0NvbnRlbnRDb250YWluZXIuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgICAgICAgIGNsczogJ2NsYXVkZS1jb2RlLXByZXZpZXctZGlmZiBjbGF1ZGUtY29kZS12aXNpYmxlJ1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBVc2Ugc2FmZSBET00gbWFuaXB1bGF0aW9uXG4gICAgICAgIGNvbnN0IGRpZmZFbGVtZW50ID0gdGhpcy5nZW5lcmF0ZURpZmZFbGVtZW50KG9yaWdpbmFsQ29udGVudCwgbW9kaWZpZWRDb250ZW50KTtcbiAgICAgICAgZGlmZkFyZWEuYXBwZW5kQ2hpbGQoZGlmZkVsZW1lbnQpO1xuXG4gICAgICAgIC8vIENyZWF0ZSByZW5kZXJlZCBtYXJrZG93biB2aWV3XG4gICAgICAgIGNvbnN0IHJlbmRlcmVkQXJlYSA9IHRoaXMucHJldmlld0NvbnRlbnRDb250YWluZXIuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgICAgICAgIGNsczogJ2NsYXVkZS1jb2RlLXByZXZpZXctcmVuZGVyZWQgY2xhdWRlLWNvZGUtaGlkZGVuJ1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZW5kZXIgdGhlIG1hcmtkb3duXG4gICAgICAgIHZvaWQgTWFya2Rvd25SZW5kZXJlci5yZW5kZXIoXG4gICAgICAgICAgICB0aGlzLmFwcCxcbiAgICAgICAgICAgIG1vZGlmaWVkQ29udGVudCxcbiAgICAgICAgICAgIHJlbmRlcmVkQXJlYSxcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE5vdGVQYXRoLFxuICAgICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhpZGUgcHJldmlldyBhbmQgY2xlYXIgY29udGV4dCBzdGF0ZVxuICAgICAqL1xuICAgIHByaXZhdGUgaGlkZVByZXZpZXcoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaGlkZVByZXZpZXdVSSgpO1xuXG4gICAgICAgIC8vIENsZWFyIHByZXZpZXcgc3RhdGUgZnJvbSBjb250ZXh0XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldEN1cnJlbnRDb250ZXh0KCk7XG4gICAgICAgIGNvbnRleHQucGVuZGluZ1ByZXZpZXdDb250ZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250ZXh0Lm9yaWdpbmFsUHJldmlld0NvbnRlbnQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGlkZSBwcmV2aWV3IFVJIG9ubHkgKHdpdGhvdXQgY2xlYXJpbmcgY29udGV4dCBzdGF0ZSlcbiAgICAgKiBVc2VkIHdoZW4gc3dpdGNoaW5nIG5vdGVzIHRvIHByZXNlcnZlIGVhY2ggbm90ZSdzIHByZXZpZXcgc3RhdGVcbiAgICAgKi9cbiAgICBwcml2YXRlIGhpZGVQcmV2aWV3VUkoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHByZXZpZXdTZWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NsYXVkZS1jb2RlLXByZXZpZXctc2VjdGlvbicpO1xuICAgICAgICBpZiAocHJldmlld1NlY3Rpb24pIHtcbiAgICAgICAgICAgIHByZXZpZXdTZWN0aW9uLmFkZENsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgICAgIHByZXZpZXdTZWN0aW9uLnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS12aXNpYmxlJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlIHByZXZpZXcgZnJvbSBzdG9yZWQgY29udGV4dCBzdGF0ZSAodXNlZCB3aGVuIHN3aXRjaGluZyBub3RlcylcbiAgICAgKi9cbiAgICBwcml2YXRlIHJlc3RvcmVQcmV2aWV3KG1vZGlmaWVkQ29udGVudDogc3RyaW5nLCBvcmlnaW5hbENvbnRlbnQ6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBjb25zdCBwcmV2aWV3U2VjdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjbGF1ZGUtY29kZS1wcmV2aWV3LXNlY3Rpb24nKTtcbiAgICAgICAgaWYgKHByZXZpZXdTZWN0aW9uKSB7XG4gICAgICAgICAgICBwcmV2aWV3U2VjdGlvbi5yZW1vdmVDbGFzcygnY2xhdWRlLWNvZGUtaGlkZGVuJyk7XG4gICAgICAgICAgICBwcmV2aWV3U2VjdGlvbi5hZGRDbGFzcygnY2xhdWRlLWNvZGUtdmlzaWJsZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcmV2aWV3QXJlYS5lbXB0eSgpO1xuXG4gICAgICAgIC8vIFJlbW92ZSBvbGQgcmVuZGVyZWQgYW5kIGRpZmYgdmlld3MgaWYgdGhleSBleGlzdFxuICAgICAgICBjb25zdCBvbGRSZW5kZXJlZCA9IHRoaXMucHJldmlld0NvbnRlbnRDb250YWluZXIucXVlcnlTZWxlY3RvcignLmNsYXVkZS1jb2RlLXByZXZpZXctcmVuZGVyZWQnKTtcbiAgICAgICAgaWYgKG9sZFJlbmRlcmVkKSBvbGRSZW5kZXJlZC5yZW1vdmUoKTtcbiAgICAgICAgY29uc3Qgb2xkRGlmZiA9IHRoaXMucHJldmlld0NvbnRlbnRDb250YWluZXIucXVlcnlTZWxlY3RvcignLmNsYXVkZS1jb2RlLXByZXZpZXctZGlmZicpO1xuICAgICAgICBpZiAob2xkRGlmZikgb2xkRGlmZi5yZW1vdmUoKTtcblxuICAgICAgICAvLyBTaG93IGNoYXJhY3RlciBjb3VudCBjb21wYXJpc29uXG4gICAgICAgIGNvbnN0IHN0YXRzRGl2ID0gdGhpcy5wcmV2aWV3QXJlYS5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdjbGF1ZGUtY29kZS1wcmV2aWV3LXN0YXRzJyB9KTtcbiAgICAgICAgc3RhdHNEaXYuY3JlYXRlRWwoJ3NwYW4nLCB7IHRleHQ6IGAke3QoJ3ByZXZpZXcub3JpZ2luYWxMYWJlbCcpfSAke29yaWdpbmFsQ29udGVudC5sZW5ndGh9ICR7dCgncHJldmlldy5jaGFyc0xhYmVsJyl9YCB9KTtcbiAgICAgICAgc3RhdHNEaXYuY3JlYXRlRWwoJ3NwYW4nLCB7IHRleHQ6IGAgXHUyMTkyICR7dCgncHJldmlldy5tb2RpZmllZExhYmVsJyl9ICR7bW9kaWZpZWRDb250ZW50Lmxlbmd0aH0gJHt0KCdwcmV2aWV3LmNoYXJzTGFiZWwnKX1gIH0pO1xuICAgICAgICBzdGF0c0Rpdi5jcmVhdGVFbCgnc3BhbicsIHsgdGV4dDogYCAoJHttb2RpZmllZENvbnRlbnQubGVuZ3RoIC0gb3JpZ2luYWxDb250ZW50Lmxlbmd0aCA+PSAwID8gJysnIDogJyd9JHttb2RpZmllZENvbnRlbnQubGVuZ3RoIC0gb3JpZ2luYWxDb250ZW50Lmxlbmd0aH0pYCB9KTtcblxuICAgICAgICAvLyBTaG93IHRoZSBtb2RpZmllZCBjb250ZW50IGluIGEgY29kZSBibG9jayAoUmF3IHRhYilcbiAgICAgICAgY29uc3QgcHJldmlld0NvbnRlbnQgPSB0aGlzLnByZXZpZXdBcmVhLmNyZWF0ZUVsKCdwcmUnLCB7IGNsczogJ2NsYXVkZS1jb2RlLXByZXZpZXctY29udGVudCcgfSk7XG4gICAgICAgIHByZXZpZXdDb250ZW50LmNyZWF0ZUVsKCdjb2RlJywgeyB0ZXh0OiBtb2RpZmllZENvbnRlbnQgfSk7XG4gICAgICAgIHRoaXMucHJldmlld0FyZWEuYWRkQ2xhc3MoJ2NsYXVkZS1jb2RlLWhpZGRlbicpOyAvLyBIaWRkZW4gYnkgZGVmYXVsdCwgRGlmZiB0YWIgaXMgYWN0aXZlXG5cbiAgICAgICAgLy8gQ3JlYXRlIGRpZmYgdmlldyAoc2hvd24gYnkgZGVmYXVsdClcbiAgICAgICAgY29uc3QgZGlmZkFyZWEgPSB0aGlzLnByZXZpZXdDb250ZW50Q29udGFpbmVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICAgICAgICBjbHM6ICdjbGF1ZGUtY29kZS1wcmV2aWV3LWRpZmYgY2xhdWRlLWNvZGUtdmlzaWJsZSdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVXNlIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuICAgICAgICBjb25zdCBkaWZmRWxlbWVudCA9IHRoaXMuZ2VuZXJhdGVEaWZmRWxlbWVudChvcmlnaW5hbENvbnRlbnQsIG1vZGlmaWVkQ29udGVudCk7XG4gICAgICAgIGRpZmZBcmVhLmFwcGVuZENoaWxkKGRpZmZFbGVtZW50KTtcblxuICAgICAgICAvLyBDcmVhdGUgcmVuZGVyZWQgbWFya2Rvd24gdmlld1xuICAgICAgICBjb25zdCByZW5kZXJlZEFyZWEgPSB0aGlzLnByZXZpZXdDb250ZW50Q29udGFpbmVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICAgICAgICBjbHM6ICdjbGF1ZGUtY29kZS1wcmV2aWV3LXJlbmRlcmVkIGNsYXVkZS1jb2RlLWhpZGRlbidcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVuZGVyIHRoZSBtYXJrZG93blxuICAgICAgICB2b2lkIE1hcmtkb3duUmVuZGVyZXIucmVuZGVyKFxuICAgICAgICAgICAgdGhpcy5hcHAsXG4gICAgICAgICAgICBtb2RpZmllZENvbnRlbnQsXG4gICAgICAgICAgICByZW5kZXJlZEFyZWEsXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnROb3RlUGF0aCxcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlIHN0cmVhbWluZyByZXN1bHQgZnJvbSBjb250ZXh0ICh1c2VkIHdoZW4gc3dpdGNoaW5nIGJhY2sgdG8gYSBydW5uaW5nIG5vdGUpXG4gICAgICovXG4gICAgcHJpdmF0ZSByZXN0b3JlU3RyZWFtaW5nUmVzdWx0KHRleHQ6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICAvLyBTaG93IHRoZSByZXN1bHQgc2VjdGlvblxuICAgICAgICBjb25zdCByZXN1bHRTZWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NsYXVkZS1jb2RlLXJlc3VsdC1zZWN0aW9uJyk7XG4gICAgICAgIGlmIChyZXN1bHRTZWN0aW9uKSB7XG4gICAgICAgICAgICByZXN1bHRTZWN0aW9uLnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgICAgIHJlc3VsdFNlY3Rpb24uYWRkQ2xhc3MoJ2NsYXVkZS1jb2RlLXZpc2libGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNob3cgcmVzdWx0IGFyZWFcbiAgICAgICAgdGhpcy5yZXN1bHRBcmVhLnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgdGhpcy5yZXN1bHRBcmVhLmFkZENsYXNzKCdjbGF1ZGUtY29kZS12aXNpYmxlJyk7XG5cbiAgICAgICAgLy8gQ2xlYXIgYW5kIHJlY3JlYXRlIHN0cmVhbWluZyBlbGVtZW50XG4gICAgICAgIHRoaXMucmVzdWx0QXJlYS5lbXB0eSgpO1xuICAgICAgICB0aGlzLmN1cnJlbnRSZXN1bHRTdHJlYW1pbmdFbGVtZW50ID0gdGhpcy5yZXN1bHRBcmVhLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICAgICAgICBjbHM6ICdjbGF1ZGUtY29kZS1yZXN1bHQtc3RyZWFtaW5nIG1hcmtkb3duLXJlbmRlcmVkJ1xuICAgICAgICB9KTtcbiAgICAgICAgKHRoaXMuY3VycmVudFJlc3VsdFN0cmVhbWluZ0VsZW1lbnQgYXMgdW5rbm93biBhcyBTdHJlYW1pbmdFbGVtZW50RGF0YSkuYWNjdW11bGF0ZWRUZXh0ID0gdGV4dDtcblxuICAgICAgICAvLyBSZXNldCByZW5kZXJpbmcgc3RhdGUgYW5kIHJlbmRlciB0aGUgYWNjdW11bGF0ZWQgdGV4dFxuICAgICAgICB0aGlzLmxhc3RSZW5kZXJlZFRleHQgPSAnJztcbiAgICAgICAgdGhpcy5oaXRGaW5hbENvbnRlbnRNYXJrZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW5kZXJTdHJlYW1pbmdNYXJrZG93bih0ZXh0KTtcblxuICAgICAgICBjb25zb2xlLmRlYnVnKCdbUmVzdG9yZSBTdHJlYW1pbmcgUmVzdWx0XSBSZXN0b3JlZCB0ZXh0IGxlbmd0aDonLCB0ZXh0Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwZW5kIHRleHQgdG8gcmVzdWx0IHBhbmVsIFVJIG9ubHkgKGNvbnRleHQgdXBkYXRlIGhhbmRsZWQgYnkgYXBwZW5kT3V0cHV0VG9Ob3RlKVxuICAgICAqIFVzZWQgZm9yIHN0cmVhbWluZyBhc3Npc3RhbnQgbWVzc2FnZXMgd2hlbiB0aGUgY3VycmVudCBub3RlIGlzIGFjdGl2ZVxuICAgICAqL1xuICAgIHByaXZhdGUgYXBwZW5kVG9SZXN1bHRVSSh0ZXh0OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnW0FwcGVuZCBUbyBSZXN1bHQgVUldIENhbGxlZCB3aXRoIHRleHQ6JywgdGV4dC5zdWJzdHJpbmcoMCwgNTApKTtcblxuICAgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGhpdCB0aGUgRklOQUwtQ09OVEVOVCBtYXJrZXIsIGlnbm9yZSBhbGwgc3Vic2VxdWVudCBjaHVua3NcbiAgICAgICAgaWYgKHRoaXMuaGl0RmluYWxDb250ZW50TWFya2VyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdbQXBwZW5kIFRvIFJlc3VsdCBVSV0gQWxyZWFkeSBoaXQgRklOQUwtQ09OVEVOVCBtYXJrZXIgZmxhZywgaWdub3JpbmcgY2h1bmsnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNob3cgdGhlIHJlc3VsdCBzZWN0aW9uIGlmIG5vdCBhbHJlYWR5IHZpc2libGVcbiAgICAgICAgY29uc3QgcmVzdWx0U2VjdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjbGF1ZGUtY29kZS1yZXN1bHQtc2VjdGlvbicpO1xuICAgICAgICBpZiAocmVzdWx0U2VjdGlvbikge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnW0FwcGVuZCBUbyBSZXN1bHQgVUldIFNob3dpbmcgcmVzdWx0IHNlY3Rpb24nKTtcbiAgICAgICAgICAgIHJlc3VsdFNlY3Rpb24ucmVtb3ZlQ2xhc3MoJ2NsYXVkZS1jb2RlLWhpZGRlbicpO1xuICAgICAgICAgICAgcmVzdWx0U2VjdGlvbi5hZGRDbGFzcygnY2xhdWRlLWNvZGUtdmlzaWJsZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hvdyByZXN1bHQgYXJlYSAoYnV0IGtlZXAgc3RhdHVzIHZpc2libGUgLSBwcm9jZXNzIG1heSBzdGlsbCBiZSBydW5uaW5nISlcbiAgICAgICAgLy8gVGhlIHN0YXR1cyB3aWxsIGJlIGhpZGRlbiB3aGVuIHRoZSBwcm9jZXNzIGNvbXBsZXRlcyB2aWEgaGlkZVN0YXR1cygpXG4gICAgICAgIHRoaXMucmVzdWx0QXJlYS5yZW1vdmVDbGFzcygnY2xhdWRlLWNvZGUtaGlkZGVuJyk7XG4gICAgICAgIHRoaXMucmVzdWx0QXJlYS5hZGRDbGFzcygnY2xhdWRlLWNvZGUtdmlzaWJsZScpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBzdHJlYW1pbmcgZWxlbWVudCBpZiBuZWVkZWQgKHdpdGggbWFya2Rvd24tcmVuZGVyZWQgY2xhc3MpXG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50UmVzdWx0U3RyZWFtaW5nRWxlbWVudCkge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnW0FwcGVuZCBUbyBSZXN1bHQgVUldIENyZWF0aW5nIHN0cmVhbWluZyBlbGVtZW50Jyk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXN1bHRTdHJlYW1pbmdFbGVtZW50ID0gdGhpcy5yZXN1bHRBcmVhLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgY2xzOiAnY2xhdWRlLWNvZGUtcmVzdWx0LXN0cmVhbWluZyBtYXJrZG93bi1yZW5kZXJlZCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gU3RvcmUgYWNjdW11bGF0ZWQgdGV4dCBzZXBhcmF0ZWx5IGZvciBtYXJrZG93biByZW5kZXJpbmdcbiAgICAgICAgICAgICh0aGlzLmN1cnJlbnRSZXN1bHRTdHJlYW1pbmdFbGVtZW50IGFzIHVua25vd24gYXMgU3RyZWFtaW5nRWxlbWVudERhdGEpLmFjY3VtdWxhdGVkVGV4dCA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IGFjY3VtdWxhdGVkIHRleHRcbiAgICAgICAgY29uc3QgYWNjdW11bGF0ZWRUZXh0ID0gKHRoaXMuY3VycmVudFJlc3VsdFN0cmVhbWluZ0VsZW1lbnQgYXMgdW5rbm93biBhcyBTdHJlYW1pbmdFbGVtZW50RGF0YSkuYWNjdW11bGF0ZWRUZXh0IHx8ICcnO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHdlJ3ZlIGFscmVhZHkgZW5jb3VudGVyZWQgRklOQUwtQ09OVEVOVCBtYXJrZXIgaW4gdGhlIGV4aXN0aW5nIHRleHRcbiAgICAgICAgaWYgKGFjY3VtdWxhdGVkVGV4dC5pbmNsdWRlcygnLS0tRklOQUwtQ09OVEVOVC0tLScpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdbQXBwZW5kIFRvIFJlc3VsdCBVSV0gRm91bmQgRklOQUwtQ09OVEVOVCBpbiBleGlzdGluZyB0ZXh0LCBjbGVhbmluZyB1cCBhbmQgc2V0dGluZyBmbGFnJyk7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXBGaW5hbENvbnRlbnRGcm9tU3RyZWFtKCk7XG4gICAgICAgICAgICB0aGlzLmhpdEZpbmFsQ29udGVudE1hcmtlciA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGNodW5rIHdvdWxkIGludHJvZHVjZSB0aGUgRklOQUwtQ09OVEVOVCBtYXJrZXJcbiAgICAgICAgY29uc3QgY29tYmluZWRUZXh0ID0gYWNjdW11bGF0ZWRUZXh0ICsgdGV4dDtcbiAgICAgICAgaWYgKGNvbWJpbmVkVGV4dC5pbmNsdWRlcygnLS0tRklOQUwtQ09OVEVOVC0tLScpKSB7XG4gICAgICAgICAgICAvLyBGaW5kIGhvdyBtdWNoIG9mIHRoaXMgY2h1bmsgd2UgY2FuIGFkZCBiZWZvcmUgdGhlIG1hcmtlclxuICAgICAgICAgICAgY29uc3QgZmluYWxDb250ZW50SW5kZXggPSBjb21iaW5lZFRleHQuaW5kZXhPZignLS0tRklOQUwtQ09OVEVOVC0tLScpO1xuICAgICAgICAgICAgY29uc3QgdGV4dEJlZm9yZU1hcmtlciA9IGNvbWJpbmVkVGV4dC5zdWJzdHJpbmcoMCwgZmluYWxDb250ZW50SW5kZXgpO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgYWNjdW11bGF0ZWQgdGV4dCBhbmQgcmVuZGVyXG4gICAgICAgICAgICAodGhpcy5jdXJyZW50UmVzdWx0U3RyZWFtaW5nRWxlbWVudCBhcyB1bmtub3duIGFzIFN0cmVhbWluZ0VsZW1lbnREYXRhKS5hY2N1bXVsYXRlZFRleHQgPSB0ZXh0QmVmb3JlTWFya2VyO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJTdHJlYW1pbmdNYXJrZG93bih0ZXh0QmVmb3JlTWFya2VyKTtcblxuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnW0FwcGVuZCBUbyBSZXN1bHQgVUldIEhpdCBGSU5BTC1DT05URU5UIG1hcmtlciwgc2V0dGluZyBmbGFnJyk7XG4gICAgICAgICAgICB0aGlzLmhpdEZpbmFsQ29udGVudE1hcmtlciA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3JtYWwgY2FzZTogYWRkIHRoZSBmdWxsIGNodW5rIGFuZCByZS1yZW5kZXIgbWFya2Rvd25cbiAgICAgICAgKHRoaXMuY3VycmVudFJlc3VsdFN0cmVhbWluZ0VsZW1lbnQgYXMgdW5rbm93biBhcyBTdHJlYW1pbmdFbGVtZW50RGF0YSkuYWNjdW11bGF0ZWRUZXh0ID0gY29tYmluZWRUZXh0O1xuICAgICAgICB0aGlzLnJlbmRlclN0cmVhbWluZ01hcmtkb3duKGNvbWJpbmVkVGV4dCk7XG5cbiAgICAgICAgY29uc29sZS5kZWJ1ZygnW0FwcGVuZCBUbyBSZXN1bHQgVUldIEFwcGVuZGVkIGNodW5rLCBhY2N1bXVsYXRlZCBsZW5ndGg6JywgY29tYmluZWRUZXh0Lmxlbmd0aCk7XG5cbiAgICAgICAgLy8gU21hcnQgYXV0by1zY3JvbGwgKHJlc3BlY3RzIHVzZXIgc2Nyb2xsIHBvc2l0aW9uKVxuICAgICAgICB0aGlzLmF1dG9TY3JvbGxSZXN1bHQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYWNjdW11bGF0ZWQgbWFya2Rvd24gdGV4dCBieSBkZXRlY3RpbmcgYW5kIHJlbmRlcmluZyBjb21wbGV0ZSBibG9ja3NcbiAgICAgKiBBcHBlbmRzIGNvbXBsZXRlIHBhcmFncmFwaHMvYmxvY2tzIGFzIGluZGVwZW5kZW50IGNodW5rc1xuICAgICAqL1xuICAgIHByaXZhdGUgcmVuZGVyU3RyZWFtaW5nTWFya2Rvd24odGV4dDogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50UmVzdWx0U3RyZWFtaW5nRWxlbWVudCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIEdldCB0aGUgbmV3IGNvbnRlbnRcbiAgICAgICAgY29uc3QgbmV3Q29udGVudCA9IHRleHQuc3Vic3RyaW5nKHRoaXMubGFzdFJlbmRlcmVkVGV4dC5sZW5ndGgpO1xuICAgICAgICBpZiAoIW5ld0NvbnRlbnQpIHJldHVybjtcblxuICAgICAgICAvLyBFeHRyYWN0IHdoYXQgd2UgY2FuIHJlbmRlciBub3dcbiAgICAgICAgY29uc3QgeyBjb21wbGV0ZUJsb2NrcywgcmVtYWluaW5nVGV4dCB9ID0gdGhpcy5leHRyYWN0Q29tcGxldGVCbG9ja3MobmV3Q29udGVudCk7XG5cbiAgICAgICAgaWYgKGNvbXBsZXRlQmxvY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgaW5jb21wbGV0ZSBwbGFpbiB0ZXh0IGZyb20gbGFzdCByZW5kZXJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlSW5jb21wbGV0ZVBsYWluVGV4dCgpO1xuXG4gICAgICAgICAgICAvLyBSZW5kZXIgZWFjaCBjb21wbGV0ZSBibG9jayBhcyBhIHNlcGFyYXRlIGNodW5rXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJsb2NrIG9mIGNvbXBsZXRlQmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRNYXJrZG93bkJsb2NrKGJsb2NrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBkYXRlIHdoYXQgd2UndmUgcmVuZGVyZWRcbiAgICAgICAgICAgIHRoaXMubGFzdFJlbmRlcmVkVGV4dCA9IHRoaXMubGFzdFJlbmRlcmVkVGV4dCArIG5ld0NvbnRlbnQuc3Vic3RyaW5nKDAsIG5ld0NvbnRlbnQubGVuZ3RoIC0gcmVtYWluaW5nVGV4dC5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwZW5kIGFueSByZW1haW5pbmcgaW5jb21wbGV0ZSB0ZXh0IGFzIHBsYWluIHRleHRcbiAgICAgICAgaWYgKHJlbWFpbmluZ1RleHQpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kUGxhaW5UZXh0KHJlbWFpbmluZ1RleHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdCBjb21wbGV0ZSBtYXJrZG93biBibG9ja3MgZnJvbSB0aGUgbmV3IGNvbnRlbnRcbiAgICAgKiBSZXR1cm5zIGJsb2NrcyB0aGF0IGFyZSByZWFkeSB0byBiZSByZW5kZXJlZCBhbmQgcmVtYWluaW5nIGluY29tcGxldGUgdGV4dFxuICAgICAqL1xuICAgIHByaXZhdGUgZXh0cmFjdENvbXBsZXRlQmxvY2tzKG5ld0NvbnRlbnQ6IHN0cmluZyk6IHsgY29tcGxldGVCbG9ja3M6IHN0cmluZ1tdLCByZW1haW5pbmdUZXh0OiBzdHJpbmcgfSB7XG4gICAgICAgIGNvbnN0IGJsb2Nrczogc3RyaW5nW10gPSBbXTtcblxuICAgICAgICAvLyBTcGxpdCBieSBwYXJhZ3JhcGggYnJlYWtzIChkb3VibGUgbmV3bGluZSlcbiAgICAgICAgY29uc3QgcGFyYWdyYXBocyA9IG5ld0NvbnRlbnQuc3BsaXQoL1xcblxcbisvKTtcblxuICAgICAgICAvLyBJZiB3ZSBoYXZlIG1vcmUgdGhhbiBvbmUgcGFyYWdyYXBoLCBhbGwgYnV0IHRoZSBsYXN0IGFyZSBjb21wbGV0ZVxuICAgICAgICBpZiAocGFyYWdyYXBocy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFncmFwaHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFncmFwaHNbaV0udHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrcy5wdXNoKHBhcmFncmFwaHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29tcGxldGVCbG9ja3M6IGJsb2NrcyxcbiAgICAgICAgICAgICAgICByZW1haW5pbmdUZXh0OiBwYXJhZ3JhcGhzW3BhcmFncmFwaHMubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBObyBjb21wbGV0ZSBibG9ja3MgeWV0LCBldmVyeXRoaW5nIGlzIHJlbWFpbmluZ1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29tcGxldGVCbG9ja3M6IFtdLFxuICAgICAgICAgICAgcmVtYWluaW5nVGV4dDogbmV3Q29udGVudFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBpbmNvbXBsZXRlIHBsYWluIHRleHQgZnJvbSB0aGUgbGFzdCByZW5kZXJcbiAgICAgKiAod2lsbCBiZSByZS1hZGRlZCBhcyBwYXJ0IG9mIGNvbXBsZXRlIGJsb2NrIG9yIG5ldyBwbGFpbiB0ZXh0KVxuICAgICAqL1xuICAgIHByaXZhdGUgcmVtb3ZlSW5jb21wbGV0ZVBsYWluVGV4dCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRSZXN1bHRTdHJlYW1pbmdFbGVtZW50KSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgbGFzdENoaWxkID0gdGhpcy5jdXJyZW50UmVzdWx0U3RyZWFtaW5nRWxlbWVudC5sYXN0Q2hpbGQ7XG4gICAgICAgIC8vIE9ubHkgcmVtb3ZlIGlmIGl0J3MgYSBwbGFpbiB0ZXh0IG5vZGUgKG5vdCBhIG1hcmtkb3duLWJsb2NrKVxuICAgICAgICBpZiAobGFzdENoaWxkICYmIGxhc3RDaGlsZC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlc3VsdFN0cmVhbWluZ0VsZW1lbnQucmVtb3ZlQ2hpbGQobGFzdENoaWxkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGVuZCBhIGNvbXBsZXRlIG1hcmtkb3duIGJsb2NrIGFzIGFuIGluZGVwZW5kZW50IHJlbmRlcmVkIGNodW5rXG4gICAgICovXG4gICAgcHJpdmF0ZSBhcHBlbmRNYXJrZG93bkJsb2NrKGJsb2NrVGV4dDogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50UmVzdWx0U3RyZWFtaW5nRWxlbWVudCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIGNvbnRhaW5lciBmb3IgdGhpcyBibG9ja1xuICAgICAgICBjb25zdCBibG9ja0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBibG9ja0NvbnRhaW5lci5hZGRDbGFzcygnbWFya2Rvd24tYmxvY2snKTtcblxuICAgICAgICB2b2lkIE1hcmtkb3duUmVuZGVyZXIucmVuZGVyKFxuICAgICAgICAgICAgdGhpcy5hcHAsXG4gICAgICAgICAgICBibG9ja1RleHQsXG4gICAgICAgICAgICBibG9ja0NvbnRhaW5lcixcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE5vdGVQYXRoLFxuICAgICAgICAgICAgdGhpc1xuICAgICAgICApLmNhdGNoKChlOiB1bmtub3duKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbQXBwZW5kIE1hcmtkb3duIEJsb2NrXSBFcnJvcjonLCBlKTtcbiAgICAgICAgICAgIGJsb2NrQ29udGFpbmVyLnRleHRDb250ZW50ID0gYmxvY2tUZXh0O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBcHBlbmQgdGhlIGJsb2NrXG4gICAgICAgIHRoaXMuY3VycmVudFJlc3VsdFN0cmVhbWluZ0VsZW1lbnQuYXBwZW5kQ2hpbGQoYmxvY2tDb250YWluZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGVuZCBwbGFpbiB0ZXh0IHdpdGhvdXQgYW55IHByb2Nlc3NpbmdcbiAgICAgKi9cbiAgICBwcml2YXRlIGFwcGVuZFBsYWluVGV4dCh0ZXh0OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRSZXN1bHRTdHJlYW1pbmdFbGVtZW50KSByZXR1cm47XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgYWxyZWFkeSBoYXZlIGEgcGxhaW4gdGV4dCBjb250YWluZXJcbiAgICAgICAgY29uc3QgbGFzdENoaWxkID0gdGhpcy5jdXJyZW50UmVzdWx0U3RyZWFtaW5nRWxlbWVudC5sYXN0Q2hpbGQ7XG4gICAgICAgIGlmIChsYXN0Q2hpbGQgJiYgbGFzdENoaWxkLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgLy8gUkVQTEFDRSBleGlzdGluZyB0ZXh0IG5vZGUgKHJlbWFpbmluZ1RleHQgYWxyZWFkeSBjb250YWlucyB0aGUgZnVsbCB0ZXh0KVxuICAgICAgICAgICAgbGFzdENoaWxkLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgdGV4dCBub2RlXG4gICAgICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVzdWx0U3RyZWFtaW5nRWxlbWVudC5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIENsZWFuIHVwIEZJTkFMLUNPTlRFTlQgbWFya2VyIGFuZCBldmVyeXRoaW5nIGFmdGVyIGl0IGZyb20gdGhlIHN0cmVhbWluZyBlbGVtZW50XG4gICAgICovXG4gICAgcHJpdmF0ZSBjbGVhbnVwRmluYWxDb250ZW50RnJvbVN0cmVhbSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRSZXN1bHRTdHJlYW1pbmdFbGVtZW50KSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgZnVsbFRleHQgPSB0aGlzLmN1cnJlbnRSZXN1bHRTdHJlYW1pbmdFbGVtZW50LnRleHRDb250ZW50IHx8ICcnO1xuICAgICAgICBjb25zdCBmaW5hbENvbnRlbnRJbmRleCA9IGZ1bGxUZXh0LmluZGV4T2YoJy0tLUZJTkFMLUNPTlRFTlQtLS0nKTtcblxuICAgICAgICBpZiAoZmluYWxDb250ZW50SW5kZXggPT09IC0xKSByZXR1cm47IC8vIE5vIG1hcmtlciBmb3VuZFxuXG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ1tDbGVhbnVwIEZJTkFMLUNPTlRFTlRdIFJlbW92aW5nIG1hcmtlciBhbmQgY29udGVudCBhZnRlciBpdCcpO1xuXG4gICAgICAgIC8vIEdldCB0aGUgdGV4dCB3ZSB3YW50IHRvIGtlZXAgKGJlZm9yZSB0aGUgbWFya2VyKVxuICAgICAgICBjb25zdCB0ZXh0VG9LZWVwID0gZnVsbFRleHQuc3Vic3RyaW5nKDAsIGZpbmFsQ29udGVudEluZGV4KS50cmltKCk7XG5cbiAgICAgICAgLy8gQ2xlYXIgYWxsIGN1cnJlbnQgY29udGVudFxuICAgICAgICB0aGlzLmN1cnJlbnRSZXN1bHRTdHJlYW1pbmdFbGVtZW50LmVtcHR5KCk7XG5cbiAgICAgICAgLy8gUmUtYWRkIG9ubHkgdGhlIHRleHQgYmVmb3JlIHRoZSBtYXJrZXIgYXMgYSBzaW5nbGUgY2h1bmtcbiAgICAgICAgdGhpcy5jdXJyZW50UmVzdWx0U3RyZWFtaW5nRWxlbWVudC5jcmVhdGVFbCgnc3BhbicsIHtcbiAgICAgICAgICAgIGNsczogJ3N0cmVhbWluZy10ZXh0LWNodW5rJyxcbiAgICAgICAgICAgIHRleHQ6IHRleHRUb0tlZXBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc29sZS5kZWJ1ZygnW0NsZWFudXAgRklOQUwtQ09OVEVOVF0gQ2xlYW5lZCB1cCwga2VwdCB0ZXh0IGxlbmd0aDonLCB0ZXh0VG9LZWVwLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvdyBtYXJrZG93biBjb250ZW50IGluIHJlc3VsdCBzZWN0aW9uIChmb3Igbm9uLXN0cmVhbWluZyBhc3Npc3RhbnQgbWVzc2FnZXMpXG4gICAgICovXG4gICAgcHJpdmF0ZSBzaG93UmVzdWx0TWFya2Rvd24odGV4dDogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ1tTaG93IFJlc3VsdCBNYXJrZG93bl0gQ2FsbGVkIHdpdGggdGV4dCBsZW5ndGg6JywgdGV4dC5sZW5ndGgpO1xuXG4gICAgICAgIC8vIEZpbHRlciBvdXQgRklOQUwtQ09OVEVOVCBhbmQgZXZlcnl0aGluZyBhZnRlciBpdFxuICAgICAgICBsZXQgZmlsdGVyZWRUZXh0ID0gdGV4dDtcbiAgICAgICAgY29uc3QgZmluYWxDb250ZW50SW5kZXggPSB0ZXh0LmluZGV4T2YoJy0tLUZJTkFMLUNPTlRFTlQtLS0nKTtcbiAgICAgICAgaWYgKGZpbmFsQ29udGVudEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgZmlsdGVyZWRUZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgZmluYWxDb250ZW50SW5kZXgpLnRyaW0oKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1tTaG93IFJlc3VsdCBNYXJrZG93bl0gRmlsdGVyZWQgRklOQUwtQ09OVEVOVCwgbmV3IGxlbmd0aDonLCBmaWx0ZXJlZFRleHQubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNob3cgdGhlIHJlc3VsdCBzZWN0aW9uXG4gICAgICAgIGNvbnN0IHJlc3VsdFNlY3Rpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2xhdWRlLWNvZGUtcmVzdWx0LXNlY3Rpb24nKTtcbiAgICAgICAgaWYgKHJlc3VsdFNlY3Rpb24pIHtcbiAgICAgICAgICAgIHJlc3VsdFNlY3Rpb24ucmVtb3ZlQ2xhc3MoJ2NsYXVkZS1jb2RlLWhpZGRlbicpO1xuICAgICAgICAgICAgcmVzdWx0U2VjdGlvbi5hZGRDbGFzcygnY2xhdWRlLWNvZGUtdmlzaWJsZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hvdyByZXN1bHQgYXJlYSAoYnV0IGtlZXAgc3RhdHVzIHZpc2libGUgLSBwcm9jZXNzIG1heSBzdGlsbCBiZSBydW5uaW5nISlcbiAgICAgICAgdGhpcy5yZXN1bHRBcmVhLnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgdGhpcy5yZXN1bHRBcmVhLmFkZENsYXNzKCdjbGF1ZGUtY29kZS12aXNpYmxlJyk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGRpdiBmb3IgdGhpcyBtYXJrZG93biBjb250ZW50XG4gICAgICAgIGNvbnN0IGNvbnRlbnREaXYgPSB0aGlzLnJlc3VsdEFyZWEuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgICAgICAgIGNsczogJ21hcmtkb3duLXJlbmRlcmVkJ1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZW5kZXIgYXMgbWFya2Rvd25cbiAgICAgICAgdm9pZCBNYXJrZG93blJlbmRlcmVyLnJlbmRlcihcbiAgICAgICAgICAgIHRoaXMuYXBwLFxuICAgICAgICAgICAgZmlsdGVyZWRUZXh0LFxuICAgICAgICAgICAgY29udGVudERpdixcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE5vdGVQYXRoLFxuICAgICAgICAgICAgdGhpc1xuICAgICAgICApLmNhdGNoKChlOiB1bmtub3duKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbU2hvdyBSZXN1bHQgTWFya2Rvd25dIFJlbmRlciBlcnJvcjonLCBlKTtcbiAgICAgICAgICAgIGNvbnRlbnREaXYudGV4dENvbnRlbnQgPSBmaWx0ZXJlZFRleHQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEF1dG8tc2Nyb2xsIHRvIGJvdHRvbVxuICAgICAgICB0aGlzLnJlc3VsdEFyZWEuc2Nyb2xsVG9wID0gdGhpcy5yZXN1bHRBcmVhLnNjcm9sbEhlaWdodDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXR1cCBzbWFydCBhdXRvLXNjcm9sbCBkZXRlY3Rpb24gb24gcmVzdWx0IGFyZWFcbiAgICAgKi9cbiAgICBwcml2YXRlIHNldHVwU21hcnRBdXRvU2Nyb2xsKCk6IHZvaWQge1xuICAgICAgICAvLyBUcmFjayB3aGVuIHVzZXIgbWFudWFsbHkgc2Nyb2xsc1xuICAgICAgICB0aGlzLnJlc3VsdEFyZWEuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBzY3JvbGxUb3AsIHNjcm9sbEhlaWdodCwgY2xpZW50SGVpZ2h0IH0gPSB0aGlzLnJlc3VsdEFyZWE7XG4gICAgICAgICAgICBjb25zdCBpc05lYXJCb3R0b20gPSBzY3JvbGxIZWlnaHQgLSBzY3JvbGxUb3AgLSBjbGllbnRIZWlnaHQgPCA1MDsgLy8gV2l0aGluIDUwcHggb2YgYm90dG9tXG5cbiAgICAgICAgICAgIC8vIElmIHVzZXIgc2Nyb2xsZWQgdXAgKGF3YXkgZnJvbSBib3R0b20pLCBtYXJrIGFzIG1hbnVhbGx5IHNjcm9sbGVkXG4gICAgICAgICAgICBpZiAoIWlzTmVhckJvdHRvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXNlckhhc1Njcm9sbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdXNlciBzY3JvbGxlZCBiYWNrIHRvIGJvdHRvbSwgcmVzdW1lIGF1dG8tc2Nyb2xsXG4gICAgICAgICAgICAgICAgdGhpcy51c2VySGFzU2Nyb2xsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXV0by1zY3JvbGwgcmVzdWx0IGFyZWEgdG8gYm90dG9tIChvbmx5IGlmIHVzZXIgaGFzbid0IG1hbnVhbGx5IHNjcm9sbGVkIHVwKVxuICAgICAqL1xuICAgIHByaXZhdGUgYXV0b1Njcm9sbFJlc3VsdCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLnVzZXJIYXNTY3JvbGxlZCkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRBcmVhLnNjcm9sbFRvcCA9IHRoaXMucmVzdWx0QXJlYS5zY3JvbGxIZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldCBzY3JvbGwgc3RhdGUgKGNhbGwgd2hlbiBzdGFydGluZyBuZXcgcmVxdWVzdClcbiAgICAgKi9cbiAgICBwcml2YXRlIHJlc2V0U2Nyb2xsU3RhdGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMudXNlckhhc1Njcm9sbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdFJlbmRlcmVkVGV4dCA9ICcnOyAvLyBSZXNldCBpbmNyZW1lbnRhbCByZW5kZXJpbmcgc3RhdGVcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5pc2ggdGhlIHN0cmVhbWluZyByZXN1bHQgYmxvY2tcbiAgICAgKi9cbiAgICBwcml2YXRlIGZpbmlzaFJlc3VsdFN0cmVhbWluZygpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFJlc3VsdFN0cmVhbWluZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1tGaW5pc2ggUmVzdWx0IFN0cmVhbWluZ10gQ2xlYW5pbmcgdXAgc3RyZWFtaW5nIHN0YXRlJyk7XG5cbiAgICAgICAgICAgIC8vIEdldCB0aGUgZnVsbCBhY2N1bXVsYXRlZCB0ZXh0XG4gICAgICAgICAgICBjb25zdCBmdWxsQWNjdW11bGF0ZWRUZXh0ID0gKHRoaXMuY3VycmVudFJlc3VsdFN0cmVhbWluZ0VsZW1lbnQgYXMgdW5rbm93biBhcyBTdHJlYW1pbmdFbGVtZW50RGF0YSkuZnVsbFRleHQgfHwgJyc7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZXJlJ3MgYW55IHRleHQgd2UgaGF2ZW4ndCByZW5kZXJlZCB5ZXRcbiAgICAgICAgICAgIGlmIChmdWxsQWNjdW11bGF0ZWRUZXh0ICYmIGZ1bGxBY2N1bXVsYXRlZFRleHQubGVuZ3RoID4gdGhpcy5sYXN0UmVuZGVyZWRUZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVucmVuZGVyZWRUZXh0ID0gZnVsbEFjY3VtdWxhdGVkVGV4dC5zdWJzdHJpbmcodGhpcy5sYXN0UmVuZGVyZWRUZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHVucmVuZGVyZWRUZXh0LnRyaW0oKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdbRmluaXNoIFJlc3VsdCBTdHJlYW1pbmddIFJlbmRlcmluZyBmaW5hbCB1bnJlbmRlcmVkIHRleHQ6JywgdW5yZW5kZXJlZFRleHQuc3Vic3RyaW5nKDAsIDUwKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgcGxhaW4gdGV4dCBub2RlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RDaGlsZCA9IHRoaXMuY3VycmVudFJlc3VsdFN0cmVhbWluZ0VsZW1lbnQubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdENoaWxkICYmIGxhc3RDaGlsZC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJlc3VsdFN0cmVhbWluZ0VsZW1lbnQucmVtb3ZlQ2hpbGQobGFzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZW5kZXIgdGhlIHVucmVuZGVyZWQgcG9ydGlvbiBhcyBhIG1hcmtkb3duIGJsb2NrXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kTWFya2Rvd25CbG9jayh1bnJlbmRlcmVkVGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBObyB1bnJlbmRlcmVkIHRleHQsIGp1c3QgY29udmVydCBhbnkgcmVtYWluaW5nIHBsYWluIHRleHQgdG8gYSBtYXJrZG93biBibG9ja1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RDaGlsZCA9IHRoaXMuY3VycmVudFJlc3VsdFN0cmVhbWluZ0VsZW1lbnQubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0Q2hpbGQgJiYgbGFzdENoaWxkLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW1haW5pbmdUZXh0ID0gbGFzdENoaWxkLnRleHRDb250ZW50IHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVtYWluaW5nVGV4dC50cmltKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgcGxhaW4gdGV4dCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXN1bHRTdHJlYW1pbmdFbGVtZW50LnJlbW92ZUNoaWxkKGxhc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW5kZXIgaXQgYXMgYSBmaW5hbCBtYXJrZG93biBibG9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRNYXJrZG93bkJsb2NrKHJlbWFpbmluZ1RleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBKdXN0IHVwZGF0ZSB0aGUgQ1NTIGNsYXNzIC0gY29udGVudCBpcyBhbHJlYWR5IHJlbmRlcmVkIGFzIG1hcmtkb3duXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXN1bHRTdHJlYW1pbmdFbGVtZW50LnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS1yZXN1bHQtc3RyZWFtaW5nJyk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXN1bHRTdHJlYW1pbmdFbGVtZW50LmFkZENsYXNzKCdtYXJrZG93bi1yZW5kZXJlZCcpO1xuXG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgc3RyZWFtaW5nIGVsZW1lbnQgcmVmZXJlbmNlXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXN1bHRTdHJlYW1pbmdFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3cgcmVzdWx0IHBhbmVsIHdpdGggQ2xhdWRlJ3MgcmVzcG9uc2VcbiAgICAgKi9cbiAgICBwcml2YXRlIHNob3dSZXN1bHQobWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMucmVzdWx0QXJlYS5lbXB0eSgpO1xuXG4gICAgICAgIC8vIEZpbHRlciBvdXQgRklOQUwtQ09OVEVOVCBhbmQgZXZlcnl0aGluZyBhZnRlciBpdFxuICAgICAgICBsZXQgZmlsdGVyZWRNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgY29uc3QgZmluYWxDb250ZW50SW5kZXggPSBtZXNzYWdlLmluZGV4T2YoJy0tLUZJTkFMLUNPTlRFTlQtLS0nKTtcbiAgICAgICAgaWYgKGZpbmFsQ29udGVudEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgZmlsdGVyZWRNZXNzYWdlID0gbWVzc2FnZS5zdWJzdHJpbmcoMCwgZmluYWxDb250ZW50SW5kZXgpLnRyaW0oKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1tTaG93IFJlc3VsdF0gRmlsdGVyZWQgRklOQUwtQ09OVEVOVCwgb3JpZ2luYWwgbGVuZ3RoOicsIG1lc3NhZ2UubGVuZ3RoLCAnZmlsdGVyZWQgbGVuZ3RoOicsIGZpbHRlcmVkTWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVuZGVyIGFzIG1hcmtkb3duXG4gICAgICAgIHZvaWQgTWFya2Rvd25SZW5kZXJlci5yZW5kZXIoXG4gICAgICAgICAgICB0aGlzLmFwcCxcbiAgICAgICAgICAgIGZpbHRlcmVkTWVzc2FnZSxcbiAgICAgICAgICAgIHRoaXMucmVzdWx0QXJlYSxcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE5vdGVQYXRoLFxuICAgICAgICAgICAgdGhpc1xuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdFNlY3Rpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2xhdWRlLWNvZGUtcmVzdWx0LXNlY3Rpb24nKTtcbiAgICAgICAgaWYgKHJlc3VsdFNlY3Rpb24pIHtcbiAgICAgICAgICAgIHJlc3VsdFNlY3Rpb24ucmVtb3ZlQ2xhc3MoJ2NsYXVkZS1jb2RlLWhpZGRlbicpO1xuICAgICAgICAgICAgcmVzdWx0U2VjdGlvbi5hZGRDbGFzcygnY2xhdWRlLWNvZGUtdmlzaWJsZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGlkZSBzdGF0dXMgYXJlYSwgc2hvdyByZXN1bHQgYXJlYVxuICAgICAgICB0aGlzLnN0YXR1c0luZGljYXRvci5hZGRDbGFzcygnY2xhdWRlLWNvZGUtaGlkZGVuJyk7XG4gICAgICAgIHRoaXMuc3RhdHVzSW5kaWNhdG9yLnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS1mbGV4LXZpc2libGUnKTtcbiAgICAgICAgdGhpcy5yZXN1bHRBcmVhLnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgdGhpcy5yZXN1bHRBcmVhLmFkZENsYXNzKCdjbGF1ZGUtY29kZS12aXNpYmxlJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGlkZSByZXN1bHQgcGFuZWxcbiAgICAgKi9cbiAgICBwcml2YXRlIGhpZGVSZXN1bHQoKTogdm9pZCB7XG4gICAgICAgIC8vIEhpZGUgdGhlIHJlc3VsdCBhcmVhIGJ1dCBkb24ndCBoaWRlIHRoZSBlbnRpcmUgc2VjdGlvbiBpZiBzdGF0dXMgaXMgc2hvd2luZ1xuICAgICAgICB0aGlzLnJlc3VsdEFyZWEuYWRkQ2xhc3MoJ2NsYXVkZS1jb2RlLWhpZGRlbicpO1xuICAgICAgICB0aGlzLnJlc3VsdEFyZWEucmVtb3ZlQ2xhc3MoJ2NsYXVkZS1jb2RlLXZpc2libGUnKTtcbiAgICAgICAgdGhpcy5yZXN1bHRBcmVhLmVtcHR5KCk7XG5cbiAgICAgICAgLy8gT25seSBoaWRlIHRoZSBlbnRpcmUgc2VjdGlvbiBpZiBzdGF0dXMgaXMgYWxzbyBub3QgdmlzaWJsZVxuICAgICAgICBpZiAodGhpcy5zdGF0dXNJbmRpY2F0b3IuaGFzQ2xhc3MoJ2NsYXVkZS1jb2RlLWhpZGRlbicpKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRTZWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NsYXVkZS1jb2RlLXJlc3VsdC1zZWN0aW9uJyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0U2VjdGlvbikge1xuICAgICAgICAgICAgICAgIHJlc3VsdFNlY3Rpb24uYWRkQ2xhc3MoJ2NsYXVkZS1jb2RlLWhpZGRlbicpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFNlY3Rpb24ucmVtb3ZlQ2xhc3MoJ2NsYXVkZS1jb2RlLXZpc2libGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3cgcGVybWlzc2lvbiBhcHByb3ZhbCBzZWN0aW9uXG4gICAgICovXG4gICAgcHJpdmF0ZSBzaG93UGVybWlzc2lvbkFwcHJvdmFsU2VjdGlvbigpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMucGVybWlzc2lvbkFwcHJvdmFsU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5wZXJtaXNzaW9uQXBwcm92YWxTZWN0aW9uLnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgICAgIHRoaXMucGVybWlzc2lvbkFwcHJvdmFsU2VjdGlvbi5hZGRDbGFzcygnY2xhdWRlLWNvZGUtdmlzaWJsZScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGlkZSBwZXJtaXNzaW9uIGFwcHJvdmFsIHNlY3Rpb25cbiAgICAgKi9cbiAgICBwcml2YXRlIGhpZGVQZXJtaXNzaW9uQXBwcm92YWxTZWN0aW9uKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5wZXJtaXNzaW9uQXBwcm92YWxTZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnBlcm1pc3Npb25BcHByb3ZhbFNlY3Rpb24uYWRkQ2xhc3MoJ2NsYXVkZS1jb2RlLWhpZGRlbicpO1xuICAgICAgICAgICAgdGhpcy5wZXJtaXNzaW9uQXBwcm92YWxTZWN0aW9uLnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS12aXNpYmxlJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYXBwcm92ZSBwZXJtaXNzaW9uIGJ1dHRvbiBjbGlja1xuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgaGFuZGxlQXBwcm92ZVBlcm1pc3Npb24oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldEN1cnJlbnRDb250ZXh0KCk7XG4gICAgICAgIGlmICghY29udGV4dC5jdXJyZW50UmVxdWVzdCkge1xuICAgICAgICAgICAgbmV3IE5vdGljZSh0KCdtaXNjLm5vUGVuZGluZ1JlcXVlc3QnKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIaWRlIHBlcm1pc3Npb24gYXBwcm92YWwgc2VjdGlvblxuICAgICAgICB0aGlzLmhpZGVQZXJtaXNzaW9uQXBwcm92YWxTZWN0aW9uKCk7XG5cbiAgICAgICAgLy8gR2V0IGFjdGl2ZSBmaWxlXG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuICAgICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UodCgnbm90aWNlLm5vQWN0aXZlTm90ZScpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmQgbWFya2Rvd24gdmlld1xuICAgICAgICBjb25zdCBsZWF2ZXMgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhdmVzT2ZUeXBlKCdtYXJrZG93bicpO1xuICAgICAgICBsZXQgYWN0aXZlVmlldzogTWFya2Rvd25WaWV3IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgbGVhZiBvZiBsZWF2ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBsZWFmLnZpZXcgYXMgTWFya2Rvd25WaWV3O1xuICAgICAgICAgICAgaWYgKHZpZXcuZmlsZSAmJiB2aWV3LmZpbGUucGF0aCA9PT0gZmlsZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlVmlldyA9IHZpZXc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFjdGl2ZVZpZXcgfHwgIWFjdGl2ZVZpZXcuZWRpdG9yKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKHQoJ25vdGljZS5ub0VkaXRvcicpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVkaXRvciA9IGFjdGl2ZVZpZXcuZWRpdG9yO1xuXG4gICAgICAgIC8vIFByZXBhcmUgYSBuZXcgcHJvbXB0IHRlbGxpbmcgQ2xhdWRlIHRvIHByb2NlZWQgd2l0aCBieXBhc3MgcGVybWlzc2lvbnNcbiAgICAgICAgY29uc3QgYXBwcm92YWxQcm9tcHQgPSBcIlllcywgSSBhcHByb3ZlLiBZb3UgaGF2ZSBwZXJtaXNzaW9ubGVzcyBtb2RlIGVuYWJsZWQgLSBwbGVhc2UgcHJvY2VlZCB3aXRoIHRoZSBhY3Rpb24geW91IHdlcmUgYXNraW5nIGFib3V0LiBEb24ndCBoZXNpdGF0ZSB0byBleGVjdXRlIGl0LlwiO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyByZXF1ZXN0IHdpdGggYnlwYXNzIHBlcm1pc3Npb25zIGVuYWJsZWRcbiAgICAgICAgY29uc3QgbmV3UmVxdWVzdDogQ2xhdWRlQ29kZVJlcXVlc3QgPSB7XG4gICAgICAgICAgICAuLi5jb250ZXh0LmN1cnJlbnRSZXF1ZXN0LFxuICAgICAgICAgICAgdXNlclByb21wdDogYXBwcm92YWxQcm9tcHQsXG4gICAgICAgICAgICBieXBhc3NQZXJtaXNzaW9uczogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ0RpcjogdGhpcy5hcHAudmF1bHQuY29uZmlnRGlyXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVXBkYXRlIFVJXG4gICAgICAgIHRoaXMucnVuQnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ydW5CdXR0b24udGV4dENvbnRlbnQgPSB0KCdpbnB1dC5ydW5uaW5nQnV0dG9uJyk7XG4gICAgICAgIHRoaXMuY2FuY2VsQnV0dG9uLnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgdGhpcy5jYW5jZWxCdXR0b24uYWRkQ2xhc3MoJ2NsYXVkZS1jb2RlLWlubGluZS12aXNpYmxlJyk7XG4gICAgICAgIHRoaXMub3V0cHV0UmVuZGVyZXIuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5oaWRlUHJldmlldygpO1xuICAgICAgICB0aGlzLmhpZGVSZXN1bHQoKTtcblxuICAgICAgICAvLyBTaG93IHN0YXR1cyB3aXRoIGVsYXBzZWQgdGltZSB0cmFja2luZ1xuICAgICAgICB0aGlzLnNob3dTdGF0dXMoJ1x1RDgzRFx1REQxMyAnICsgdCgnc3RhdHVzLnJ1bm5pbmdBdXRob3JpemVkJykgKyAnIC4uLiAwLjBzJyk7XG4gICAgICAgIHRoaXMuc3RhcnRFbGFwc2VkVGltZVRyYWNraW5nKCdcdUQ4M0RcdUREMTMgJyArIHQoJ3N0YXR1cy5ydW5uaW5nQXV0aG9yaXplZCcpKTtcblxuICAgICAgICAvLyBDYXB0dXJlIHRoZSBub3RlIHBhdGggZm9yIHRoaXMgc3BlY2lmaWMgcnVuXG4gICAgICAgIGNvbnN0IHJ1bk5vdGVQYXRoID0gZmlsZS5wYXRoO1xuXG4gICAgICAgIC8vIFJ1biBDbGF1ZGUgQ29kZSB3aXRoIGJ5cGFzcyBwZXJtaXNzaW9uc1xuICAgICAgICBjb250ZXh0LmlzUnVubmluZyA9IHRydWU7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29udGV4dC5ydW5uZXIucnVuKFxuICAgICAgICAgICAgbmV3UmVxdWVzdCxcbiAgICAgICAgICAgIChsaW5lOiBzdHJpbmcsIGlzTWFya2Rvd24/OiBib29sZWFuLCBpc1N0cmVhbWluZz86IGJvb2xlYW4gfCBzdHJpbmcsIGlzQXNzaXN0YW50TWVzc2FnZT86IGJvb2xlYW4pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZE91dHB1dFRvTm90ZShydW5Ob3RlUGF0aCwgbGluZSwgaXNNYXJrZG93biwgaXNTdHJlYW1pbmcsIGlzQXNzaXN0YW50TWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vdGVQYXRoID09PSBydW5Ob3RlUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXR1c0Zyb21PdXRwdXQobGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnRleHQuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIGNvbnRleHQuY3VycmVudFJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIGNvbnRleHQuZXhlY3V0aW9uU3RhcnRUaW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250ZXh0LmJhc2VTdGF0dXNNZXNzYWdlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIEhpZGUgc3RhdHVzXG4gICAgICAgIHRoaXMuaGlkZVN0YXR1cygpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBVSVxuICAgICAgICB0aGlzLnJ1bkJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJ1bkJ1dHRvbi50ZXh0Q29udGVudCA9IHQoJ2lucHV0LnJ1bkJ1dHRvbicpO1xuXG4gICAgICAgIHRoaXMuY2FuY2VsQnV0dG9uLmFkZENsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgdGhpcy5jYW5jZWxCdXR0b24ucmVtb3ZlQ2xhc3MoJ2NsYXVkZS1jb2RlLWlubGluZS12aXNpYmxlJyk7XG5cbiAgICAgICAgLy8gSGFuZGxlIHJlc3BvbnNlIChzYW1lIGFzIHJlZ3VsYXIgcnVuKVxuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgY29udGV4dC5oaXN0b3J5LnB1c2goe1xuICAgICAgICAgICAgICAgIHByb21wdDogYXBwcm92YWxQcm9tcHQsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgbm90ZVBhdGg6IGZpbGUucGF0aCxcbiAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogbmV3UmVxdWVzdCxcbiAgICAgICAgICAgICAgICBvdXRwdXRMaW5lczogY29udGV4dC5vdXRwdXRMaW5lc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlSGlzdG9yeURpc3BsYXkoY29udGV4dC5oaXN0b3J5KTtcblxuICAgICAgICAgICAgY29uc3QgdmF1bHRQYXRoID0gKHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIgYXMgRmlsZVN5c3RlbUFkYXB0ZXIpLmdldEJhc2VQYXRoKCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRNYW5hZ2VyLnNhdmVDb250ZXh0KGZpbGUucGF0aCwgdmF1bHRQYXRoKTtcblxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm1vZGlmaWVkQ29udGVudCAmJiByZXNwb25zZS5tb2RpZmllZENvbnRlbnQudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXV0b0FjY2VwdENoZWNrYm94LmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vdGVQYXRoID09PSBydW5Ob3RlUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93U3RhdHVzKCdcdTI3MDUgJyArIHQoJ3N0YXR1cy5hdXRvQXBwbHlpbmcnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBseUNoYW5nZXNUb0VkaXRvcihyZXNwb25zZS5tb2RpZmllZENvbnRlbnQsIGVkaXRvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnROb3RlUGF0aCA9PT0gcnVuTm90ZVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZVN0YXR1cygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1x1MjcxMyAnICsgdCgnbm90aWNlLmNoYW5nZXNBcHBsaWVkJykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd1ByZXZpZXcocmVzcG9uc2UubW9kaWZpZWRDb250ZW50LCBydW5Ob3RlUGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHVwZGF0ZSBVSSBpZiB0aGlzIGlzIHN0aWxsIHRoZSBhY3RpdmUgbm90ZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnROb3RlUGF0aCA9PT0gcnVuTm90ZVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBjYWxsIHNob3dSZXN1bHQgaWYgd2UgaGF2ZW4ndCBiZWVuIHN0cmVhbWluZyAoc3RyZWFtaW5nIGFscmVhZHkgcmVuZGVyZWQgdGhlIHJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0U2VjdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjbGF1ZGUtY29kZS1yZXN1bHQtc2VjdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNTdHJlYW1lZENvbnRlbnQgPSByZXN1bHRTZWN0aW9uICYmIHJlc3VsdFNlY3Rpb24uaGFzQ2xhc3MoJ2NsYXVkZS1jb2RlLXZpc2libGUnKSAmJiB0aGlzLnJlc3VsdEFyZWEuY2hpbGRyZW4ubGVuZ3RoID4gMDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc1N0cmVhbWVkQ29udGVudCAmJiByZXNwb25zZS5hc3Npc3RhbnRNZXNzYWdlICYmIHJlc3BvbnNlLmFzc2lzdGFudE1lc3NhZ2UudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dSZXN1bHQocmVzcG9uc2UuYXNzaXN0YW50TWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKCdcdTI3MTMgJyArIHQoJ25vdGljZS5jb21wbGV0ZWQnKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzU3RyZWFtZWRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN1bHQgd2FzIGFscmVhZHkgc3RyZWFtZWQsIGp1c3Qgc2hvdyBub3RpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1x1MjcxMyAnICsgdCgnbm90aWNlLmNvbXBsZXRlZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1x1MjcxMyAnICsgdCgnbm90aWNlLmNvbXBsZXRlZE5vQ2hhbmdlcycpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1x1MjcxMyAnICsgdCgnbm90aWNlLmNvbXBsZXRlZCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50Tm90ZVBhdGggPT09IHJ1bk5vdGVQYXRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93RXJyb3JTdGF0dXMoJ1x1Mjc0QyAnICsgdCgnc3RhdHVzLmZhaWxlZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYFx1MjcxNyBDbGF1ZGUgQ29kZSBmYWlsZWQ6ICR7cmVzcG9uc2UuZXJyb3IgfHwgJ1Vua25vd24gZXJyb3InfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGRlbnkgcGVybWlzc2lvbiBidXR0b24gY2xpY2tcbiAgICAgKi9cbiAgICBwcml2YXRlIGhhbmRsZURlbnlQZXJtaXNzaW9uKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmhpZGVQZXJtaXNzaW9uQXBwcm92YWxTZWN0aW9uKCk7XG4gICAgICAgIG5ldyBOb3RpY2UodCgnbm90aWNlLnBlcm1pc3Npb25EZW5pZWQnKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFwcGx5IGNoYW5nZXNcbiAgICAgKi9cbiAgICBwcml2YXRlIGhhbmRsZUFwcGx5Q2hhbmdlcygpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q3VycmVudENvbnRleHQoKTtcblxuICAgICAgICAvLyBVc2UgcGVuZGluZyBwcmV2aWV3IGNvbnRlbnQgKHBlci1ub3RlIHN0YXRlKSBvciBmYWxsIGJhY2sgdG8gcmVzcG9uc2VcbiAgICAgICAgY29uc3QgY29udGVudFRvQXBwbHkgPSBjb250ZXh0LnBlbmRpbmdQcmV2aWV3Q29udGVudCB8fCBjb250ZXh0LmN1cnJlbnRSZXNwb25zZT8ubW9kaWZpZWRDb250ZW50O1xuXG4gICAgICAgIGlmICghY29udGVudFRvQXBwbHkpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1x1MjZBMCAnICsgdCgnbm90aWNlLm5vQ2hhbmdlc1RvQXBwbHknKSk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbQXBwbHkgQ2hhbmdlc10gTm8gbW9kaWZpZWQgY29udGVudCBmb3VuZCBpbiBjb250ZXh0Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgdGhlIGFjdGl2ZSBmaWxlXG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuICAgICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1x1MjZBMCAnICsgdCgnbm90aWNlLm5vQWN0aXZlRmlsZScpKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tBcHBseSBDaGFuZ2VzXSBObyBhY3RpdmUgZmlsZSBmb3VuZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluZCB0aGUgbWFya2Rvd24gdmlldyBmb3IgdGhpcyBmaWxlXG4gICAgICAgIGNvbnN0IGxlYXZlcyA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWF2ZXNPZlR5cGUoJ21hcmtkb3duJyk7XG4gICAgICAgIGxldCB0YXJnZXRWaWV3OiBNYXJrZG93blZpZXcgfCBudWxsID0gbnVsbDtcblxuICAgICAgICBmb3IgKGNvbnN0IGxlYWYgb2YgbGVhdmVzKSB7XG4gICAgICAgICAgICBjb25zdCB2aWV3ID0gbGVhZi52aWV3IGFzIE1hcmtkb3duVmlldztcbiAgICAgICAgICAgIGlmICh2aWV3LmZpbGUgJiYgdmlldy5maWxlLnBhdGggPT09IGZpbGUucGF0aCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmFsbGJhY2s6IHVzZSBmaXJzdCBtYXJrZG93biB2aWV3XG4gICAgICAgIGlmICghdGFyZ2V0VmlldyAmJiBsZWF2ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGFyZ2V0VmlldyA9IGxlYXZlc1swXS52aWV3IGFzIE1hcmtkb3duVmlldztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGFyZ2V0VmlldyB8fCAhdGFyZ2V0Vmlldy5lZGl0b3IpIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1x1MjZBMCAnICsgdCgnbm90aWNlLm5vRWRpdG9yJykpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW0FwcGx5IENoYW5nZXNdIE5vIG1hcmtkb3duIHZpZXcgb3IgZWRpdG9yIGZvdW5kJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5hcHBseUNoYW5nZXNUb0VkaXRvcihjb250ZW50VG9BcHBseSwgdGFyZ2V0Vmlldy5lZGl0b3IpO1xuICAgICAgICAgICAgdGhpcy5oaWRlUHJldmlldygpO1xuICAgICAgICAgICAgbmV3IE5vdGljZSgnXHUyNzEzICcgKyB0KCdub3RpY2UuY2hhbmdlc0FwcGxpZWRTdWNjZXNzJykpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbmV3IE5vdGljZSgnXHUyNzE3ICcgKyB0KCdub3RpY2UuZmFpbGVkQXBwbHlDaGFuZ2VzJykpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW0FwcGx5IENoYW5nZXNdIEVycm9yOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IGNoYW5nZXMgdG8gZWRpdG9yXG4gICAgICovXG4gICAgcHJpdmF0ZSBhcHBseUNoYW5nZXNUb0VkaXRvcihjb250ZW50OiBzdHJpbmcsIGVkaXRvcjogRWRpdG9yKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldEN1cnJlbnRDb250ZXh0KCk7XG4gICAgICAgIGNvbnN0IGN1cnNvckJlZm9yZSA9IGVkaXRvci5nZXRDdXJzb3IoKTtcblxuICAgICAgICAvLyBDaGVjayBpZiB3ZSB3ZXJlIGVkaXRpbmcgc2VsZWN0ZWQgdGV4dCBvbmx5XG4gICAgICAgIGlmIChjb250ZXh0LmN1cnJlbnRSZXF1ZXN0Py5zZWxlY3RlZFRleHQpIHtcbiAgICAgICAgICAgIC8vIFJlcGxhY2Ugc2VsZWN0ZWQgdGV4dCBvbmx5XG4gICAgICAgICAgICBlZGl0b3IucmVwbGFjZVNlbGVjdGlvbihjb250ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgZW50aXJlIG5vdGVcbiAgICAgICAgICAgIGVkaXRvci5zZXRWYWx1ZShjb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcmVzZXJ2ZUN1cnNvclBvc2l0aW9uKSB7XG4gICAgICAgICAgICBlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvckJlZm9yZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgcmVqZWN0IGNoYW5nZXNcbiAgICAgKi9cbiAgICBwcml2YXRlIGhhbmRsZVJlamVjdENoYW5nZXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaGlkZVByZXZpZXcoKTtcbiAgICAgICAgbmV3IE5vdGljZSh0KCdub3RpY2UuY2hhbmdlc1JlamVjdGVkJykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBjYW5jZWxcbiAgICAgKi9cbiAgICBwcml2YXRlIGhhbmRsZUNhbmNlbCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q3VycmVudENvbnRleHQoKTtcbiAgICAgICAgY29udGV4dC5ydW5uZXIudGVybWluYXRlKCk7XG4gICAgICAgIGNvbnRleHQuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIGNvbnRleHQuZXhlY3V0aW9uU3RhcnRUaW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250ZXh0LmJhc2VTdGF0dXNNZXNzYWdlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJ1bkJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJ1bkJ1dHRvbi50ZXh0Q29udGVudCA9IHQoJ2lucHV0LnJ1bkJ1dHRvbicpO1xuICAgICAgICB0aGlzLmNhbmNlbEJ1dHRvbi5hZGRDbGFzcygnY2xhdWRlLWNvZGUtaGlkZGVuJyk7XG4gICAgICAgIHRoaXMuY2FuY2VsQnV0dG9uLnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS1pbmxpbmUtdmlzaWJsZScpO1xuICAgICAgICB0aGlzLmhpZGVTdGF0dXMoKTtcbiAgICAgICAgbmV3IE5vdGljZSh0KCdub3RpY2UuY2FuY2VsbGVkJykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc3BvbmQgdG8gaW50ZXJhY3RpdmUgcHJvbXB0IChwbGFjZWhvbGRlciBmb3IgZnV0dXJlIHVzZSlcbiAgICAgKi9cbiAgICBwcml2YXRlIHJlc3BvbmRUb1Byb21wdChyZXNwb25zZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIC8vIEZ1dHVyZSBpbXBsZW1lbnRhdGlvbiBmb3IgaW50ZXJhY3RpdmUgUSZBXG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ0ludGVyYWN0aXZlIHJlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBkaWZmIEhUTUwgYmV0d2VlbiBvcmlnaW5hbCBhbmQgbW9kaWZpZWQgY29udGVudFxuICAgICAqL1xuICAgIHByaXZhdGUgZ2VuZXJhdGVEaWZmRWxlbWVudChvcmlnaW5hbDogc3RyaW5nLCBtb2RpZmllZDogc3RyaW5nKTogSFRNTEVsZW1lbnQge1xuICAgICAgICByZXR1cm4gRGlmZkdlbmVyYXRvci5nZW5lcmF0ZURpZmZFbGVtZW50KG9yaWdpbmFsLCBtb2RpZmllZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGhpc3RvcnkgZGlzcGxheVxuICAgICAqL1xuICAgIHByaXZhdGUgdXBkYXRlSGlzdG9yeURpc3BsYXkoaGlzdG9yeTogU2Vzc2lvbkhpc3RvcnlJdGVtW10pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5TGlzdC5lbXB0eSgpO1xuXG4gICAgICAgIGNvbnN0IGhpc3RvcnlTZWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NsYXVkZS1jb2RlLWhpc3Rvcnktc2VjdGlvbicpO1xuXG4gICAgICAgIGlmIChoaXN0b3J5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gSGlkZSBoaXN0b3J5IHNlY3Rpb24gd2hlbiBlbXB0eVxuICAgICAgICAgICAgaWYgKGhpc3RvcnlTZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaGlzdG9yeVNlY3Rpb24uYWRkQ2xhc3MoJ2NsYXVkZS1jb2RlLWhpZGRlbicpO1xuICAgICAgICAgICAgICAgIGhpc3RvcnlTZWN0aW9uLnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS12aXNpYmxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaG93IGhpc3Rvcnkgc2VjdGlvbiB3aGVuIHRoZXJlJ3MgY29udGVudFxuICAgICAgICBpZiAoaGlzdG9yeVNlY3Rpb24pIHtcbiAgICAgICAgICAgIGhpc3RvcnlTZWN0aW9uLnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgICAgIGhpc3RvcnlTZWN0aW9uLmFkZENsYXNzKCdjbGF1ZGUtY29kZS12aXNpYmxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaGlzdG9yeS5zbGljZSgpLnJldmVyc2UoKSkge1xuICAgICAgICAgICAgY29uc3QgbGkgPSB0aGlzLmhpc3RvcnlMaXN0LmNyZWF0ZUVsKCdsaScpO1xuICAgICAgICAgICAgY29uc3QgaWNvbiA9IGl0ZW0uc3VjY2VzcyA/ICdcdTI3MTMnIDogJ1x1MjcxNyc7XG4gICAgICAgICAgICBjb25zdCB0aW1lID0gbmV3IERhdGUoaXRlbS50aW1lc3RhbXApLnRvTG9jYWxlVGltZVN0cmluZygpO1xuICAgICAgICAgICAgbGkuY3JlYXRlRWwoJ3NwYW4nLCB7IHRleHQ6IGAke2ljb259ICR7dGltZX1gLCBjbHM6ICdoaXN0b3J5LXRpbWUnIH0pO1xuXG4gICAgICAgICAgICAvLyBUcmltIHByb21wdCB0byAxMDAgY2hhcmFjdGVyc1xuICAgICAgICAgICAgY29uc3QgZGlzcGxheVByb21wdCA9IGl0ZW0ucHJvbXB0Lmxlbmd0aCA+IDEwMFxuICAgICAgICAgICAgICAgID8gaXRlbS5wcm9tcHQuc3Vic3RyaW5nKDAsIDEwMCkgKyAnLi4uJ1xuICAgICAgICAgICAgICAgIDogaXRlbS5wcm9tcHQ7XG4gICAgICAgICAgICBsaS5jcmVhdGVFbCgnc3BhbicsIHsgdGV4dDogZGlzcGxheVByb21wdCwgY2xzOiAnaGlzdG9yeS1wcm9tcHQnIH0pO1xuXG4gICAgICAgICAgICAvLyBBZGQgY2xpY2sgaGFuZGxlciB0byByZXN0b3JlIGZyb20gaGlzdG9yeVxuICAgICAgICAgICAgbGkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLnJlc3RvcmVGcm9tSGlzdG9yeShpdGVtKSk7XG4gICAgICAgICAgICBsaS5hZGRDbGFzcygnY2xhdWRlLWNvZGUtY3Vyc29yLXBvaW50ZXInKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgc3RhdGUgZnJvbSBhIGhpc3RvcnkgaXRlbVxuICAgICAqL1xuICAgIHByaXZhdGUgcmVzdG9yZUZyb21IaXN0b3J5KGl0ZW06IFNlc3Npb25IaXN0b3J5SXRlbSk6IHZvaWQge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDdXJyZW50Q29udGV4dCgpO1xuXG4gICAgICAgIC8vIFJlc3RvcmUgcHJvbXB0XG4gICAgICAgIHRoaXMucHJvbXB0SW5wdXQudmFsdWUgPSBpdGVtLnByb21wdDtcblxuICAgICAgICAvLyBSZXN0b3JlIG91dHB1dCBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKGl0ZW0ub3V0cHV0TGluZXMgJiYgaXRlbS5vdXRwdXRMaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dFJlbmRlcmVyLmNsZWFyKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgaXRlbS5vdXRwdXRMaW5lcykge1xuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0UmVuZGVyZXIuYXBwZW5kTGluZShsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc3RvcmUgcmVzcG9uc2UgYW5kIHJlcXVlc3RcbiAgICAgICAgaWYgKGl0ZW0ucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGNvbnRleHQuY3VycmVudFJlc3BvbnNlID0gaXRlbS5yZXNwb25zZTtcblxuICAgICAgICAgICAgLy8gQlVHIEZJWDogUmVzdG9yZSB0aGUgYXNzaXN0YW50IG1lc3NhZ2UgaW4gdGhlIFJlc3VsdCBzZWN0aW9uXG4gICAgICAgICAgICBpZiAoaXRlbS5yZXNwb25zZS5hc3Npc3RhbnRNZXNzYWdlICYmIGl0ZW0ucmVzcG9uc2UuYXNzaXN0YW50TWVzc2FnZS50cmltKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dSZXN1bHQoaXRlbS5yZXNwb25zZS5hc3Npc3RhbnRNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbS5yZXF1ZXN0KSB7XG4gICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRSZXF1ZXN0ID0gaXRlbS5yZXF1ZXN0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hvdyBwcmV2aWV3IGlmIHRoZXJlJ3MgYSBzdWNjZXNzZnVsIHJlc3BvbnNlIHdpdGggY29udGVudFxuICAgICAgICBpZiAoaXRlbS5zdWNjZXNzICYmIGl0ZW0ucmVzcG9uc2U/Lm1vZGlmaWVkQ29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5zaG93UHJldmlldyhpdGVtLnJlc3BvbnNlLm1vZGlmaWVkQ29udGVudCk7XG4gICAgICAgICAgICBuZXcgTm90aWNlKHQoJ25vdGljZS5oaXN0b3J5UmVzdG9yZWRXaXRoQ2hhbmdlcycpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZVByZXZpZXcoKTtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UodCgnbm90aWNlLmhpc3RvcnlSZXN0b3JlZCcpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIGhpc3RvcnlcbiAgICAgKi9cbiAgICBwcml2YXRlIGNsZWFySGlzdG9yeSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jb250ZXh0TWFuYWdlci5jbGVhckhpc3RvcnkodGhpcy5jdXJyZW50Tm90ZVBhdGgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUhpc3RvcnlEaXNwbGF5KFtdKTtcbiAgICAgICAgY29uc3QgaGlzdG9yeVNlY3Rpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2xhdWRlLWNvZGUtaGlzdG9yeS1zZWN0aW9uJyk7XG4gICAgICAgIGlmIChoaXN0b3J5U2VjdGlvbikge1xuICAgICAgICAgICAgaGlzdG9yeVNlY3Rpb24uYWRkQ2xhc3MoJ2NsYXVkZS1jb2RlLWhpZGRlbicpO1xuICAgICAgICAgICAgaGlzdG9yeVNlY3Rpb24ucmVtb3ZlQ2xhc3MoJ2NsYXVkZS1jb2RlLXZpc2libGUnKTtcbiAgICAgICAgfVxuICAgICAgICBuZXcgTm90aWNlKHQoJ25vdGljZS5oaXN0b3J5Q2xlYXJlZCcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgdG9kbyBsaXN0IGRpc3BsYXlcbiAgICAgKi9cbiAgICBwcml2YXRlIGNsZWFyVG9kb0xpc3QoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHBsYW5Db2x1bW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2xhdWRlLWNvZGUtcGxhbi1jb2x1bW4nKSBhcyBIVE1MRWxlbWVudDtcbiAgICAgICAgY29uc3QgdG9kb0xpc3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2xhdWRlLWNvZGUtdG9kby1saXN0Jyk7XG4gICAgICAgIGNvbnN0IGVtcHR5UGxhbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjbGF1ZGUtY29kZS1lbXB0eS1wbGFuJyk7XG5cbiAgICAgICAgY29uc29sZS5kZWJ1ZygnW0NsZWFyIFRvZG8gTGlzdF0gQ2FsbGVkJyk7XG5cbiAgICAgICAgaWYgKCF0b2RvTGlzdCB8fCAhcGxhbkNvbHVtbikge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnW0NsZWFyIFRvZG8gTGlzdF0gRWxlbWVudHMgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbGVhciB0aGUgbGlzdFxuICAgICAgICB0b2RvTGlzdC5lbXB0eSgpO1xuXG4gICAgICAgIC8vIEhpZGUgZW1wdHkgbWVzc2FnZSBhbmQgbGlzdFxuICAgICAgICBpZiAoZW1wdHlQbGFuKSB7XG4gICAgICAgICAgICBlbXB0eVBsYW4uYWRkQ2xhc3MoJ2NsYXVkZS1jb2RlLWhpZGRlbicpO1xuICAgICAgICB9XG4gICAgICAgIHRvZG9MaXN0LmFkZENsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcblxuICAgICAgICAvLyBIaWRlIHRoZSBQTEFOIENPTFVNTiBvbmx5XG4gICAgICAgIHBsYW5Db2x1bW4uYWRkQ2xhc3MoJ2NsYXVkZS1jb2RlLWhpZGRlbicpO1xuXG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ1tDbGVhciBUb2RvIExpc3RdIFBsYW4gY29sdW1uIGhpZGRlbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBDbGF1ZGUncyB0b2RvIGxpc3QgZGlzcGxheVxuICAgICAqL1xuICAgIHByaXZhdGUgdXBkYXRlVG9kb0xpc3QodG9kb3M6IEFycmF5PHtjb250ZW50OiBzdHJpbmcsIHN0YXR1czogc3RyaW5nLCBhY3RpdmVGb3JtOiBzdHJpbmd9Pik6IHZvaWQge1xuICAgICAgICBjb25zdCBhZ2VudENvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjbGF1ZGUtY29kZS1hZ2VudC1jb250YWluZXInKTtcbiAgICAgICAgY29uc3QgcGxhbkNvbHVtbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jbGF1ZGUtY29kZS1wbGFuLWNvbHVtbicpIGFzIEhUTUxFbGVtZW50O1xuICAgICAgICBjb25zdCB0b2RvTGlzdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjbGF1ZGUtY29kZS10b2RvLWxpc3QnKTtcbiAgICAgICAgY29uc3QgZW1wdHlQbGFuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NsYXVkZS1jb2RlLWVtcHR5LXBsYW4nKTtcblxuICAgICAgICBpZiAoIWFnZW50Q29udGFpbmVyIHx8ICF0b2RvTGlzdCB8fCAhcGxhbkNvbHVtbikgcmV0dXJuO1xuXG4gICAgICAgIC8vIENsZWFyIGV4aXN0aW5nIHRvZG9zXG4gICAgICAgIHRvZG9MaXN0LmVtcHR5KCk7XG5cbiAgICAgICAgaWYgKHRvZG9zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gSGlkZSB0aGUgcGxhbiBjb2x1bW4gLSBubyBwbGFuXG4gICAgICAgICAgICBwbGFuQ29sdW1uLmFkZENsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgICAgIGlmIChlbXB0eVBsYW4pIGVtcHR5UGxhbi5hZGRDbGFzcygnY2xhdWRlLWNvZGUtaGlkZGVuJyk7XG4gICAgICAgICAgICB0b2RvTGlzdC5hZGRDbGFzcygnY2xhdWRlLWNvZGUtaGlkZGVuJyk7XG5cbiAgICAgICAgICAgIC8vIEhpZGUgdGhlIGVudGlyZSBjb250YWluZXIgb25seSBpZiB0aGVyZSBhcmUgbm8gYWdlbnQgc3RlcHMgZWl0aGVyXG4gICAgICAgICAgICBjb25zdCBhZ2VudFN0ZXBzQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NsYXVkZS1jb2RlLWFnZW50LXN0ZXBzJyk7XG4gICAgICAgICAgICBpZiAoYWdlbnRTdGVwc0NvbnRhaW5lciAmJiBhZ2VudFN0ZXBzQ29udGFpbmVyLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGFnZW50Q29udGFpbmVyLnJlbW92ZUNsYXNzKCdpcy12aXNpYmxlJyk7XG4gICAgICAgICAgICAgICAgYWdlbnRDb250YWluZXIuYWRkQ2xhc3MoJ2lzLWhpZGRlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU2hvdyB0aGUgYWdlbnQgY29udGFpbmVyIGFuZCBwbGFuIGNvbHVtblxuICAgICAgICAgICAgYWdlbnRDb250YWluZXIucmVtb3ZlQ2xhc3MoJ2lzLWhpZGRlbicpO1xuICAgICAgICAgICAgYWdlbnRDb250YWluZXIuYWRkQ2xhc3MoJ2lzLXZpc2libGUnKTtcbiAgICAgICAgICAgIHBsYW5Db2x1bW4ucmVtb3ZlQ2xhc3MoJ2NsYXVkZS1jb2RlLWhpZGRlbicpO1xuICAgICAgICAgICAgcGxhbkNvbHVtbi5hZGRDbGFzcygnY2xhdWRlLWNvZGUtZmxleC12aXNpYmxlJyk7XG5cbiAgICAgICAgICAgIC8vIEhpZGUgZW1wdHkgbWVzc2FnZSBhbmQgc2hvdyB0b2Rvc1xuICAgICAgICAgICAgaWYgKGVtcHR5UGxhbikgZW1wdHlQbGFuLmFkZENsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgICAgIHRvZG9MaXN0LnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgICAgIHRvZG9MaXN0LmFkZENsYXNzKCdjbGF1ZGUtY29kZS1mbGV4LXZpc2libGUnKTtcblxuICAgICAgICAgICAgLy8gQWRkIGVhY2ggdG9kb1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b2RvIG9mIHRvZG9zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9kb0l0ZW0gPSB0b2RvTGlzdC5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdjbGF1ZGUtY29kZS10b2RvLWl0ZW0nIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gU3RhdHVzIGljb25cbiAgICAgICAgICAgICAgICBsZXQgaWNvbiA9ICdcdTIzRjMnO1xuICAgICAgICAgICAgICAgIGxldCBzdGF0dXNDbGFzcyA9ICdwZW5kaW5nJztcbiAgICAgICAgICAgICAgICBpZiAodG9kby5zdGF0dXMgPT09ICdpbl9wcm9ncmVzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbiA9ICdcdUQ4M0RcdUREMDQnO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNDbGFzcyA9ICdpbi1wcm9ncmVzcyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2RvLnN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbiA9ICdcdTI3MDUnO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNDbGFzcyA9ICdjb21wbGV0ZWQnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRvZG9JdGVtLmNyZWF0ZUVsKCdzcGFuJywge1xuICAgICAgICAgICAgICAgICAgICBjbHM6IGBjbGF1ZGUtY29kZS10b2RvLWljb24gJHtzdGF0dXNDbGFzc31gLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBpY29uXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBDb250ZW50XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IHRvZG8uc3RhdHVzID09PSAnaW5fcHJvZ3Jlc3MnID8gdG9kby5hY3RpdmVGb3JtIDogdG9kby5jb250ZW50O1xuICAgICAgICAgICAgICAgIHRvZG9JdGVtLmNyZWF0ZUVsKCdzcGFuJywge1xuICAgICAgICAgICAgICAgICAgICBjbHM6ICdjbGF1ZGUtY29kZS10b2RvLWNvbnRlbnQnLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgc2V0dGluZ3NcbiAgICAgKi9cbiAgICB1cGRhdGVTZXR0aW5ncygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hdXRvQWNjZXB0Q2hlY2tib3guY2hlY2tlZCA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmF1dG9BY2NlcHRDaGFuZ2VzO1xuICAgICAgICB0aGlzLm1vZGVsU2VsZWN0LnZhbHVlID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MubW9kZWxBbGlhcztcbiAgICB9XG5cbiAgICBhc3luYyBvbkNsb3NlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICAvLyBDbGVhbiB1cCBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgaWYgKHRoaXMucHJvbXB0SW5wdXRLZXlkb3duSGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5wcm9tcHRJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5wcm9tcHRJbnB1dEtleWRvd25IYW5kbGVyKTtcbiAgICAgICAgICAgIHRoaXMucHJvbXB0SW5wdXRLZXlkb3duSGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IHsgZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIgfSBvZiB0aGlzLmV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSBbXTtcblxuICAgICAgICAvLyBTYXZlIGFsbCBjb250ZXh0c1xuICAgICAgICBjb25zdCB2YXVsdFBhdGggPSAodGhpcy5hcHAudmF1bHQuYWRhcHRlciBhcyBGaWxlU3lzdGVtQWRhcHRlcikuZ2V0QmFzZVBhdGgoKTtcbiAgICAgICAgaWYgKHZhdWx0UGF0aCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRNYW5hZ2VyLnNhdmVBbGxDb250ZXh0cyh2YXVsdFBhdGgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSBjb250ZXh0cyBvbiBjbG9zZTonLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgQ2xhdWRlQ29kZVJlcXVlc3QsIENsYXVkZUNvZGVSZXNwb25zZSB9IGZyb20gJy4vY2xhdWRlLWNvZGUtcnVubmVyJztcbmltcG9ydCB7IENsYXVkZUNvZGVSdW5uZXIgfSBmcm9tICcuL2NsYXVkZS1jb2RlLXJ1bm5lcic7XG5cbmV4cG9ydCBjb25zdCBWSUVXX1RZUEVfQ0xBVURFX0NPREUgPSAnY2xhdWRlLWNvZGUtdmlldyc7XG5cbi8vIFRva2VuIHVzYWdlIHR5cGVcbmV4cG9ydCBpbnRlcmZhY2UgVG9rZW5Vc2FnZSB7XG4gICAgaW5wdXRUb2tlbnM/OiBudW1iZXI7XG4gICAgb3V0cHV0VG9rZW5zPzogbnVtYmVyO1xuICAgIHRvdGFsVG9rZW5zPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlc3Npb25IaXN0b3J5SXRlbSB7XG4gICAgcHJvbXB0OiBzdHJpbmc7XG4gICAgdGltZXN0YW1wOiBEYXRlO1xuICAgIHN1Y2Nlc3M6IGJvb2xlYW47XG4gICAgbm90ZVBhdGg6IHN0cmluZztcbiAgICByZXNwb25zZT86IENsYXVkZUNvZGVSZXNwb25zZTtcbiAgICByZXF1ZXN0PzogQ2xhdWRlQ29kZVJlcXVlc3Q7XG4gICAgb3V0cHV0TGluZXM/OiBzdHJpbmdbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBZ2VudFN0ZXAge1xuICAgIGljb246IHN0cmluZztcbiAgICBhY3Rpb246IHN0cmluZztcbiAgICB0YXJnZXQ6IHN0cmluZztcbiAgICBrZXk6IHN0cmluZztcbiAgICBzdGFydFRpbWU/OiBudW1iZXI7ICAvLyBUaW1lc3RhbXAgd2hlbiBzdGVwIHN0YXJ0ZWRcbiAgICBkdXJhdGlvbj86IG51bWJlcjsgICAvLyBEdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOb3RlQ29udGV4dCB7XG4gICAgaGlzdG9yeTogU2Vzc2lvbkhpc3RvcnlJdGVtW107XG4gICAgc2Vzc2lvbklkOiBzdHJpbmcgfCBudWxsO1xuICAgIGN1cnJlbnRSZXNwb25zZTogQ2xhdWRlQ29kZVJlc3BvbnNlIHwgbnVsbDtcbiAgICBjdXJyZW50UmVxdWVzdDogQ2xhdWRlQ29kZVJlcXVlc3QgfCBudWxsO1xuICAgIG91dHB1dExpbmVzOiBzdHJpbmdbXTtcbiAgICBhZ2VudFN0ZXBzOiBBZ2VudFN0ZXBbXTtcbiAgICBydW5uZXI6IENsYXVkZUNvZGVSdW5uZXI7XG4gICAgaXNSdW5uaW5nOiBib29sZWFuO1xuICAgIHJ1bkJ1dHRvbj86IEhUTUxCdXR0b25FbGVtZW50O1xuICAgIGNhbmNlbEJ1dHRvbj86IEhUTUxCdXR0b25FbGVtZW50O1xuICAgIHdhaXRpbmdGb3JSZXNwb25zZT86IGJvb2xlYW47XG4gICAgc2VsZWN0ZWRNb2RlbD86IHN0cmluZztcbiAgICBsYXN0UHJvbXB0Pzogc3RyaW5nO1xuICAgIC8vIFBlci1ub3RlIHByZXZpZXcvZGlmZiBzdGF0ZVxuICAgIHBlbmRpbmdQcmV2aWV3Q29udGVudD86IHN0cmluZzsgIC8vIE1vZGlmaWVkIGNvbnRlbnQgd2FpdGluZyBmb3IgYXBwcm92YWxcbiAgICBvcmlnaW5hbFByZXZpZXdDb250ZW50Pzogc3RyaW5nOyAvLyBPcmlnaW5hbCBjb250ZW50IGZvciBkaWZmIGRpc3BsYXlcbiAgICAvLyBQZXItbm90ZSBzdHJlYW1pbmcgcmVzdWx0IHN0YXRlIChmb3IgcmVzdG9yaW5nIHdoZW4gc3dpdGNoaW5nIG5vdGVzIG1pZC1zdHJlYW0pXG4gICAgY3VycmVudFJlc3VsdFRleHQ/OiBzdHJpbmc7ICAgICAgLy8gQWNjdW11bGF0ZWQgcmVzdWx0IHRleHQgKHN0cmVhbWluZyBvciBjb21wbGV0ZSlcbiAgICAvLyBQZXItbm90ZSBleGVjdXRpb24gdGltaW5nIChmb3IgaW5kZXBlbmRlbnQgdGltZXJzIHdoZW4gc3dpdGNoaW5nIG5vdGVzKVxuICAgIGV4ZWN1dGlvblN0YXJ0VGltZT86IG51bWJlcjsgICAgIC8vIFRpbWVzdGFtcCB3aGVuIGV4ZWN1dGlvbiBzdGFydGVkXG4gICAgYmFzZVN0YXR1c01lc3NhZ2U/OiBzdHJpbmc7ICAgICAgLy8gQmFzZSBtZXNzYWdlIGZvciBzdGF0dXMgdXBkYXRlcyAoZS5nLiwgXCJcdUQ4M0VcdUREMTQgUHJvY2Vzc2luZ1wiKVxufVxuIiwgIi8qKlxuICogRW5nbGlzaCB0cmFuc2xhdGlvbnMgKGRlZmF1bHQpXG4gKi9cbmV4cG9ydCBjb25zdCBlbiA9IHtcbiAgICAvLyBIZWFkZXJcbiAgICAnaGVhZGVyLnRpdGxlJzogJ0NsYXVkZSBDb2RlIGFzc2lzdGFudCcsXG4gICAgJ2hlYWRlci5ub05vdGVTZWxlY3RlZCc6ICdubyBub3RlIHNlbGVjdGVkJyxcblxuICAgIC8vIElucHV0IFNlY3Rpb25cbiAgICAnaW5wdXQubGFiZWwnOiAnWW91ciBpbnN0cnVjdGlvbnM6JyxcbiAgICAnaW5wdXQucGxhY2Vob2xkZXInOiAnZS5nLiwgXCJBZGQgbW9yZSBleGFtcGxlcyB0byB0aGlzIHNlY3Rpb25cIiBvciBcIlJlb3JnYW5pemUgd2l0aCBiZXR0ZXIgaGVhZGVyc1wiIChFbnRlciB0byBzZW5kLCBDdHJsK0VudGVyIGZvciBuZXcgbGluZSknLFxuICAgICdpbnB1dC5jb252ZXJzYXRpb25hbE1vZGUnOiAnY29udmVyc2F0aW9uYWwgbW9kZSAobm8gZmlsZSBlZGl0cyknLFxuICAgICdpbnB1dC5jb252ZXJzYXRpb25hbE1vZGVUb29sdGlwJzogJ0NoYXQgd2l0aCBDbGF1ZGUgd2l0aG91dCBtb2RpZnlpbmcgYW55IGZpbGVzJyxcbiAgICAnaW5wdXQuc2VsZWN0ZWRUZXh0T25seSc6ICdFZGl0IHNlbGVjdGVkIHRleHQgb25seScsXG4gICAgJ2lucHV0LmF1dG9BY2NlcHQnOiAnQXV0by1hY2NlcHQgY2hhbmdlcycsXG4gICAgJ2lucHV0Lm1vZGVsTGFiZWwnOiAnTW9kZWw6JyxcbiAgICAnaW5wdXQubW9kZWxEZWZhdWx0JzogJ0RlZmF1bHQnLFxuICAgICdpbnB1dC5ydW5CdXR0b24nOiAnUnVuIENsYXVkZSBDb2RlJyxcbiAgICAnaW5wdXQucnVubmluZ0J1dHRvbic6ICdSdW5uaW5nLi4uJyxcbiAgICAnaW5wdXQuY2FuY2VsQnV0dG9uJzogJ0NhbmNlbCcsXG5cbiAgICAvLyBSZXN1bHQgU2VjdGlvblxuICAgICdyZXN1bHQudGl0bGUnOiAnUmVzdWx0JyxcblxuICAgIC8vIE91dHB1dCBTZWN0aW9uXG4gICAgJ291dHB1dC50aXRsZSc6ICdPdXRwdXQnLFxuXG4gICAgLy8gUHJldmlldyBTZWN0aW9uXG4gICAgJ3ByZXZpZXcudGl0bGUnOiAnUHJldmlldycsXG4gICAgJ3ByZXZpZXcudGFiUmF3JzogJ1JhdycsXG4gICAgJ3ByZXZpZXcudGFiRGlmZic6ICdEaWZmJyxcbiAgICAncHJldmlldy50YWJSZW5kZXJlZCc6ICdSZW5kZXJlZCcsXG4gICAgJ3ByZXZpZXcub3JpZ2luYWxDaGFycyc6ICdPcmlnaW5hbDonLFxuICAgICdwcmV2aWV3Lm1vZGlmaWVkQ2hhcnMnOiAnTW9kaWZpZWQ6JyxcbiAgICAncHJldmlldy5jaGFycyc6ICdjaGFycycsXG4gICAgJ3ByZXZpZXcuYXBwbHlCdXR0b24nOiAnYXBwbHkgY2hhbmdlcycsXG4gICAgJ3ByZXZpZXcucmVqZWN0QnV0dG9uJzogJ3JlamVjdCcsXG5cbiAgICAvLyBIaXN0b3J5IFNlY3Rpb25cbiAgICAnaGlzdG9yeS50aXRsZSc6ICdIaXN0b3J5JyxcbiAgICAnaGlzdG9yeS5jbGVhckJ1dHRvbic6ICdDbGVhcicsXG5cbiAgICAvLyBBZ2VudCBTZWN0aW9uXG4gICAgJ2FnZW50LnBsYW5UaXRsZSc6ICdwbGFuJyxcbiAgICAnYWdlbnQuYWN0aXZpdHlUaXRsZSc6ICdBY3Rpdml0eScsXG4gICAgJ2FnZW50Lm5vUGxhbic6ICdObyBwbGFuIGNyZWF0ZWQgeWV0JyxcblxuICAgIC8vIFRvZG8gU3RhdHVzXG4gICAgJ3RvZG8ucGVuZGluZyc6ICdwZW5kaW5nJyxcbiAgICAndG9kby5pblByb2dyZXNzJzogJ2luIHByb2dyZXNzJyxcbiAgICAndG9kby5jb21wbGV0ZWQnOiAnY29tcGxldGVkJyxcblxuICAgIC8vIEludGVyYWN0aXZlIFByb21wdFxuICAgICdpbnRlcmFjdGl2ZS5oZWFkZXInOiAnQ2xhdWRlIGlzIGFza2luZyBmb3IgY29uZmlybWF0aW9uJyxcbiAgICAnaW50ZXJhY3RpdmUueWVzQnV0dG9uJzogJ3llcycsXG4gICAgJ2ludGVyYWN0aXZlLm5vQnV0dG9uJzogJ25vJyxcbiAgICAnaW50ZXJhY3RpdmUuY3VzdG9tUGxhY2Vob2xkZXInOiAnT3IgdHlwZSBhIGN1c3RvbSByZXNwb25zZS4uLicsXG5cbiAgICAvLyBQZXJtaXNzaW9uIEFwcHJvdmFsXG4gICAgJ3Blcm1pc3Npb24uaGVhZGVyJzogJ3Blcm1pc3Npb24gcmVxdWlyZWQnLFxuICAgICdwZXJtaXNzaW9uLm1lc3NhZ2UnOiAnQ2xhdWRlIGlzIHJlcXVlc3RpbmcgcGVybWlzc2lvbiB0byBleGVjdXRlIGFjdGlvbnMuJyxcbiAgICAncGVybWlzc2lvbi5hcHByb3ZlQnV0dG9uJzogJ2FwcHJvdmUgJiBjb250aW51ZScsXG4gICAgJ3Blcm1pc3Npb24uZGVueUJ1dHRvbic6ICdkZW55JyxcblxuICAgIC8vIFN0YXR1cyBNZXNzYWdlc1xuICAgICdzdGF0dXMucHJvY2Vzc2luZyc6ICdDbGF1ZGUgaXMgcHJvY2Vzc2luZycsXG4gICAgJ3N0YXR1cy5hdXRvQXBwbHlpbmcnOiAnQXV0by1hcHBseWluZyBjaGFuZ2VzLi4uJyxcbiAgICAnc3RhdHVzLnJ1bm5pbmdBdXRob3JpemVkJzogJ1J1bm5pbmcgYXV0aG9yaXplZCB0YXNrcycsXG4gICAgJ3N0YXR1cy5ydW5uaW5nSW5CYWNrZ3JvdW5kJzogJ1J1bm5pbmcgaW4gYmFja2dyb3VuZC4uLicsXG4gICAgJ3N0YXR1cy5mYWlsZWQnOiAnRmFpbGVkIC0gc2VlIGVycm9yIGJlbG93JyxcblxuICAgIC8vIE5vdGlmaWNhdGlvbnNcbiAgICAnbm90aWNlLmFscmVhZHlQcm9jZXNzaW5nJzogJ0FscmVhZHkgcHJvY2Vzc2luZyBhIHJlcXVlc3QuIFBsZWFzZSB3YWl0LicsXG4gICAgJ25vdGljZS5lbnRlclByb21wdCc6ICdQbGVhc2UgZW50ZXIgYSBwcm9tcHQnLFxuICAgICdub3RpY2Uubm9BY3RpdmVOb3RlJzogJ05vIGFjdGl2ZSBub3RlIGZvdW5kLCBwbGVhc2Ugb3BlbiBhIE1hcmtkb3duIG5vdGUgZmlyc3QnLFxuICAgICdub3RpY2Uubm9FZGl0b3InOiAnTm8gTWFya2Rvd24gZWRpdG9yIGZvdW5kLCBwbGVhc2UgbWFrZSBzdXJlIHlvdSBoYXZlIGEgbm90ZSBvcGVuJyxcbiAgICAnbm90aWNlLm5vVmF1bHRQYXRoJzogJ0NvdWxkIG5vdCBkZXRlcm1pbmUgdmF1bHQgcGF0aCcsXG4gICAgJ25vdGljZS5jb21wbGV0ZWQnOiAnQ2xhdWRlIENvZGUgY29tcGxldGVkJyxcbiAgICAnbm90aWNlLmNvbXBsZXRlZE5vQ2hhbmdlcyc6ICdDbGF1ZGUgQ29kZSBjb21wbGV0ZWQgKG5vIGZpbGUgY2hhbmdlcyknLFxuICAgICdub3RpY2UuY2hhbmdlc0FwcGxpZWQnOiAnY2hhbmdlcyBhcHBsaWVkIGF1dG9tYXRpY2FsbHknLFxuICAgICdub3RpY2UuY2hhbmdlc0FwcGxpZWRTdWNjZXNzJzogJ2NoYW5nZXMgYXBwbGllZCBzdWNjZXNzZnVsbHknLFxuICAgICdub3RpY2UuZmFpbGVkQXBwbHlDaGFuZ2VzJzogJ2ZhaWxlZCB0byBhcHBseSBjaGFuZ2VzJyxcbiAgICAnbm90aWNlLmNoYW5nZXNSZWplY3RlZCc6ICdDaGFuZ2VzIHJlamVjdGVkJyxcbiAgICAnbm90aWNlLmNhbmNlbGxlZCc6ICdDYW5jZWxsZWQnLFxuICAgICdub3RpY2UucGVybWlzc2lvblJlcXVlc3QnOiAnQ2xhdWRlIGlzIHJlcXVlc3RpbmcgcGVybWlzc2lvbiAtIHBsZWFzZSBhcHByb3ZlIG9yIGRlbnknLFxuICAgICdub3RpY2UucGVybWlzc2lvbkRlbmllZCc6ICdQZXJtaXNzaW9uIGRlbmllZCAtIENsYXVkZSB3aWxsIG5vdCBwcm9jZWVkJyxcbiAgICAnbm90aWNlLm5vQ2hhbmdlc1RvQXBwbHknOiAnbm8gY2hhbmdlcyB0byBhcHBseScsXG4gICAgJ25vdGljZS5ub0FjdGl2ZUZpbGUnOiAnbm8gYWN0aXZlIGZpbGUnLFxuICAgICdub3RpY2UuaGlzdG9yeVJlc3RvcmVkJzogJ0hpc3RvcnkgaXRlbSByZXN0b3JlZCcsXG4gICAgJ25vdGljZS5oaXN0b3J5UmVzdG9yZWRXaXRoQ2hhbmdlcyc6ICdIaXN0b3J5IGl0ZW0gcmVzdG9yZWQgd2l0aCBwcm9wb3NlZCBjaGFuZ2VzJyxcbiAgICAnbm90aWNlLmhpc3RvcnlDbGVhcmVkJzogJ0hpc3RvcnkgY2xlYXJlZCcsXG5cbiAgICAvLyBEaWZmIFZpZXdcbiAgICAnZGlmZi5vcmlnaW5hbCc6ICdPcmlnaW5hbCcsXG4gICAgJ2RpZmYubW9kaWZpZWQnOiAnTW9kaWZpZWQnLFxuXG4gICAgLy8gUmVzdWx0IFJlbmRlcmVyXG4gICAgJ3Jlc3VsdC5kaXJlY3RBbnN3ZXInOiAnRGlyZWN0IGFuc3dlcicsXG4gICAgJ3Jlc3VsdC5hZGRpdGlvbmFsQ29udGV4dCc6ICdBZGRpdGlvbmFsIENvbnRleHQnLFxuICAgICdyZXN1bHQudG9rZW5zJzogJ3Rva2VucycsXG4gICAgJ3Jlc3VsdC50b2tlbnNJbic6ICdpbicsXG4gICAgJ3Jlc3VsdC50b2tlbnNPdXQnOiAnb3V0JyxcblxuICAgIC8vIFByZXZpZXcgU3RhdHNcbiAgICAncHJldmlldy5vcmlnaW5hbExhYmVsJzogJ09yaWdpbmFsOicsXG4gICAgJ3ByZXZpZXcubW9kaWZpZWRMYWJlbCc6ICdNb2RpZmllZDonLFxuICAgICdwcmV2aWV3LmNoYXJzTGFiZWwnOiAnY2hhcnMnLFxuXG4gICAgLy8gTWlzY1xuICAgICdtaXNjLm5vUGVuZGluZ1JlcXVlc3QnOiAnTm8gcGVuZGluZyByZXF1ZXN0IGZvdW5kJyxcbiAgICAnbWlzYy5sYW5ndWFnZUNoYW5nZWQnOiAnTGFuZ3VhZ2UgY2hhbmdlZC4gU29tZSBVSSBlbGVtZW50cyB3aWxsIHVwZGF0ZSBvbiByZWxvYWQuJyxcbiAgICAnbWlzYy50ZXN0RmFpbGVkJzogJ0NsYXVkZSBDb2RlIHRlc3QgZmFpbGVkJyxcblxuICAgIC8vIFNldHRpbmdzXG4gICAgJ3NldHRpbmdzLmF1dG9EZXRlY3RQYXRoJzogJ0F1dG8tZGV0ZWN0IENsYXVkZSBDb2RlIHBhdGgnLFxuICAgICdzZXR0aW5ncy5hdXRvRGV0ZWN0UGF0aERlc2MnOiAnQXV0b21hdGljYWxseSBkZXRlY3QgdGhlIENsYXVkZSBDb2RlIGV4ZWN1dGFibGUgbG9jYXRpb24nLFxuICAgICdzZXR0aW5ncy5leGVjdXRhYmxlUGF0aCc6ICdDbGF1ZGUgQ29kZSBleGVjdXRhYmxlIHBhdGgnLFxuICAgICdzZXR0aW5ncy5leGVjdXRhYmxlUGF0aERlc2MnOiAnRnVsbCBwYXRoIHRvIHRoZSBDbGF1ZGUgQ29kZSBleGVjdXRhYmxlIChlLmcuLCAvdXNyL2xvY2FsL2Jpbi9jbGF1ZGUpJyxcbiAgICAnc2V0dGluZ3MudGVzdEluc3RhbGxhdGlvbic6ICdUZXN0IENsYXVkZSBDb2RlIGluc3RhbGxhdGlvbicsXG4gICAgJ3NldHRpbmdzLnRlc3RJbnN0YWxsYXRpb25EZXNjJzogJ1ZlcmlmeSB0aGF0IENsYXVkZSBDb2RlIGlzIGFjY2Vzc2libGUgYW5kIHdvcmtpbmcnLFxuICAgICdzZXR0aW5ncy50ZXN0QnV0dG9uJzogJ1Rlc3QnLFxuICAgICdzZXR0aW5ncy50ZXN0V29ya2luZyc6ICd3b3JraW5nIScsXG4gICAgJ3NldHRpbmdzLnRlc3RGYWlsZWQnOiAnZmFpbGVkJyxcbiAgICAnc2V0dGluZ3MuY3VzdG9tUHJvbXB0JzogJ0N1c3RvbSBzeXN0ZW0gcHJvbXB0JyxcbiAgICAnc2V0dGluZ3MuY3VzdG9tUHJvbXB0RGVzYyc6ICdPcHRpb25hbCBjdXN0b20gc3lzdGVtIHByb21wdCB0byBwcmVwZW5kIHRvIGFsbCByZXF1ZXN0cycsXG4gICAgJ3NldHRpbmdzLmN1c3RvbVByb21wdFBsYWNlaG9sZGVyJzogJ1lvdSBhcmUgaGVscGluZyBlZGl0IG1hcmtkb3duIG5vdGVzLi4uJyxcbiAgICAnc2V0dGluZ3MucHJlc2VydmVDdXJzb3InOiAnUHJlc2VydmUgY3Vyc29yIHBvc2l0aW9uJyxcbiAgICAnc2V0dGluZ3MucHJlc2VydmVDdXJzb3JEZXNjJzogJ1RyeSB0byBtYWludGFpbiBjdXJzb3IgcG9zaXRpb24gYWZ0ZXIgYXBwbHlpbmcgY2hhbmdlcycsXG4gICAgJ3NldHRpbmdzLmF1dG9BY2NlcHRDaGFuZ2VzJzogJ0F1dG8tYWNjZXB0IGNoYW5nZXMnLFxuICAgICdzZXR0aW5ncy5hdXRvQWNjZXB0Q2hhbmdlc0Rlc2MnOiAnQXV0b21hdGljYWxseSBhcHBseSBjaGFuZ2VzIHdpdGhvdXQgc2hvd2luZyBwcmV2aWV3ICh1c2Ugd2l0aCBjYXV0aW9uISknLFxuICAgICdzZXR0aW5ncy5tb2RlbCc6ICdNb2RlbCcsXG4gICAgJ3NldHRpbmdzLm1vZGVsRGVzYyc6ICdTZWxlY3QgdGhlIENsYXVkZSBtb2RlbCB0byB1c2U6IFNvbm5ldCAoYmFsYW5jZWQpLCBPcHVzIChtb3N0IGNhcGFibGUpLCBvciBIYWlrdSAoZmFzdGVzdCkuIExlYXZlIGVtcHR5IHRvIHVzZSB0aGUgZGVmYXVsdCBzdWJhZ2VudCBtb2RlbC4nLFxuICAgICdzZXR0aW5ncy5tb2RlbERlZmF1bHQnOiAnRGVmYXVsdCAoc3ViYWdlbnQgbW9kZWwpJyxcbiAgICAnc2V0dGluZ3MubW9kZWxTb25uZXQnOiAnU29ubmV0IChiYWxhbmNlZCknLFxuICAgICdzZXR0aW5ncy5tb2RlbE9wdXMnOiAnT3B1cyAobW9zdCBjYXBhYmxlKScsXG4gICAgJ3NldHRpbmdzLm1vZGVsSGFpa3UnOiAnSGFpa3UgKGZhc3Rlc3QpJyxcbiAgICAnc2V0dGluZ3MudmF1bHRBY2Nlc3MnOiAnQWxsb3cgdmF1bHQtd2lkZSBhY2Nlc3MnLFxuICAgICdzZXR0aW5ncy52YXVsdEFjY2Vzc0Rlc2MnOiAnQWxsb3cgQ2xhdWRlIHRvIHJlYWQvc2VhcmNoIG90aGVyIGZpbGVzIGluIHlvdXIgdmF1bHQgKG5vdCBqdXN0IHRoZSBjdXJyZW50IG5vdGUpJyxcbiAgICAnc2V0dGluZ3MucGVybWlzc2lvbmxlc3NNb2RlJzogJ0VuYWJsZSBwZXJtaXNzaW9ubGVzcyBtb2RlJyxcbiAgICAnc2V0dGluZ3MucGVybWlzc2lvbmxlc3NNb2RlRGVzYyc6ICdBbGxvdyBDbGF1ZGUgdG8gZXhlY3V0ZSBhY3Rpb25zIHdpdGhvdXQgYXNraW5nIGZvciBwZXJtaXNzaW9uIGVhY2ggdGltZSAodXNlIHdpdGggY2F1dGlvbiEgQ2xhdWRlIHdpbGwgaGF2ZSBmdWxsIGNvbnRyb2wpJyxcbiAgICAnc2V0dGluZ3MudGltZW91dCc6ICdUaW1lb3V0IChzZWNvbmRzKScsXG4gICAgJ3NldHRpbmdzLnRpbWVvdXREZXNjJzogJ01heGltdW0gdGltZSB0byB3YWl0IGZvciBDbGF1ZGUgQ29kZSByZXNwb25zZSAoMCA9IG5vIHRpbWVvdXQpJyxcbiAgICAnc2V0dGluZ3MuY3VzdG9tQXBpQ29uZmlnJzogJ0N1c3RvbSBBUEkgY29uZmlndXJhdGlvbicsXG4gICAgJ3NldHRpbmdzLmN1c3RvbUFwaUNvbmZpZ0Rlc2MnOiAnQ29uZmlndXJlIGN1c3RvbSBBUEkgZW5kcG9pbnRzIGZvciByZWdpb25zIHdoZXJlIENsYXVkZSBpcyBub3QgZGlyZWN0bHkgYXZhaWxhYmxlLiBMZWF2ZSBlbXB0eSB0byB1c2UgZGVmYXVsdCBzZXR0aW5ncy4nLFxuICAgICdzZXR0aW5ncy5hcGlCYXNlVXJsJzogJ0FQSSBiYXNlIFVSTCcsXG4gICAgJ3NldHRpbmdzLmFwaUJhc2VVcmxEZXNjJzogJ0N1c3RvbSBBUEkgZW5kcG9pbnQgVVJMIChlLmcuLCBodHRwczovL2FwaS5raW1pLmNvbS9jb2RpbmcvKScsXG4gICAgJ3NldHRpbmdzLmFwaUF1dGhUb2tlbic6ICdBUEkgYXV0aCB0b2tlbicsXG4gICAgJ3NldHRpbmdzLmFwaUF1dGhUb2tlbkRlc2MnOiAnQ3VzdG9tIGF1dGhlbnRpY2F0aW9uIHRva2VuIGZvciB0aGUgQVBJIGVuZHBvaW50JyxcbiAgICAnc2V0dGluZ3MuYXBpQXV0aFRva2VuUGxhY2Vob2xkZXInOiAnRW50ZXIgeW91ciBBUEkgdG9rZW4nLFxuICAgICdzZXR0aW5ncy5jdXN0b21Nb2RlbCc6ICdDdXN0b20gbW9kZWwnLFxuICAgICdzZXR0aW5ncy5jdXN0b21Nb2RlbERlc2MnOiAnQ3VzdG9tIG1vZGVsIG5hbWUgdG8gdXNlIChlLmcuLCBraW1pLWZvci1jb2RpbmcpLiBPdmVycmlkZXMgdGhlIG1vZGVsIGRyb3Bkb3duIGFib3ZlLicsXG4gICAgJ3NldHRpbmdzLmN1c3RvbVNtYWxsTW9kZWwnOiAnQ3VzdG9tIHNtYWxsL2Zhc3QgbW9kZWwnLFxuICAgICdzZXR0aW5ncy5jdXN0b21TbWFsbE1vZGVsRGVzYyc6ICdDdXN0b20gbW9kZWwgbmFtZSBmb3IgZmFzdCBvcGVyYXRpb25zIChlLmcuLCBraW1pLWZvci1jb2RpbmcpJyxcbiAgICAnc2V0dGluZ3MubGFuZ3VhZ2UnOiAnTGFuZ3VhZ2UnLFxuICAgICdzZXR0aW5ncy5sYW5ndWFnZURlc2MnOiAnU2VsZWN0IGludGVyZmFjZSBsYW5ndWFnZScsXG59O1xuXG5leHBvcnQgdHlwZSBUcmFuc2xhdGlvbktleSA9IGtleW9mIHR5cGVvZiBlbjtcbiIsICIvKipcbiAqIENoaW5lc2UgKFNpbXBsaWZpZWQpIHRyYW5zbGF0aW9uc1xuICovXG5leHBvcnQgY29uc3QgemggPSB7XG4gICAgLy8gSGVhZGVyXG4gICAgJ2hlYWRlci50aXRsZSc6ICdDbGF1ZGUgQ29kZSBcdTUyQTlcdTYyNEInLFxuICAgICdoZWFkZXIubm9Ob3RlU2VsZWN0ZWQnOiAnXHU2NzJBXHU5MDA5XHU2MkU5XHU3QjE0XHU4QkIwJyxcblxuICAgIC8vIElucHV0IFNlY3Rpb25cbiAgICAnaW5wdXQubGFiZWwnOiAnXHU4RjkzXHU1MTY1XHU2MzA3XHU0RUU0XHVGRjFBJyxcbiAgICAnaW5wdXQucGxhY2Vob2xkZXInOiAnXHU0RjhCXHU1OTgyXHVGRjFBXCJcdTRFM0FcdThGRDlcdTRFMkFcdTkwRThcdTUyMDZcdTZERkJcdTUyQTBcdTY2RjRcdTU5MUFcdTc5M0FcdTRGOEJcIiBcdTYyMTYgXCJcdTc1MjhcdTY2RjRcdTU5N0RcdTc2ODRcdTY4MDdcdTk4OThcdTkxQ0RcdTY1QjBcdTdFQzRcdTdFQzdcIlx1RkYwOFx1NTZERVx1OEY2Nlx1NTNEMVx1OTAwMVx1RkYwQ0N0cmwrXHU1NkRFXHU4RjY2XHU2MzYyXHU4ODRDXHVGRjA5JyxcbiAgICAnaW5wdXQuY29udmVyc2F0aW9uYWxNb2RlJzogJ1x1NUJGOVx1OEJERFx1NkEyMVx1NUYwRlx1RkYwOFx1NEUwRFx1NEZFRVx1NjUzOVx1NjU4N1x1NEVGNlx1RkYwOScsXG4gICAgJ2lucHV0LmNvbnZlcnNhdGlvbmFsTW9kZVRvb2x0aXAnOiAnXHU0RTBFIENsYXVkZSBcdTVCRjlcdThCRERcdTRGNDZcdTRFMERcdTRGRUVcdTY1MzlcdTRFRkJcdTRGNTVcdTY1ODdcdTRFRjYnLFxuICAgICdpbnB1dC5zZWxlY3RlZFRleHRPbmx5JzogJ1x1NEVDNVx1N0YxNlx1OEY5MVx1OTAwOVx1NEUyRFx1NjU4N1x1NjcyQycsXG4gICAgJ2lucHV0LmF1dG9BY2NlcHQnOiAnXHU4MUVBXHU1MkE4XHU1RTk0XHU3NTI4XHU2NkY0XHU2NTM5JyxcbiAgICAnaW5wdXQubW9kZWxMYWJlbCc6ICdcdTZBMjFcdTU3OEJcdUZGMUEnLFxuICAgICdpbnB1dC5tb2RlbERlZmF1bHQnOiAnXHU5RUQ4XHU4QkE0JyxcbiAgICAnaW5wdXQucnVuQnV0dG9uJzogJ1x1OEZEMFx1ODg0QyBDbGF1ZGUgQ29kZScsXG4gICAgJ2lucHV0LnJ1bm5pbmdCdXR0b24nOiAnXHU4RkQwXHU4ODRDXHU0RTJELi4uJyxcbiAgICAnaW5wdXQuY2FuY2VsQnV0dG9uJzogJ1x1NTNENlx1NkQ4OCcsXG5cbiAgICAvLyBSZXN1bHQgU2VjdGlvblxuICAgICdyZXN1bHQudGl0bGUnOiAnXHU3RUQzXHU2NzlDJyxcblxuICAgIC8vIE91dHB1dCBTZWN0aW9uXG4gICAgJ291dHB1dC50aXRsZSc6ICdcdThGOTNcdTUxRkEnLFxuXG4gICAgLy8gUHJldmlldyBTZWN0aW9uXG4gICAgJ3ByZXZpZXcudGl0bGUnOiAnXHU5ODg0XHU4OUM4JyxcbiAgICAncHJldmlldy50YWJSYXcnOiAnXHU1MzlGXHU1OUNCJyxcbiAgICAncHJldmlldy50YWJEaWZmJzogJ1x1NURFRVx1NUYwMicsXG4gICAgJ3ByZXZpZXcudGFiUmVuZGVyZWQnOiAnXHU2RTMyXHU2N0QzJyxcbiAgICAncHJldmlldy5vcmlnaW5hbENoYXJzJzogJ1x1NTM5Rlx1NTlDQlx1RkYxQScsXG4gICAgJ3ByZXZpZXcubW9kaWZpZWRDaGFycyc6ICdcdTRGRUVcdTY1MzlcdTU0MEVcdUZGMUEnLFxuICAgICdwcmV2aWV3LmNoYXJzJzogJ1x1NUI1N1x1N0IyNicsXG4gICAgJ3ByZXZpZXcuYXBwbHlCdXR0b24nOiAnXHU1RTk0XHU3NTI4XHU2NkY0XHU2NTM5JyxcbiAgICAncHJldmlldy5yZWplY3RCdXR0b24nOiAnXHU2MkQyXHU3RUREJyxcblxuICAgIC8vIEhpc3RvcnkgU2VjdGlvblxuICAgICdoaXN0b3J5LnRpdGxlJzogJ1x1NTM4Nlx1NTNGMlx1OEJCMFx1NUY1NScsXG4gICAgJ2hpc3RvcnkuY2xlYXJCdXR0b24nOiAnXHU2RTA1XHU5NjY0JyxcblxuICAgIC8vIEFnZW50IFNlY3Rpb25cbiAgICAnYWdlbnQucGxhblRpdGxlJzogJ1x1OEJBMVx1NTIxMicsXG4gICAgJ2FnZW50LmFjdGl2aXR5VGl0bGUnOiAnXHU2RDNCXHU1MkE4JyxcbiAgICAnYWdlbnQubm9QbGFuJzogJ1x1NUMxQVx1NjcyQVx1NTIxQlx1NUVGQVx1OEJBMVx1NTIxMicsXG5cbiAgICAvLyBUb2RvIFN0YXR1c1xuICAgICd0b2RvLnBlbmRpbmcnOiAnXHU1Rjg1XHU1OTA0XHU3NDA2JyxcbiAgICAndG9kby5pblByb2dyZXNzJzogJ1x1OEZEQlx1ODg0Q1x1NEUyRCcsXG4gICAgJ3RvZG8uY29tcGxldGVkJzogJ1x1NURGMlx1NUI4Q1x1NjIxMCcsXG5cbiAgICAvLyBJbnRlcmFjdGl2ZSBQcm9tcHRcbiAgICAnaW50ZXJhY3RpdmUuaGVhZGVyJzogJ0NsYXVkZSBcdTZCNjNcdTU3MjhcdThCRjdcdTZDNDJcdTc4NkVcdThCQTQnLFxuICAgICdpbnRlcmFjdGl2ZS55ZXNCdXR0b24nOiAnXHU2NjJGJyxcbiAgICAnaW50ZXJhY3RpdmUubm9CdXR0b24nOiAnXHU1NDI2JyxcbiAgICAnaW50ZXJhY3RpdmUuY3VzdG9tUGxhY2Vob2xkZXInOiAnXHU2MjE2XHU4RjkzXHU1MTY1XHU4MUVBXHU1QjlBXHU0RTQ5XHU1NkRFXHU1OTBELi4uJyxcblxuICAgIC8vIFBlcm1pc3Npb24gQXBwcm92YWxcbiAgICAncGVybWlzc2lvbi5oZWFkZXInOiAnXHU5NzAwXHU4OTgxXHU2NzQzXHU5NjUwJyxcbiAgICAncGVybWlzc2lvbi5tZXNzYWdlJzogJ0NsYXVkZSBcdTZCNjNcdTU3MjhcdThCRjdcdTZDNDJcdTYyNjdcdTg4NENcdTY0Q0RcdTRGNUNcdTc2ODRcdTY3NDNcdTk2NTBcdTMwMDInLFxuICAgICdwZXJtaXNzaW9uLmFwcHJvdmVCdXR0b24nOiAnXHU2Mjc5XHU1MUM2XHU1RTc2XHU3RUU3XHU3RUVEJyxcbiAgICAncGVybWlzc2lvbi5kZW55QnV0dG9uJzogJ1x1NjJEMlx1N0VERCcsXG5cbiAgICAvLyBTdGF0dXMgTWVzc2FnZXNcbiAgICAnc3RhdHVzLnByb2Nlc3NpbmcnOiAnQ2xhdWRlIFx1NkI2M1x1NTcyOFx1NTkwNFx1NzQwNicsXG4gICAgJ3N0YXR1cy5hdXRvQXBwbHlpbmcnOiAnXHU2QjYzXHU1NzI4XHU4MUVBXHU1MkE4XHU1RTk0XHU3NTI4XHU2NkY0XHU2NTM5Li4uJyxcbiAgICAnc3RhdHVzLnJ1bm5pbmdBdXRob3JpemVkJzogJ1x1NkI2M1x1NTcyOFx1NjI2N1x1ODg0Q1x1NjM4OFx1Njc0M1x1NEVGQlx1NTJBMScsXG4gICAgJ3N0YXR1cy5ydW5uaW5nSW5CYWNrZ3JvdW5kJzogJ1x1NTQwRVx1NTNGMFx1OEZEMFx1ODg0Q1x1NEUyRC4uLicsXG4gICAgJ3N0YXR1cy5mYWlsZWQnOiAnXHU1OTMxXHU4RDI1IC0gXHU4QkY3XHU2N0U1XHU3NzBCXHU0RTBCXHU2NUI5XHU5NTE5XHU4QkVGXHU0RkUxXHU2MDZGJyxcblxuICAgIC8vIE5vdGlmaWNhdGlvbnNcbiAgICAnbm90aWNlLmFscmVhZHlQcm9jZXNzaW5nJzogJ1x1NkI2M1x1NTcyOFx1NTkwNFx1NzQwNlx1OEJGN1x1NkM0Mlx1RkYwQ1x1OEJGN1x1N0EwRFx1NTAxOVx1MzAwMicsXG4gICAgJ25vdGljZS5lbnRlclByb21wdCc6ICdcdThCRjdcdThGOTNcdTUxNjVcdTYzMDdcdTRFRTQnLFxuICAgICdub3RpY2Uubm9BY3RpdmVOb3RlJzogJ1x1NjcyQVx1NjI3RVx1NTIzMFx1NkQzQlx1NTJBOFx1N0IxNFx1OEJCMFx1RkYwQ1x1OEJGN1x1NTE0OFx1NjI1M1x1NUYwMFx1NEUwMFx1NEUyQSBNYXJrZG93biBcdTdCMTRcdThCQjAnLFxuICAgICdub3RpY2Uubm9FZGl0b3InOiAnXHU2NzJBXHU2MjdFXHU1MjMwIE1hcmtkb3duIFx1N0YxNlx1OEY5MVx1NTY2OFx1RkYwQ1x1OEJGN1x1Nzg2RVx1NEZERFx1NURGMlx1NjI1M1x1NUYwMFx1N0IxNFx1OEJCMCcsXG4gICAgJ25vdGljZS5ub1ZhdWx0UGF0aCc6ICdcdTY1RTBcdTZDRDVcdTc4NkVcdTVCOUFcdTRFRDNcdTVFOTNcdThERUZcdTVGODQnLFxuICAgICdub3RpY2UuY29tcGxldGVkJzogJ0NsYXVkZSBDb2RlIFx1NURGMlx1NUI4Q1x1NjIxMCcsXG4gICAgJ25vdGljZS5jb21wbGV0ZWROb0NoYW5nZXMnOiAnQ2xhdWRlIENvZGUgXHU1REYyXHU1QjhDXHU2MjEwXHVGRjA4XHU2NUUwXHU2NTg3XHU0RUY2XHU2NkY0XHU2NTM5XHVGRjA5JyxcbiAgICAnbm90aWNlLmNoYW5nZXNBcHBsaWVkJzogJ1x1NjZGNFx1NjUzOVx1NURGMlx1ODFFQVx1NTJBOFx1NUU5NFx1NzUyOCcsXG4gICAgJ25vdGljZS5jaGFuZ2VzQXBwbGllZFN1Y2Nlc3MnOiAnXHU2NkY0XHU2NTM5XHU1REYyXHU2MjEwXHU1MjlGXHU1RTk0XHU3NTI4JyxcbiAgICAnbm90aWNlLmZhaWxlZEFwcGx5Q2hhbmdlcyc6ICdcdTVFOTRcdTc1MjhcdTY2RjRcdTY1MzlcdTU5MzFcdThEMjUnLFxuICAgICdub3RpY2UuY2hhbmdlc1JlamVjdGVkJzogJ1x1NjZGNFx1NjUzOVx1NURGMlx1NjJEMlx1N0VERCcsXG4gICAgJ25vdGljZS5jYW5jZWxsZWQnOiAnXHU1REYyXHU1M0Q2XHU2RDg4JyxcbiAgICAnbm90aWNlLnBlcm1pc3Npb25SZXF1ZXN0JzogJ0NsYXVkZSBcdTZCNjNcdTU3MjhcdThCRjdcdTZDNDJcdTY3NDNcdTk2NTAgLSBcdThCRjdcdTYyNzlcdTUxQzZcdTYyMTZcdTYyRDJcdTdFREQnLFxuICAgICdub3RpY2UucGVybWlzc2lvbkRlbmllZCc6ICdcdTY3NDNcdTk2NTBcdTg4QUJcdTYyRDJcdTdFREQgLSBDbGF1ZGUgXHU1QzA2XHU0RTBEXHU0RjFBXHU3RUU3XHU3RUVEJyxcbiAgICAnbm90aWNlLm5vQ2hhbmdlc1RvQXBwbHknOiAnXHU2Q0ExXHU2NzA5XHU1M0VGXHU1RTk0XHU3NTI4XHU3Njg0XHU2NkY0XHU2NTM5JyxcbiAgICAnbm90aWNlLm5vQWN0aXZlRmlsZSc6ICdcdTZDQTFcdTY3MDlcdTZEM0JcdTUyQThcdTY1ODdcdTRFRjYnLFxuICAgICdub3RpY2UuaGlzdG9yeVJlc3RvcmVkJzogJ1x1NTM4Nlx1NTNGMlx1OEJCMFx1NUY1NVx1OTg3OVx1NURGMlx1NjA2Mlx1NTkwRCcsXG4gICAgJ25vdGljZS5oaXN0b3J5UmVzdG9yZWRXaXRoQ2hhbmdlcyc6ICdcdTUzODZcdTUzRjJcdThCQjBcdTVGNTVcdTk4NzlcdTVERjJcdTYwNjJcdTU5MERcdUZGMDhcdTUzMDVcdTU0MkJcdTVFRkFcdThCQUVcdTc2ODRcdTY2RjRcdTY1MzlcdUZGMDknLFxuICAgICdub3RpY2UuaGlzdG9yeUNsZWFyZWQnOiAnXHU1Mzg2XHU1M0YyXHU4QkIwXHU1RjU1XHU1REYyXHU2RTA1XHU5NjY0JyxcblxuICAgIC8vIERpZmYgVmlld1xuICAgICdkaWZmLm9yaWdpbmFsJzogJ1x1NTM5Rlx1NTlDQicsXG4gICAgJ2RpZmYubW9kaWZpZWQnOiAnXHU0RkVFXHU2NTM5XHU1NDBFJyxcblxuICAgIC8vIFJlc3VsdCBSZW5kZXJlclxuICAgICdyZXN1bHQuZGlyZWN0QW5zd2VyJzogJ1x1NzZGNFx1NjNBNVx1NTZERVx1N0I1NCcsXG4gICAgJ3Jlc3VsdC5hZGRpdGlvbmFsQ29udGV4dCc6ICdcdTk2NDRcdTUyQTBcdTUxODVcdTVCQjknLFxuICAgICdyZXN1bHQudG9rZW5zJzogJ1x1NEVFNFx1NzI0QycsXG4gICAgJ3Jlc3VsdC50b2tlbnNJbic6ICdcdThGOTNcdTUxNjUnLFxuICAgICdyZXN1bHQudG9rZW5zT3V0JzogJ1x1OEY5M1x1NTFGQScsXG5cbiAgICAvLyBQcmV2aWV3IFN0YXRzXG4gICAgJ3ByZXZpZXcub3JpZ2luYWxMYWJlbCc6ICdcdTUzOUZcdTU5Q0JcdUZGMUEnLFxuICAgICdwcmV2aWV3Lm1vZGlmaWVkTGFiZWwnOiAnXHU0RkVFXHU2NTM5XHU1NDBFXHVGRjFBJyxcbiAgICAncHJldmlldy5jaGFyc0xhYmVsJzogJ1x1NUI1N1x1N0IyNicsXG5cbiAgICAvLyBNaXNjXG4gICAgJ21pc2Mubm9QZW5kaW5nUmVxdWVzdCc6ICdcdTY3MkFcdTYyN0VcdTUyMzBcdTVGODVcdTU5MDRcdTc0MDZcdTc2ODRcdThCRjdcdTZDNDInLFxuICAgICdtaXNjLmxhbmd1YWdlQ2hhbmdlZCc6ICdcdThCRURcdThBMDBcdTVERjJcdTY2RjRcdTY1MzlcdTMwMDJcdTkwRThcdTUyMDZcdTc1NENcdTk3NjJcdTUxNDNcdTdEMjBcdTVDMDZcdTU3MjhcdTkxQ0RcdTY1QjBcdTUyQTBcdThGN0RcdTU0MEVcdTY2RjRcdTY1QjBcdTMwMDInLFxuICAgICdtaXNjLnRlc3RGYWlsZWQnOiAnQ2xhdWRlIENvZGUgXHU2RDRCXHU4QkQ1XHU1OTMxXHU4RDI1JyxcblxuICAgIC8vIFNldHRpbmdzXG4gICAgJ3NldHRpbmdzLmF1dG9EZXRlY3RQYXRoJzogJ1x1ODFFQVx1NTJBOFx1NjhDMFx1NkQ0QiBDbGF1ZGUgQ29kZSBcdThERUZcdTVGODQnLFxuICAgICdzZXR0aW5ncy5hdXRvRGV0ZWN0UGF0aERlc2MnOiAnXHU4MUVBXHU1MkE4XHU2OEMwXHU2RDRCIENsYXVkZSBDb2RlIFx1NTNFRlx1NjI2N1x1ODg0Q1x1NjU4N1x1NEVGNlx1NzY4NFx1NEY0RFx1N0Y2RScsXG4gICAgJ3NldHRpbmdzLmV4ZWN1dGFibGVQYXRoJzogJ0NsYXVkZSBDb2RlIFx1NTNFRlx1NjI2N1x1ODg0Q1x1NjU4N1x1NEVGNlx1OERFRlx1NUY4NCcsXG4gICAgJ3NldHRpbmdzLmV4ZWN1dGFibGVQYXRoRGVzYyc6ICdDbGF1ZGUgQ29kZSBcdTUzRUZcdTYyNjdcdTg4NENcdTY1ODdcdTRFRjZcdTc2ODRcdTVCOENcdTY1NzRcdThERUZcdTVGODRcdUZGMDhcdTRGOEJcdTU5ODJcdUZGMUEvdXNyL2xvY2FsL2Jpbi9jbGF1ZGVcdUZGMDknLFxuICAgICdzZXR0aW5ncy50ZXN0SW5zdGFsbGF0aW9uJzogJ1x1NkQ0Qlx1OEJENSBDbGF1ZGUgQ29kZSBcdTVCODlcdTg4QzUnLFxuICAgICdzZXR0aW5ncy50ZXN0SW5zdGFsbGF0aW9uRGVzYyc6ICdcdTlBOENcdThCQzEgQ2xhdWRlIENvZGUgXHU2NjJGXHU1NDI2XHU1M0VGXHU4QkJGXHU5NUVFXHU1RTc2XHU2QjYzXHU1RTM4XHU1REU1XHU0RjVDJyxcbiAgICAnc2V0dGluZ3MudGVzdEJ1dHRvbic6ICdcdTZENEJcdThCRDUnLFxuICAgICdzZXR0aW5ncy50ZXN0V29ya2luZyc6ICdcdTZCNjNcdTVFMzhcdTVERTVcdTRGNUNcdUZGMDEnLFxuICAgICdzZXR0aW5ncy50ZXN0RmFpbGVkJzogJ1x1NTkzMVx1OEQyNScsXG4gICAgJ3NldHRpbmdzLmN1c3RvbVByb21wdCc6ICdcdTgxRUFcdTVCOUFcdTRFNDlcdTdDRkJcdTdFREZcdTYzRDBcdTc5M0EnLFxuICAgICdzZXR0aW5ncy5jdXN0b21Qcm9tcHREZXNjJzogJ1x1NTNFRlx1OTAwOVx1NzY4NFx1ODFFQVx1NUI5QVx1NEU0OVx1N0NGQlx1N0VERlx1NjNEMFx1NzkzQVx1RkYwQ1x1NUMwNlx1NkRGQlx1NTJBMFx1NTIzMFx1NjI0MFx1NjcwOVx1OEJGN1x1NkM0Mlx1NTI0RCcsXG4gICAgJ3NldHRpbmdzLmN1c3RvbVByb21wdFBsYWNlaG9sZGVyJzogJ1x1NEY2MFx1NkI2M1x1NTcyOFx1NUUyRVx1NTJBOVx1N0YxNlx1OEY5MSBNYXJrZG93biBcdTdCMTRcdThCQjAuLi4nLFxuICAgICdzZXR0aW5ncy5wcmVzZXJ2ZUN1cnNvcic6ICdcdTRGRERcdTYzMDFcdTUxNDlcdTY4MDdcdTRGNERcdTdGNkUnLFxuICAgICdzZXR0aW5ncy5wcmVzZXJ2ZUN1cnNvckRlc2MnOiAnXHU1RTk0XHU3NTI4XHU2NkY0XHU2NTM5XHU1NDBFXHU1QzFEXHU4QkQ1XHU0RkREXHU2MzAxXHU1MTQ5XHU2ODA3XHU0RjREXHU3RjZFJyxcbiAgICAnc2V0dGluZ3MuYXV0b0FjY2VwdENoYW5nZXMnOiAnXHU4MUVBXHU1MkE4XHU2M0E1XHU1M0Q3XHU2NkY0XHU2NTM5JyxcbiAgICAnc2V0dGluZ3MuYXV0b0FjY2VwdENoYW5nZXNEZXNjJzogJ1x1ODFFQVx1NTJBOFx1NUU5NFx1NzUyOFx1NjZGNFx1NjUzOVx1ODAwQ1x1NEUwRFx1NjYzRVx1NzkzQVx1OTg4NFx1ODlDOFx1RkYwOFx1OEJGN1x1OEMyOFx1NjE0RVx1NEY3Rlx1NzUyOFx1RkYwMVx1RkYwOScsXG4gICAgJ3NldHRpbmdzLm1vZGVsJzogJ1x1NkEyMVx1NTc4QicsXG4gICAgJ3NldHRpbmdzLm1vZGVsRGVzYyc6ICdcdTkwMDlcdTYyRTlcdTg5ODFcdTRGN0ZcdTc1MjhcdTc2ODQgQ2xhdWRlIFx1NkEyMVx1NTc4Qlx1RkYxQVNvbm5ldFx1RkYwOFx1NUU3M1x1ODg2MVx1RkYwOVx1MzAwMU9wdXNcdUZGMDhcdTY3MDBcdTVGM0FcdTU5MjdcdUZGMDlcdTYyMTYgSGFpa3VcdUZGMDhcdTY3MDBcdTVGRUJcdUZGMDlcdTMwMDJcdTc1NTlcdTdBN0FcdTRGN0ZcdTc1MjhcdTlFRDhcdThCQTRcdTVCNTBcdTRFRTNcdTc0MDZcdTZBMjFcdTU3OEJcdTMwMDInLFxuICAgICdzZXR0aW5ncy5tb2RlbERlZmF1bHQnOiAnXHU5RUQ4XHU4QkE0XHVGRjA4XHU1QjUwXHU0RUUzXHU3NDA2XHU2QTIxXHU1NzhCXHVGRjA5JyxcbiAgICAnc2V0dGluZ3MubW9kZWxTb25uZXQnOiAnU29ubmV0XHVGRjA4XHU1RTczXHU4ODYxXHVGRjA5JyxcbiAgICAnc2V0dGluZ3MubW9kZWxPcHVzJzogJ09wdXNcdUZGMDhcdTY3MDBcdTVGM0FcdTU5MjdcdUZGMDknLFxuICAgICdzZXR0aW5ncy5tb2RlbEhhaWt1JzogJ0hhaWt1XHVGRjA4XHU2NzAwXHU1RkVCXHVGRjA5JyxcbiAgICAnc2V0dGluZ3MudmF1bHRBY2Nlc3MnOiAnXHU1MTQxXHU4QkI4XHU0RUQzXHU1RTkzXHU4MzAzXHU1NkY0XHU4QkJGXHU5NUVFJyxcbiAgICAnc2V0dGluZ3MudmF1bHRBY2Nlc3NEZXNjJzogJ1x1NTE0MVx1OEJCOCBDbGF1ZGUgXHU4QkZCXHU1M0Q2L1x1NjQxQ1x1N0QyMlx1NEVEM1x1NUU5M1x1NEUyRFx1NzY4NFx1NTE3Nlx1NEVENlx1NjU4N1x1NEVGNlx1RkYwOFx1NEUwRFx1NEVDNVx1NEVDNVx1NjYyRlx1NUY1M1x1NTI0RFx1N0IxNFx1OEJCMFx1RkYwOScsXG4gICAgJ3NldHRpbmdzLnBlcm1pc3Npb25sZXNzTW9kZSc6ICdcdTU0MkZcdTc1MjhcdTY1RTBcdTY3NDNcdTk2NTBcdTZBMjFcdTVGMEYnLFxuICAgICdzZXR0aW5ncy5wZXJtaXNzaW9ubGVzc01vZGVEZXNjJzogJ1x1NTE0MVx1OEJCOCBDbGF1ZGUgXHU2MjY3XHU4ODRDXHU2NENEXHU0RjVDXHU4MDBDXHU2NUUwXHU5NzAwXHU2QkNGXHU2QjIxXHU4QkY3XHU2QzQyXHU2NzQzXHU5NjUwXHVGRjA4XHU4QkY3XHU4QzI4XHU2MTRFXHU0RjdGXHU3NTI4XHVGRjAxQ2xhdWRlIFx1NUMwNlx1NjJFNVx1NjcwOVx1NUI4Q1x1NTE2OFx1NjNBN1x1NTIzNlx1Njc0M1x1RkYwOScsXG4gICAgJ3NldHRpbmdzLnRpbWVvdXQnOiAnXHU4RDg1XHU2NUY2XHU2NUY2XHU5NUY0XHVGRjA4XHU3OUQyXHVGRjA5JyxcbiAgICAnc2V0dGluZ3MudGltZW91dERlc2MnOiAnXHU3QjQ5XHU1Rjg1IENsYXVkZSBDb2RlIFx1NTRDRFx1NUU5NFx1NzY4NFx1NjcwMFx1OTU3Rlx1NjVGNlx1OTVGNFx1RkYwODAgPSBcdTY1RTBcdThEODVcdTY1RjZcdUZGMDknLFxuICAgICdzZXR0aW5ncy5jdXN0b21BcGlDb25maWcnOiAnXHU4MUVBXHU1QjlBXHU0RTQ5IEFQSSBcdTkxNERcdTdGNkUnLFxuICAgICdzZXR0aW5ncy5jdXN0b21BcGlDb25maWdEZXNjJzogJ1x1NEUzQSBDbGF1ZGUgXHU0RTBEXHU1M0VGXHU3NkY0XHU2M0E1XHU4QkJGXHU5NUVFXHU3Njg0XHU1NzMwXHU1MzNBXHU5MTREXHU3RjZFXHU4MUVBXHU1QjlBXHU0RTQ5IEFQSSBcdTdBRUZcdTcwQjlcdTMwMDJcdTc1NTlcdTdBN0FcdTRGN0ZcdTc1MjhcdTlFRDhcdThCQTRcdThCQkVcdTdGNkVcdTMwMDInLFxuICAgICdzZXR0aW5ncy5hcGlCYXNlVXJsJzogJ0FQSSBcdTU3RkFcdTc4NDAgVVJMJyxcbiAgICAnc2V0dGluZ3MuYXBpQmFzZVVybERlc2MnOiAnXHU4MUVBXHU1QjlBXHU0RTQ5IEFQSSBcdTdBRUZcdTcwQjkgVVJMXHVGRjA4XHU0RjhCXHU1OTgyXHVGRjFBaHR0cHM6Ly9hcGkua2ltaS5jb20vY29kaW5nL1x1RkYwOScsXG4gICAgJ3NldHRpbmdzLmFwaUF1dGhUb2tlbic6ICdBUEkgXHU4QkE0XHU4QkMxXHU0RUU0XHU3MjRDJyxcbiAgICAnc2V0dGluZ3MuYXBpQXV0aFRva2VuRGVzYyc6ICdBUEkgXHU3QUVGXHU3MEI5XHU3Njg0XHU4MUVBXHU1QjlBXHU0RTQ5XHU4QkE0XHU4QkMxXHU0RUU0XHU3MjRDJyxcbiAgICAnc2V0dGluZ3MuYXBpQXV0aFRva2VuUGxhY2Vob2xkZXInOiAnXHU4RjkzXHU1MTY1XHU2MEE4XHU3Njg0IEFQSSBcdTRFRTRcdTcyNEMnLFxuICAgICdzZXR0aW5ncy5jdXN0b21Nb2RlbCc6ICdcdTgxRUFcdTVCOUFcdTRFNDlcdTZBMjFcdTU3OEInLFxuICAgICdzZXR0aW5ncy5jdXN0b21Nb2RlbERlc2MnOiAnXHU4OTgxXHU0RjdGXHU3NTI4XHU3Njg0XHU4MUVBXHU1QjlBXHU0RTQ5XHU2QTIxXHU1NzhCXHU1NDBEXHU3OUYwXHVGRjA4XHU0RjhCXHU1OTgyXHVGRjFBa2ltaS1mb3ItY29kaW5nXHVGRjA5XHUzMDAyXHU1QzA2XHU4OTg2XHU3NkQ2XHU0RTBBXHU5NzYyXHU3Njg0XHU2QTIxXHU1NzhCXHU0RTBCXHU2MkM5XHU5MDA5XHU5ODc5XHUzMDAyJyxcbiAgICAnc2V0dGluZ3MuY3VzdG9tU21hbGxNb2RlbCc6ICdcdTgxRUFcdTVCOUFcdTRFNDlcdTVDMEZcdTU3OEIvXHU1RkVCXHU5MDFGXHU2QTIxXHU1NzhCJyxcbiAgICAnc2V0dGluZ3MuY3VzdG9tU21hbGxNb2RlbERlc2MnOiAnXHU3NTI4XHU0RThFXHU1RkVCXHU5MDFGXHU2NENEXHU0RjVDXHU3Njg0XHU4MUVBXHU1QjlBXHU0RTQ5XHU2QTIxXHU1NzhCXHU1NDBEXHU3OUYwXHVGRjA4XHU0RjhCXHU1OTgyXHVGRjFBa2ltaS1mb3ItY29kaW5nXHVGRjA5JyxcbiAgICAnc2V0dGluZ3MubGFuZ3VhZ2UnOiAnXHU4QkVEXHU4QTAwJyxcbiAgICAnc2V0dGluZ3MubGFuZ3VhZ2VEZXNjJzogJ1x1OTAwOVx1NjJFOVx1NzU0Q1x1OTc2Mlx1OEJFRFx1OEEwMCcsXG59O1xuIiwgIi8qKlxuICogU3BhbmlzaCB0cmFuc2xhdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IGVzID0ge1xuICAgIC8vIEhlYWRlclxuICAgICdoZWFkZXIudGl0bGUnOiAnQXNpc3RlbnRlIENsYXVkZSBDb2RlJyxcbiAgICAnaGVhZGVyLm5vTm90ZVNlbGVjdGVkJzogJ25pbmd1bmEgbm90YSBzZWxlY2Npb25hZGEnLFxuXG4gICAgLy8gSW5wdXQgU2VjdGlvblxuICAgICdpbnB1dC5sYWJlbCc6ICdUdXMgaW5zdHJ1Y2Npb25lczonLFxuICAgICdpbnB1dC5wbGFjZWhvbGRlcic6ICdlai4sIFwiQWdyZWdhciBtXHUwMEUxcyBlamVtcGxvcyBhIGVzdGEgc2VjY2lcdTAwRjNuXCIgbyBcIlJlb3JnYW5pemFyIGNvbiBtZWpvcmVzIGVuY2FiZXphZG9zXCIgKEVudGVyIHBhcmEgZW52aWFyLCBDdHJsK0VudGVyIHBhcmEgbnVldmEgbFx1MDBFRG5lYSknLFxuICAgICdpbnB1dC5jb252ZXJzYXRpb25hbE1vZGUnOiAnbW9kbyBjb252ZXJzYWNpb25hbCAoc2luIGVkaWNpXHUwMEYzbiBkZSBhcmNoaXZvcyknLFxuICAgICdpbnB1dC5jb252ZXJzYXRpb25hbE1vZGVUb29sdGlwJzogJ0NoYXRlYSBjb24gQ2xhdWRlIHNpbiBtb2RpZmljYXIgbmluZ1x1MDBGQW4gYXJjaGl2bycsXG4gICAgJ2lucHV0LnNlbGVjdGVkVGV4dE9ubHknOiAnRWRpdGFyIHNvbG8gdGV4dG8gc2VsZWNjaW9uYWRvJyxcbiAgICAnaW5wdXQuYXV0b0FjY2VwdCc6ICdBY2VwdGFyIGNhbWJpb3MgYXV0b21cdTAwRTF0aWNhbWVudGUnLFxuICAgICdpbnB1dC5tb2RlbExhYmVsJzogJ01vZGVsbzonLFxuICAgICdpbnB1dC5tb2RlbERlZmF1bHQnOiAnUHJlZGV0ZXJtaW5hZG8nLFxuICAgICdpbnB1dC5ydW5CdXR0b24nOiAnRWplY3V0YXIgQ2xhdWRlIENvZGUnLFxuICAgICdpbnB1dC5ydW5uaW5nQnV0dG9uJzogJ0VqZWN1dGFuZG8uLi4nLFxuICAgICdpbnB1dC5jYW5jZWxCdXR0b24nOiAnQ2FuY2VsYXInLFxuXG4gICAgLy8gUmVzdWx0IFNlY3Rpb25cbiAgICAncmVzdWx0LnRpdGxlJzogJ1Jlc3VsdGFkbycsXG5cbiAgICAvLyBPdXRwdXQgU2VjdGlvblxuICAgICdvdXRwdXQudGl0bGUnOiAnU2FsaWRhJyxcblxuICAgIC8vIFByZXZpZXcgU2VjdGlvblxuICAgICdwcmV2aWV3LnRpdGxlJzogJ1Zpc3RhIHByZXZpYScsXG4gICAgJ3ByZXZpZXcudGFiUmF3JzogJ1NpbiBmb3JtYXRvJyxcbiAgICAncHJldmlldy50YWJEaWZmJzogJ0RpZmVyZW5jaWFzJyxcbiAgICAncHJldmlldy50YWJSZW5kZXJlZCc6ICdSZW5kZXJpemFkbycsXG4gICAgJ3ByZXZpZXcub3JpZ2luYWxDaGFycyc6ICdPcmlnaW5hbDonLFxuICAgICdwcmV2aWV3Lm1vZGlmaWVkQ2hhcnMnOiAnTW9kaWZpY2FkbzonLFxuICAgICdwcmV2aWV3LmNoYXJzJzogJ2NhcmFjdGVyZXMnLFxuICAgICdwcmV2aWV3LmFwcGx5QnV0dG9uJzogJ2FwbGljYXIgY2FtYmlvcycsXG4gICAgJ3ByZXZpZXcucmVqZWN0QnV0dG9uJzogJ3JlY2hhemFyJyxcblxuICAgIC8vIEhpc3RvcnkgU2VjdGlvblxuICAgICdoaXN0b3J5LnRpdGxlJzogJ0hpc3RvcmlhbCcsXG4gICAgJ2hpc3RvcnkuY2xlYXJCdXR0b24nOiAnTGltcGlhcicsXG5cbiAgICAvLyBBZ2VudCBTZWN0aW9uXG4gICAgJ2FnZW50LnBsYW5UaXRsZSc6ICdwbGFuJyxcbiAgICAnYWdlbnQuYWN0aXZpdHlUaXRsZSc6ICdBY3RpdmlkYWQnLFxuICAgICdhZ2VudC5ub1BsYW4nOiAnQVx1MDBGQW4gbm8gc2UgaGEgY3JlYWRvIHVuIHBsYW4nLFxuXG4gICAgLy8gVG9kbyBTdGF0dXNcbiAgICAndG9kby5wZW5kaW5nJzogJ3BlbmRpZW50ZScsXG4gICAgJ3RvZG8uaW5Qcm9ncmVzcyc6ICdlbiBwcm9ncmVzbycsXG4gICAgJ3RvZG8uY29tcGxldGVkJzogJ2NvbXBsZXRhZG8nLFxuXG4gICAgLy8gSW50ZXJhY3RpdmUgUHJvbXB0XG4gICAgJ2ludGVyYWN0aXZlLmhlYWRlcic6ICdDbGF1ZGUgZXN0XHUwMEUxIHNvbGljaXRhbmRvIGNvbmZpcm1hY2lcdTAwRjNuJyxcbiAgICAnaW50ZXJhY3RpdmUueWVzQnV0dG9uJzogJ3NcdTAwRUQnLFxuICAgICdpbnRlcmFjdGl2ZS5ub0J1dHRvbic6ICdubycsXG4gICAgJ2ludGVyYWN0aXZlLmN1c3RvbVBsYWNlaG9sZGVyJzogJ08gZXNjcmliZSB1bmEgcmVzcHVlc3RhIHBlcnNvbmFsaXphZGEuLi4nLFxuXG4gICAgLy8gUGVybWlzc2lvbiBBcHByb3ZhbFxuICAgICdwZXJtaXNzaW9uLmhlYWRlcic6ICdwZXJtaXNvIHJlcXVlcmlkbycsXG4gICAgJ3Blcm1pc3Npb24ubWVzc2FnZSc6ICdDbGF1ZGUgZXN0XHUwMEUxIHNvbGljaXRhbmRvIHBlcm1pc28gcGFyYSBlamVjdXRhciBhY2Npb25lcy4nLFxuICAgICdwZXJtaXNzaW9uLmFwcHJvdmVCdXR0b24nOiAnYXByb2JhciB5IGNvbnRpbnVhcicsXG4gICAgJ3Blcm1pc3Npb24uZGVueUJ1dHRvbic6ICdkZW5lZ2FyJyxcblxuICAgIC8vIFN0YXR1cyBNZXNzYWdlc1xuICAgICdzdGF0dXMucHJvY2Vzc2luZyc6ICdDbGF1ZGUgZXN0XHUwMEUxIHByb2Nlc2FuZG8nLFxuICAgICdzdGF0dXMuYXV0b0FwcGx5aW5nJzogJ0FwbGljYW5kbyBjYW1iaW9zIGF1dG9tXHUwMEUxdGljYW1lbnRlLi4uJyxcbiAgICAnc3RhdHVzLnJ1bm5pbmdBdXRob3JpemVkJzogJ0VqZWN1dGFuZG8gdGFyZWFzIGF1dG9yaXphZGFzJyxcbiAgICAnc3RhdHVzLnJ1bm5pbmdJbkJhY2tncm91bmQnOiAnRWplY3V0YW5kbyBlbiBzZWd1bmRvIHBsYW5vLi4uJyxcbiAgICAnc3RhdHVzLmZhaWxlZCc6ICdGYWxsXHUwMEYzIC0gdmVyIGVycm9yIGFiYWpvJyxcblxuICAgIC8vIE5vdGlmaWNhdGlvbnNcbiAgICAnbm90aWNlLmFscmVhZHlQcm9jZXNzaW5nJzogJ1lhIHNlIGVzdFx1MDBFMSBwcm9jZXNhbmRvIHVuYSBzb2xpY2l0dWQuIFBvciBmYXZvciBlc3BlcmEuJyxcbiAgICAnbm90aWNlLmVudGVyUHJvbXB0JzogJ1BvciBmYXZvciBpbmdyZXNhIHVuYSBpbnN0cnVjY2lcdTAwRjNuJyxcbiAgICAnbm90aWNlLm5vQWN0aXZlTm90ZSc6ICdObyBzZSBlbmNvbnRyXHUwMEYzIHVuYSBub3RhIGFjdGl2YSwgcG9yIGZhdm9yIGFicmUgdW5hIG5vdGEgTWFya2Rvd24gcHJpbWVybycsXG4gICAgJ25vdGljZS5ub0VkaXRvcic6ICdObyBzZSBlbmNvbnRyXHUwMEYzIHVuIGVkaXRvciBNYXJrZG93biwgYXNlZ1x1MDBGQXJhdGUgZGUgdGVuZXIgdW5hIG5vdGEgYWJpZXJ0YScsXG4gICAgJ25vdGljZS5ub1ZhdWx0UGF0aCc6ICdObyBzZSBwdWRvIGRldGVybWluYXIgbGEgcnV0YSBkZSBsYSBiXHUwMEYzdmVkYScsXG4gICAgJ25vdGljZS5jb21wbGV0ZWQnOiAnQ2xhdWRlIENvZGUgY29tcGxldGFkbycsXG4gICAgJ25vdGljZS5jb21wbGV0ZWROb0NoYW5nZXMnOiAnQ2xhdWRlIENvZGUgY29tcGxldGFkbyAoc2luIGNhbWJpb3MgZW4gYXJjaGl2b3MpJyxcbiAgICAnbm90aWNlLmNoYW5nZXNBcHBsaWVkJzogJ2NhbWJpb3MgYXBsaWNhZG9zIGF1dG9tXHUwMEUxdGljYW1lbnRlJyxcbiAgICAnbm90aWNlLmNoYW5nZXNBcHBsaWVkU3VjY2Vzcyc6ICdjYW1iaW9zIGFwbGljYWRvcyBleGl0b3NhbWVudGUnLFxuICAgICdub3RpY2UuZmFpbGVkQXBwbHlDaGFuZ2VzJzogJ2ZhbGxcdTAwRjMgYWwgYXBsaWNhciBjYW1iaW9zJyxcbiAgICAnbm90aWNlLmNoYW5nZXNSZWplY3RlZCc6ICdDYW1iaW9zIHJlY2hhemFkb3MnLFxuICAgICdub3RpY2UuY2FuY2VsbGVkJzogJ0NhbmNlbGFkbycsXG4gICAgJ25vdGljZS5wZXJtaXNzaW9uUmVxdWVzdCc6ICdDbGF1ZGUgZXN0XHUwMEUxIHNvbGljaXRhbmRvIHBlcm1pc28gLSBwb3IgZmF2b3IgYXBydWViYSBvIGRlbmllZ2EnLFxuICAgICdub3RpY2UucGVybWlzc2lvbkRlbmllZCc6ICdQZXJtaXNvIGRlbmVnYWRvIC0gQ2xhdWRlIG5vIHByb2NlZGVyXHUwMEUxJyxcbiAgICAnbm90aWNlLm5vQ2hhbmdlc1RvQXBwbHknOiAnbm8gaGF5IGNhbWJpb3MgcGFyYSBhcGxpY2FyJyxcbiAgICAnbm90aWNlLm5vQWN0aXZlRmlsZSc6ICdubyBoYXkgYXJjaGl2byBhY3Rpdm8nLFxuICAgICdub3RpY2UuaGlzdG9yeVJlc3RvcmVkJzogJ0VsZW1lbnRvIGRlbCBoaXN0b3JpYWwgcmVzdGF1cmFkbycsXG4gICAgJ25vdGljZS5oaXN0b3J5UmVzdG9yZWRXaXRoQ2hhbmdlcyc6ICdFbGVtZW50byBkZWwgaGlzdG9yaWFsIHJlc3RhdXJhZG8gY29uIGNhbWJpb3MgcHJvcHVlc3RvcycsXG4gICAgJ25vdGljZS5oaXN0b3J5Q2xlYXJlZCc6ICdIaXN0b3JpYWwgbGltcGlhZG8nLFxuXG4gICAgLy8gRGlmZiBWaWV3XG4gICAgJ2RpZmYub3JpZ2luYWwnOiAnT3JpZ2luYWwnLFxuICAgICdkaWZmLm1vZGlmaWVkJzogJ01vZGlmaWNhZG8nLFxuXG4gICAgLy8gUmVzdWx0IFJlbmRlcmVyXG4gICAgJ3Jlc3VsdC5kaXJlY3RBbnN3ZXInOiAnUmVzcHVlc3RhIGRpcmVjdGEnLFxuICAgICdyZXN1bHQuYWRkaXRpb25hbENvbnRleHQnOiAnQ29udGV4dG8gYWRpY2lvbmFsJyxcbiAgICAncmVzdWx0LnRva2Vucyc6ICd0b2tlbnMnLFxuICAgICdyZXN1bHQudG9rZW5zSW4nOiAnZW50cmFkYScsXG4gICAgJ3Jlc3VsdC50b2tlbnNPdXQnOiAnc2FsaWRhJyxcblxuICAgIC8vIFByZXZpZXcgU3RhdHNcbiAgICAncHJldmlldy5vcmlnaW5hbExhYmVsJzogJ09yaWdpbmFsOicsXG4gICAgJ3ByZXZpZXcubW9kaWZpZWRMYWJlbCc6ICdNb2RpZmljYWRvOicsXG4gICAgJ3ByZXZpZXcuY2hhcnNMYWJlbCc6ICdjYXJhY3RlcmVzJyxcblxuICAgIC8vIE1pc2NcbiAgICAnbWlzYy5ub1BlbmRpbmdSZXF1ZXN0JzogJ05vIHNlIGVuY29udHJcdTAwRjMgc29saWNpdHVkIHBlbmRpZW50ZScsXG4gICAgJ21pc2MubGFuZ3VhZ2VDaGFuZ2VkJzogJ0lkaW9tYSBjYW1iaWFkby4gQWxndW5vcyBlbGVtZW50b3MgZGUgbGEgaW50ZXJmYXogc2UgYWN0dWFsaXphclx1MDBFMW4gYWwgcmVjYXJnYXIuJyxcbiAgICAnbWlzYy50ZXN0RmFpbGVkJzogJ1BydWViYSBkZSBDbGF1ZGUgQ29kZSBmYWxsaWRhJyxcblxuICAgIC8vIFNldHRpbmdzXG4gICAgJ3NldHRpbmdzLmF1dG9EZXRlY3RQYXRoJzogJ0F1dG8tZGV0ZWN0YXIgcnV0YSBkZSBDbGF1ZGUgQ29kZScsXG4gICAgJ3NldHRpbmdzLmF1dG9EZXRlY3RQYXRoRGVzYyc6ICdEZXRlY3RhciBhdXRvbVx1MDBFMXRpY2FtZW50ZSBsYSB1YmljYWNpXHUwMEYzbiBkZWwgZWplY3V0YWJsZSBkZSBDbGF1ZGUgQ29kZScsXG4gICAgJ3NldHRpbmdzLmV4ZWN1dGFibGVQYXRoJzogJ1J1dGEgZGVsIGVqZWN1dGFibGUgZGUgQ2xhdWRlIENvZGUnLFxuICAgICdzZXR0aW5ncy5leGVjdXRhYmxlUGF0aERlc2MnOiAnUnV0YSBjb21wbGV0YSBhbCBlamVjdXRhYmxlIGRlIENsYXVkZSBDb2RlIChlai4sIC91c3IvbG9jYWwvYmluL2NsYXVkZSknLFxuICAgICdzZXR0aW5ncy50ZXN0SW5zdGFsbGF0aW9uJzogJ1Byb2JhciBpbnN0YWxhY2lcdTAwRjNuIGRlIENsYXVkZSBDb2RlJyxcbiAgICAnc2V0dGluZ3MudGVzdEluc3RhbGxhdGlvbkRlc2MnOiAnVmVyaWZpY2FyIHF1ZSBDbGF1ZGUgQ29kZSBzZWEgYWNjZXNpYmxlIHkgZnVuY2lvbmUnLFxuICAgICdzZXR0aW5ncy50ZXN0QnV0dG9uJzogJ1Byb2JhcicsXG4gICAgJ3NldHRpbmdzLnRlc3RXb3JraW5nJzogJ1x1MDBBMWZ1bmNpb25hbmRvIScsXG4gICAgJ3NldHRpbmdzLnRlc3RGYWlsZWQnOiAnZmFsbFx1MDBGMycsXG4gICAgJ3NldHRpbmdzLmN1c3RvbVByb21wdCc6ICdQcm9tcHQgZGUgc2lzdGVtYSBwZXJzb25hbGl6YWRvJyxcbiAgICAnc2V0dGluZ3MuY3VzdG9tUHJvbXB0RGVzYyc6ICdQcm9tcHQgZGUgc2lzdGVtYSBwZXJzb25hbGl6YWRvIG9wY2lvbmFsIHBhcmEgYWdyZWdhciBhIHRvZGFzIGxhcyBzb2xpY2l0dWRlcycsXG4gICAgJ3NldHRpbmdzLmN1c3RvbVByb21wdFBsYWNlaG9sZGVyJzogJ0VzdFx1MDBFMXMgYXl1ZGFuZG8gYSBlZGl0YXIgbm90YXMgbWFya2Rvd24uLi4nLFxuICAgICdzZXR0aW5ncy5wcmVzZXJ2ZUN1cnNvcic6ICdQcmVzZXJ2YXIgcG9zaWNpXHUwMEYzbiBkZWwgY3Vyc29yJyxcbiAgICAnc2V0dGluZ3MucHJlc2VydmVDdXJzb3JEZXNjJzogJ0ludGVudGFyIG1hbnRlbmVyIGxhIHBvc2ljaVx1MDBGM24gZGVsIGN1cnNvciBkZXNwdVx1MDBFOXMgZGUgYXBsaWNhciBjYW1iaW9zJyxcbiAgICAnc2V0dGluZ3MuYXV0b0FjY2VwdENoYW5nZXMnOiAnQWNlcHRhciBjYW1iaW9zIGF1dG9tXHUwMEUxdGljYW1lbnRlJyxcbiAgICAnc2V0dGluZ3MuYXV0b0FjY2VwdENoYW5nZXNEZXNjJzogJ0FwbGljYXIgY2FtYmlvcyBhdXRvbVx1MDBFMXRpY2FtZW50ZSBzaW4gbW9zdHJhciB2aXN0YSBwcmV2aWEgKFx1MDBBMXVzYXIgY29uIHByZWNhdWNpXHUwMEYzbiEpJyxcbiAgICAnc2V0dGluZ3MubW9kZWwnOiAnTW9kZWxvJyxcbiAgICAnc2V0dGluZ3MubW9kZWxEZXNjJzogJ1NlbGVjY2lvbmEgZWwgbW9kZWxvIGRlIENsYXVkZSBhIHVzYXI6IFNvbm5ldCAoZXF1aWxpYnJhZG8pLCBPcHVzIChtXHUwMEUxcyBjYXBheiksIG8gSGFpa3UgKG1cdTAwRTFzIHJcdTAwRTFwaWRvKS4gRGVqYXIgdmFjXHUwMEVEbyBwYXJhIHVzYXIgZWwgbW9kZWxvIGRlIHN1YmFnZW50ZSBwcmVkZXRlcm1pbmFkby4nLFxuICAgICdzZXR0aW5ncy5tb2RlbERlZmF1bHQnOiAnUHJlZGV0ZXJtaW5hZG8gKG1vZGVsbyBzdWJhZ2VudGUpJyxcbiAgICAnc2V0dGluZ3MubW9kZWxTb25uZXQnOiAnU29ubmV0IChlcXVpbGlicmFkbyknLFxuICAgICdzZXR0aW5ncy5tb2RlbE9wdXMnOiAnT3B1cyAobVx1MDBFMXMgY2FwYXopJyxcbiAgICAnc2V0dGluZ3MubW9kZWxIYWlrdSc6ICdIYWlrdSAobVx1MDBFMXMgclx1MDBFMXBpZG8pJyxcbiAgICAnc2V0dGluZ3MudmF1bHRBY2Nlc3MnOiAnUGVybWl0aXIgYWNjZXNvIGEgdG9kYSBsYSBiXHUwMEYzdmVkYScsXG4gICAgJ3NldHRpbmdzLnZhdWx0QWNjZXNzRGVzYyc6ICdQZXJtaXRpciBhIENsYXVkZSBsZWVyL2J1c2NhciBvdHJvcyBhcmNoaXZvcyBlbiB0dSBiXHUwMEYzdmVkYSAobm8gc29sbyBsYSBub3RhIGFjdHVhbCknLFxuICAgICdzZXR0aW5ncy5wZXJtaXNzaW9ubGVzc01vZGUnOiAnSGFiaWxpdGFyIG1vZG8gc2luIHBlcm1pc29zJyxcbiAgICAnc2V0dGluZ3MucGVybWlzc2lvbmxlc3NNb2RlRGVzYyc6ICdQZXJtaXRpciBhIENsYXVkZSBlamVjdXRhciBhY2Npb25lcyBzaW4gcGVkaXIgcGVybWlzbyBjYWRhIHZleiAoXHUwMEExdXNhciBjb24gcHJlY2F1Y2lcdTAwRjNuISBDbGF1ZGUgdGVuZHJcdTAwRTEgY29udHJvbCB0b3RhbCknLFxuICAgICdzZXR0aW5ncy50aW1lb3V0JzogJ1RpZW1wbyBkZSBlc3BlcmEgKHNlZ3VuZG9zKScsXG4gICAgJ3NldHRpbmdzLnRpbWVvdXREZXNjJzogJ1RpZW1wbyBtXHUwMEUxeGltbyBkZSBlc3BlcmEgcGFyYSBsYSByZXNwdWVzdGEgZGUgQ2xhdWRlIENvZGUgKDAgPSBzaW4gbFx1MDBFRG1pdGUpJyxcbiAgICAnc2V0dGluZ3MuY3VzdG9tQXBpQ29uZmlnJzogJ0NvbmZpZ3VyYWNpXHUwMEYzbiBkZSBBUEkgcGVyc29uYWxpemFkYScsXG4gICAgJ3NldHRpbmdzLmN1c3RvbUFwaUNvbmZpZ0Rlc2MnOiAnQ29uZmlndXJhciBlbmRwb2ludHMgZGUgQVBJIHBlcnNvbmFsaXphZG9zIHBhcmEgcmVnaW9uZXMgZG9uZGUgQ2xhdWRlIG5vIGVzdFx1MDBFMSBkaXNwb25pYmxlIGRpcmVjdGFtZW50ZS4gRGVqYXIgdmFjXHUwMEVEbyBwYXJhIHVzYXIgbGEgY29uZmlndXJhY2lcdTAwRjNuIHByZWRldGVybWluYWRhLicsXG4gICAgJ3NldHRpbmdzLmFwaUJhc2VVcmwnOiAnVVJMIGJhc2UgZGUgQVBJJyxcbiAgICAnc2V0dGluZ3MuYXBpQmFzZVVybERlc2MnOiAnVVJMIGRlbCBlbmRwb2ludCBkZSBBUEkgcGVyc29uYWxpemFkbyAoZWouLCBodHRwczovL2FwaS5raW1pLmNvbS9jb2RpbmcvKScsXG4gICAgJ3NldHRpbmdzLmFwaUF1dGhUb2tlbic6ICdUb2tlbiBkZSBhdXRlbnRpY2FjaVx1MDBGM24gZGUgQVBJJyxcbiAgICAnc2V0dGluZ3MuYXBpQXV0aFRva2VuRGVzYyc6ICdUb2tlbiBkZSBhdXRlbnRpY2FjaVx1MDBGM24gcGVyc29uYWxpemFkbyBwYXJhIGVsIGVuZHBvaW50IGRlIEFQSScsXG4gICAgJ3NldHRpbmdzLmFwaUF1dGhUb2tlblBsYWNlaG9sZGVyJzogJ0luZ3Jlc2EgdHUgdG9rZW4gZGUgQVBJJyxcbiAgICAnc2V0dGluZ3MuY3VzdG9tTW9kZWwnOiAnTW9kZWxvIHBlcnNvbmFsaXphZG8nLFxuICAgICdzZXR0aW5ncy5jdXN0b21Nb2RlbERlc2MnOiAnTm9tYnJlIGRlbCBtb2RlbG8gcGVyc29uYWxpemFkbyBhIHVzYXIgKGVqLiwga2ltaS1mb3ItY29kaW5nKS4gU29icmVzY3JpYmUgZWwgc2VsZWN0b3IgZGUgbW9kZWxvIGFudGVyaW9yLicsXG4gICAgJ3NldHRpbmdzLmN1c3RvbVNtYWxsTW9kZWwnOiAnTW9kZWxvIHBlcXVlXHUwMEYxby9yXHUwMEUxcGlkbyBwZXJzb25hbGl6YWRvJyxcbiAgICAnc2V0dGluZ3MuY3VzdG9tU21hbGxNb2RlbERlc2MnOiAnTm9tYnJlIGRlbCBtb2RlbG8gcGVyc29uYWxpemFkbyBwYXJhIG9wZXJhY2lvbmVzIHJcdTAwRTFwaWRhcyAoZWouLCBraW1pLWZvci1jb2RpbmcpJyxcbiAgICAnc2V0dGluZ3MubGFuZ3VhZ2UnOiAnSWRpb21hJyxcbiAgICAnc2V0dGluZ3MubGFuZ3VhZ2VEZXNjJzogJ1NlbGVjY2lvbmFyIGlkaW9tYSBkZSBsYSBpbnRlcmZheicsXG59OyIsICIvKipcbiAqIEdlcm1hbiB0cmFuc2xhdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IGRlID0ge1xuICAgIC8vIEhlYWRlclxuICAgICdoZWFkZXIudGl0bGUnOiAnQ2xhdWRlIENvZGUgQXNzaXN0ZW50JyxcbiAgICAnaGVhZGVyLm5vTm90ZVNlbGVjdGVkJzogJ2tlaW5lIE5vdGl6IGF1c2dld1x1MDBFNGhsdCcsXG5cbiAgICAvLyBJbnB1dCBTZWN0aW9uXG4gICAgJ2lucHV0LmxhYmVsJzogJ0RlaW5lIEFud2Vpc3VuZ2VuOicsXG4gICAgJ2lucHV0LnBsYWNlaG9sZGVyJzogJ3ouQi4gXCJGXHUwMEZDZ2UgbWVociBCZWlzcGllbGUgenUgZGllc2VtIEFic2Nobml0dCBoaW56dVwiIG9kZXIgXCJSZW9yZ2FuaXNpZXJlIG1pdCBiZXNzZXJlbiBcdTAwRENiZXJzY2hyaWZ0ZW5cIiAoRW50ZXIgenVtIFNlbmRlbiwgU3RyZytFbnRlciBmXHUwMEZDciBuZXVlIFplaWxlKScsXG4gICAgJ2lucHV0LmNvbnZlcnNhdGlvbmFsTW9kZSc6ICdLb252ZXJzYXRpb25zbW9kdXMgKGtlaW5lIERhdGVpXHUwMEU0bmRlcnVuZ2VuKScsXG4gICAgJ2lucHV0LmNvbnZlcnNhdGlvbmFsTW9kZVRvb2x0aXAnOiAnTWl0IENsYXVkZSBjaGF0dGVuLCBvaG5lIERhdGVpZW4genUgXHUwMEU0bmRlcm4nLFxuICAgICdpbnB1dC5zZWxlY3RlZFRleHRPbmx5JzogJ051ciBtYXJraWVydGVuIFRleHQgYmVhcmJlaXRlbicsXG4gICAgJ2lucHV0LmF1dG9BY2NlcHQnOiAnXHUwMEM0bmRlcnVuZ2VuIGF1dG9tYXRpc2NoIFx1MDBGQ2Jlcm5laG1lbicsXG4gICAgJ2lucHV0Lm1vZGVsTGFiZWwnOiAnTW9kZWxsOicsXG4gICAgJ2lucHV0Lm1vZGVsRGVmYXVsdCc6ICdTdGFuZGFyZCcsXG4gICAgJ2lucHV0LnJ1bkJ1dHRvbic6ICdDbGF1ZGUgQ29kZSBhdXNmXHUwMEZDaHJlbicsXG4gICAgJ2lucHV0LnJ1bm5pbmdCdXR0b24nOiAnTFx1MDBFNHVmdC4uLicsXG4gICAgJ2lucHV0LmNhbmNlbEJ1dHRvbic6ICdBYmJyZWNoZW4nLFxuXG4gICAgLy8gUmVzdWx0IFNlY3Rpb25cbiAgICAncmVzdWx0LnRpdGxlJzogJ0VyZ2VibmlzJyxcblxuICAgIC8vIE91dHB1dCBTZWN0aW9uXG4gICAgJ291dHB1dC50aXRsZSc6ICdBdXNnYWJlJyxcblxuICAgIC8vIFByZXZpZXcgU2VjdGlvblxuICAgICdwcmV2aWV3LnRpdGxlJzogJ1ZvcnNjaGF1JyxcbiAgICAncHJldmlldy50YWJSYXcnOiAnUm9oJyxcbiAgICAncHJldmlldy50YWJEaWZmJzogJ0RpZmYnLFxuICAgICdwcmV2aWV3LnRhYlJlbmRlcmVkJzogJ0dlcmVuZGVydCcsXG4gICAgJ3ByZXZpZXcub3JpZ2luYWxDaGFycyc6ICdPcmlnaW5hbDonLFxuICAgICdwcmV2aWV3Lm1vZGlmaWVkQ2hhcnMnOiAnR2VcdTAwRTRuZGVydDonLFxuICAgICdwcmV2aWV3LmNoYXJzJzogJ1plaWNoZW4nLFxuICAgICdwcmV2aWV3LmFwcGx5QnV0dG9uJzogJ1x1MDBDNG5kZXJ1bmdlbiBcdTAwRkNiZXJuZWhtZW4nLFxuICAgICdwcmV2aWV3LnJlamVjdEJ1dHRvbic6ICdBYmxlaG5lbicsXG5cbiAgICAvLyBIaXN0b3J5IFNlY3Rpb25cbiAgICAnaGlzdG9yeS50aXRsZSc6ICdWZXJsYXVmJyxcbiAgICAnaGlzdG9yeS5jbGVhckJ1dHRvbic6ICdMXHUwMEY2c2NoZW4nLFxuXG4gICAgLy8gQWdlbnQgU2VjdGlvblxuICAgICdhZ2VudC5wbGFuVGl0bGUnOiAnUGxhbicsXG4gICAgJ2FnZW50LmFjdGl2aXR5VGl0bGUnOiAnQWt0aXZpdFx1MDBFNHQnLFxuICAgICdhZ2VudC5ub1BsYW4nOiAnTm9jaCBrZWluIFBsYW4gZXJzdGVsbHQnLFxuXG4gICAgLy8gVG9kbyBTdGF0dXNcbiAgICAndG9kby5wZW5kaW5nJzogJ0F1c3N0ZWhlbmQnLFxuICAgICd0b2RvLmluUHJvZ3Jlc3MnOiAnSW4gQmVhcmJlaXR1bmcnLFxuICAgICd0b2RvLmNvbXBsZXRlZCc6ICdBYmdlc2NobG9zc2VuJyxcblxuICAgIC8vIEludGVyYWN0aXZlIFByb21wdFxuICAgICdpbnRlcmFjdGl2ZS5oZWFkZXInOiAnQ2xhdWRlIGJpdHRldCB1bSBCZXN0XHUwMEU0dGlndW5nJyxcbiAgICAnaW50ZXJhY3RpdmUueWVzQnV0dG9uJzogJ0phJyxcbiAgICAnaW50ZXJhY3RpdmUubm9CdXR0b24nOiAnTmVpbicsXG4gICAgJ2ludGVyYWN0aXZlLmN1c3RvbVBsYWNlaG9sZGVyJzogJ09kZXIgZWluZSBlaWdlbmUgQW50d29ydCBlaW5nZWJlbi4uLicsXG5cbiAgICAvLyBQZXJtaXNzaW9uIEFwcHJvdmFsXG4gICAgJ3Blcm1pc3Npb24uaGVhZGVyJzogJ0JlcmVjaHRpZ3VuZyBlcmZvcmRlcmxpY2gnLFxuICAgICdwZXJtaXNzaW9uLm1lc3NhZ2UnOiAnQ2xhdWRlIGJpdHRldCB1bSBFcmxhdWJuaXMsIEFrdGlvbmVuIGF1c3p1Zlx1MDBGQ2hyZW4uJyxcbiAgICAncGVybWlzc2lvbi5hcHByb3ZlQnV0dG9uJzogJ0dlbmVobWlnZW4gJiBmb3J0ZmFocmVuJyxcbiAgICAncGVybWlzc2lvbi5kZW55QnV0dG9uJzogJ0FibGVobmVuJyxcblxuICAgIC8vIFN0YXR1cyBNZXNzYWdlc1xuICAgICdzdGF0dXMucHJvY2Vzc2luZyc6ICdDbGF1ZGUgdmVyYXJiZWl0ZXQnLFxuICAgICdzdGF0dXMuYXV0b0FwcGx5aW5nJzogJ1x1MDBDNG5kZXJ1bmdlbiB3ZXJkZW4gYXV0b21hdGlzY2ggXHUwMEZDYmVybm9tbWVuLi4uJyxcbiAgICAnc3RhdHVzLnJ1bm5pbmdBdXRob3JpemVkJzogJ0ZcdTAwRkNocmUgYXV0b3Jpc2llcnRlIEF1ZmdhYmVuIGF1cycsXG4gICAgJ3N0YXR1cy5ydW5uaW5nSW5CYWNrZ3JvdW5kJzogJ0xcdTAwRTR1ZnQgaW0gSGludGVyZ3J1bmQuLi4nLFxuICAgICdzdGF0dXMuZmFpbGVkJzogJ0ZlaGxnZXNjaGxhZ2VuIC0gc2llaGUgRmVobGVyIHVudGVuJyxcblxuICAgIC8vIE5vdGlmaWNhdGlvbnNcbiAgICAnbm90aWNlLmFscmVhZHlQcm9jZXNzaW5nJzogJ0VpbmUgQW5mcmFnZSB3aXJkIGJlcmVpdHMgdmVyYXJiZWl0ZXQuIEJpdHRlIHdhcnRlbi4nLFxuICAgICdub3RpY2UuZW50ZXJQcm9tcHQnOiAnQml0dGUgZ2liIGVpbmUgQW53ZWlzdW5nIGVpbicsXG4gICAgJ25vdGljZS5ub0FjdGl2ZU5vdGUnOiAnS2VpbmUgYWt0aXZlIE5vdGl6IGdlZnVuZGVuLCBiaXR0ZSBcdTAwRjZmZm5lIHp1ZXJzdCBlaW5lIE1hcmtkb3duLU5vdGl6JyxcbiAgICAnbm90aWNlLm5vRWRpdG9yJzogJ0tlaW4gTWFya2Rvd24tRWRpdG9yIGdlZnVuZGVuLCBiaXR0ZSBzdGVsbGUgc2ljaGVyLCBkYXNzIGVpbmUgTm90aXogZ2VcdTAwRjZmZm5ldCBpc3QnLFxuICAgICdub3RpY2Uubm9WYXVsdFBhdGgnOiAnVmF1bHQtUGZhZCBrb25udGUgbmljaHQgZXJtaXR0ZWx0IHdlcmRlbicsXG4gICAgJ25vdGljZS5jb21wbGV0ZWQnOiAnQ2xhdWRlIENvZGUgYWJnZXNjaGxvc3NlbicsXG4gICAgJ25vdGljZS5jb21wbGV0ZWROb0NoYW5nZXMnOiAnQ2xhdWRlIENvZGUgYWJnZXNjaGxvc3NlbiAoa2VpbmUgRGF0ZWlcdTAwRTRuZGVydW5nZW4pJyxcbiAgICAnbm90aWNlLmNoYW5nZXNBcHBsaWVkJzogJ1x1MDBDNG5kZXJ1bmdlbiBhdXRvbWF0aXNjaCBcdTAwRkNiZXJub21tZW4nLFxuICAgICdub3RpY2UuY2hhbmdlc0FwcGxpZWRTdWNjZXNzJzogJ1x1MDBDNG5kZXJ1bmdlbiBlcmZvbGdyZWljaCBcdTAwRkNiZXJub21tZW4nLFxuICAgICdub3RpY2UuZmFpbGVkQXBwbHlDaGFuZ2VzJzogJ1x1MDBDNG5kZXJ1bmdlbiBrb25udGVuIG5pY2h0IFx1MDBGQ2Jlcm5vbW1lbiB3ZXJkZW4nLFxuICAgICdub3RpY2UuY2hhbmdlc1JlamVjdGVkJzogJ1x1MDBDNG5kZXJ1bmdlbiBhYmdlbGVobnQnLFxuICAgICdub3RpY2UuY2FuY2VsbGVkJzogJ0FiZ2Vicm9jaGVuJyxcbiAgICAnbm90aWNlLnBlcm1pc3Npb25SZXF1ZXN0JzogJ0NsYXVkZSBiaXR0ZXQgdW0gQmVyZWNodGlndW5nIC0gYml0dGUgZ2VuZWhtaWdlbiBvZGVyIGFibGVobmVuJyxcbiAgICAnbm90aWNlLnBlcm1pc3Npb25EZW5pZWQnOiAnQmVyZWNodGlndW5nIHZlcndlaWdlcnQgLSBDbGF1ZGUgd2lyZCBuaWNodCBmb3J0ZmFocmVuJyxcbiAgICAnbm90aWNlLm5vQ2hhbmdlc1RvQXBwbHknOiAnS2VpbmUgXHUwMEM0bmRlcnVuZ2VuIHp1bSBcdTAwRENiZXJuZWhtZW4nLFxuICAgICdub3RpY2Uubm9BY3RpdmVGaWxlJzogJ0tlaW5lIGFrdGl2ZSBEYXRlaScsXG4gICAgJ25vdGljZS5oaXN0b3J5UmVzdG9yZWQnOiAnVmVybGF1ZnNlaW50cmFnIHdpZWRlcmhlcmdlc3RlbGx0JyxcbiAgICAnbm90aWNlLmhpc3RvcnlSZXN0b3JlZFdpdGhDaGFuZ2VzJzogJ1ZlcmxhdWZzZWludHJhZyBtaXQgdm9yZ2VzY2hsYWdlbmVuIFx1MDBDNG5kZXJ1bmdlbiB3aWVkZXJoZXJnZXN0ZWxsdCcsXG4gICAgJ25vdGljZS5oaXN0b3J5Q2xlYXJlZCc6ICdWZXJsYXVmIGdlbFx1MDBGNnNjaHQnLFxuXG4gICAgLy8gRGlmZiBWaWV3XG4gICAgJ2RpZmYub3JpZ2luYWwnOiAnT3JpZ2luYWwnLFxuICAgICdkaWZmLm1vZGlmaWVkJzogJ0dlXHUwMEU0bmRlcnQnLFxuXG4gICAgLy8gUmVzdWx0IFJlbmRlcmVyXG4gICAgJ3Jlc3VsdC5kaXJlY3RBbnN3ZXInOiAnRGlyZWt0ZSBBbnR3b3J0JyxcbiAgICAncmVzdWx0LmFkZGl0aW9uYWxDb250ZXh0JzogJ1p1c1x1MDBFNHR6bGljaGVyIEtvbnRleHQnLFxuICAgICdyZXN1bHQudG9rZW5zJzogJ1Rva2VucycsXG4gICAgJ3Jlc3VsdC50b2tlbnNJbic6ICdFaW5nYWJlJyxcbiAgICAncmVzdWx0LnRva2Vuc091dCc6ICdBdXNnYWJlJyxcblxuICAgIC8vIFByZXZpZXcgU3RhdHNcbiAgICAncHJldmlldy5vcmlnaW5hbExhYmVsJzogJ09yaWdpbmFsOicsXG4gICAgJ3ByZXZpZXcubW9kaWZpZWRMYWJlbCc6ICdHZVx1MDBFNG5kZXJ0OicsXG4gICAgJ3ByZXZpZXcuY2hhcnNMYWJlbCc6ICdaZWljaGVuJyxcblxuICAgIC8vIE1pc2NcbiAgICAnbWlzYy5ub1BlbmRpbmdSZXF1ZXN0JzogJ0tlaW5lIGF1c3N0ZWhlbmRlIEFuZnJhZ2UgZ2VmdW5kZW4nLFxuICAgICdtaXNjLmxhbmd1YWdlQ2hhbmdlZCc6ICdTcHJhY2hlIGdlXHUwMEU0bmRlcnQuIEVpbmlnZSBVSS1FbGVtZW50ZSB3ZXJkZW4gbmFjaCBkZW0gTmV1bGFkZW4gYWt0dWFsaXNpZXJ0LicsXG4gICAgJ21pc2MudGVzdEZhaWxlZCc6ICdDbGF1ZGUgQ29kZSBUZXN0IGZlaGxnZXNjaGxhZ2VuJyxcblxuICAgIC8vIFNldHRpbmdzXG4gICAgJ3NldHRpbmdzLmF1dG9EZXRlY3RQYXRoJzogJ0NsYXVkZSBDb2RlIFBmYWQgYXV0b21hdGlzY2ggZXJrZW5uZW4nLFxuICAgICdzZXR0aW5ncy5hdXRvRGV0ZWN0UGF0aERlc2MnOiAnRGVuIFNwZWljaGVyb3J0IGRlciBDbGF1ZGUgQ29kZSBBbndlbmR1bmcgYXV0b21hdGlzY2ggZXJrZW5uZW4nLFxuICAgICdzZXR0aW5ncy5leGVjdXRhYmxlUGF0aCc6ICdDbGF1ZGUgQ29kZSBBbndlbmR1bmdzcGZhZCcsXG4gICAgJ3NldHRpbmdzLmV4ZWN1dGFibGVQYXRoRGVzYyc6ICdWb2xsc3RcdTAwRTRuZGlnZXIgUGZhZCB6dXIgQ2xhdWRlIENvZGUgQW53ZW5kdW5nICh6LkIuIC91c3IvbG9jYWwvYmluL2NsYXVkZSknLFxuICAgICdzZXR0aW5ncy50ZXN0SW5zdGFsbGF0aW9uJzogJ0NsYXVkZSBDb2RlIEluc3RhbGxhdGlvbiB0ZXN0ZW4nLFxuICAgICdzZXR0aW5ncy50ZXN0SW5zdGFsbGF0aW9uRGVzYyc6ICdcdTAwRENiZXJwclx1MDBGQ2Zlbiwgb2IgQ2xhdWRlIENvZGUgZXJyZWljaGJhciBpc3QgdW5kIGZ1bmt0aW9uaWVydCcsXG4gICAgJ3NldHRpbmdzLnRlc3RCdXR0b24nOiAnVGVzdGVuJyxcbiAgICAnc2V0dGluZ3MudGVzdFdvcmtpbmcnOiAnRnVua3Rpb25pZXJ0IScsXG4gICAgJ3NldHRpbmdzLnRlc3RGYWlsZWQnOiAnRmVobGdlc2NobGFnZW4nLFxuICAgICdzZXR0aW5ncy5jdXN0b21Qcm9tcHQnOiAnQmVudXR6ZXJkZWZpbmllcnRlIFN5c3RlbWFud2Vpc3VuZycsXG4gICAgJ3NldHRpbmdzLmN1c3RvbVByb21wdERlc2MnOiAnT3B0aW9uYWxlIGJlbnV0emVyZGVmaW5pZXJ0ZSBTeXN0ZW1hbndlaXN1bmcsIGRpZSBhbGxlbiBBbmZyYWdlbiB2b3Jhbmdlc3RlbGx0IHdpcmQnLFxuICAgICdzZXR0aW5ncy5jdXN0b21Qcm9tcHRQbGFjZWhvbGRlcic6ICdEdSBoaWxmc3QgYmVpbSBCZWFyYmVpdGVuIHZvbiBNYXJrZG93bi1Ob3RpemVuLi4uJyxcbiAgICAnc2V0dGluZ3MucHJlc2VydmVDdXJzb3InOiAnQ3Vyc29ycG9zaXRpb24gYmVpYmVoYWx0ZW4nLFxuICAgICdzZXR0aW5ncy5wcmVzZXJ2ZUN1cnNvckRlc2MnOiAnVmVyc3VjaGVuLCBkaWUgQ3Vyc29ycG9zaXRpb24gbmFjaCBkZW0gXHUwMERDYmVybmVobWVuIHZvbiBcdTAwQzRuZGVydW5nZW4gYmVpenViZWhhbHRlbicsXG4gICAgJ3NldHRpbmdzLmF1dG9BY2NlcHRDaGFuZ2VzJzogJ1x1MDBDNG5kZXJ1bmdlbiBhdXRvbWF0aXNjaCBcdTAwRkNiZXJuZWhtZW4nLFxuICAgICdzZXR0aW5ncy5hdXRvQWNjZXB0Q2hhbmdlc0Rlc2MnOiAnXHUwMEM0bmRlcnVuZ2VuIGF1dG9tYXRpc2NoIFx1MDBGQ2Jlcm5laG1lbiwgb2huZSBWb3JzY2hhdSBhbnp1emVpZ2VuIChtaXQgVm9yc2ljaHQgdmVyd2VuZGVuISknLFxuICAgICdzZXR0aW5ncy5tb2RlbCc6ICdNb2RlbGwnLFxuICAgICdzZXR0aW5ncy5tb2RlbERlc2MnOiAnV1x1MDBFNGhsZSBkYXMgQ2xhdWRlLU1vZGVsbDogU29ubmV0IChhdXNnZXdvZ2VuKSwgT3B1cyAobGVpc3R1bmdzZlx1MDBFNGhpZ3N0ZSksIG9kZXIgSGFpa3UgKHNjaG5lbGxzdGUpLiBMZWVyIGxhc3NlbiBmXHUwMEZDciBTdGFuZGFyZC1TdWJhZ2VudC1Nb2RlbGwuJyxcbiAgICAnc2V0dGluZ3MubW9kZWxEZWZhdWx0JzogJ1N0YW5kYXJkIChTdWJhZ2VudC1Nb2RlbGwpJyxcbiAgICAnc2V0dGluZ3MubW9kZWxTb25uZXQnOiAnU29ubmV0IChhdXNnZXdvZ2VuKScsXG4gICAgJ3NldHRpbmdzLm1vZGVsT3B1cyc6ICdPcHVzIChsZWlzdHVuZ3NmXHUwMEU0aGlnc3RlKScsXG4gICAgJ3NldHRpbmdzLm1vZGVsSGFpa3UnOiAnSGFpa3UgKHNjaG5lbGxzdGUpJyxcbiAgICAnc2V0dGluZ3MudmF1bHRBY2Nlc3MnOiAnVmF1bHQtd2VpdGVuIFp1Z3JpZmYgZXJsYXViZW4nLFxuICAgICdzZXR0aW5ncy52YXVsdEFjY2Vzc0Rlc2MnOiAnQ2xhdWRlIGVybGF1YmVuLCBhbmRlcmUgRGF0ZWllbiBpbSBWYXVsdCB6dSBsZXNlbi9kdXJjaHN1Y2hlbiAobmljaHQgbnVyIGRpZSBha3R1ZWxsZSBOb3RpeiknLFxuICAgICdzZXR0aW5ncy5wZXJtaXNzaW9ubGVzc01vZGUnOiAnQmVyZWNodGlndW5nc2ZyZWllbiBNb2R1cyBha3RpdmllcmVuJyxcbiAgICAnc2V0dGluZ3MucGVybWlzc2lvbmxlc3NNb2RlRGVzYyc6ICdDbGF1ZGUgZXJsYXViZW4sIEFrdGlvbmVuIGF1c3p1Zlx1MDBGQ2hyZW4sIG9obmUgamVkZXMgTWFsIHVtIEVybGF1Ym5pcyB6dSBmcmFnZW4gKG1pdCBWb3JzaWNodCB2ZXJ3ZW5kZW4hIENsYXVkZSBoYXQgdm9sbGUgS29udHJvbGxlKScsXG4gICAgJ3NldHRpbmdzLnRpbWVvdXQnOiAnWmVpdGxpbWl0IChTZWt1bmRlbiknLFxuICAgICdzZXR0aW5ncy50aW1lb3V0RGVzYyc6ICdNYXhpbWFsZSBXYXJ0ZXplaXQgYXVmIENsYXVkZSBDb2RlIEFudHdvcnQgKDAgPSBrZWluIFplaXRsaW1pdCknLFxuICAgICdzZXR0aW5ncy5jdXN0b21BcGlDb25maWcnOiAnQmVudXR6ZXJkZWZpbmllcnRlIEFQSS1Lb25maWd1cmF0aW9uJyxcbiAgICAnc2V0dGluZ3MuY3VzdG9tQXBpQ29uZmlnRGVzYyc6ICdCZW51dHplcmRlZmluaWVydGUgQVBJLUVuZHB1bmt0ZSBmXHUwMEZDciBSZWdpb25lbiBrb25maWd1cmllcmVuLCBpbiBkZW5lbiBDbGF1ZGUgbmljaHQgZGlyZWt0IHZlcmZcdTAwRkNnYmFyIGlzdC4gTGVlciBsYXNzZW4gZlx1MDBGQ3IgU3RhbmRhcmRlaW5zdGVsbHVuZ2VuLicsXG4gICAgJ3NldHRpbmdzLmFwaUJhc2VVcmwnOiAnQVBJIEJhc2lzLVVSTCcsXG4gICAgJ3NldHRpbmdzLmFwaUJhc2VVcmxEZXNjJzogJ0JlbnV0emVyZGVmaW5pZXJ0ZSBBUEktRW5kcHVua3QtVVJMICh6LkIuIGh0dHBzOi8vYXBpLmtpbWkuY29tL2NvZGluZy8pJyxcbiAgICAnc2V0dGluZ3MuYXBpQXV0aFRva2VuJzogJ0FQSSBBdXRoLVRva2VuJyxcbiAgICAnc2V0dGluZ3MuYXBpQXV0aFRva2VuRGVzYyc6ICdCZW51dHplcmRlZmluaWVydGVzIEF1dGhlbnRpZml6aWVydW5nc3Rva2VuIGZcdTAwRkNyIGRlbiBBUEktRW5kcHVua3QnLFxuICAgICdzZXR0aW5ncy5hcGlBdXRoVG9rZW5QbGFjZWhvbGRlcic6ICdHaWIgZGVpbiBBUEktVG9rZW4gZWluJyxcbiAgICAnc2V0dGluZ3MuY3VzdG9tTW9kZWwnOiAnQmVudXR6ZXJkZWZpbmllcnRlcyBNb2RlbGwnLFxuICAgICdzZXR0aW5ncy5jdXN0b21Nb2RlbERlc2MnOiAnQmVudXR6ZXJkZWZpbmllcnRlciBNb2RlbGxuYW1lICh6LkIuIGtpbWktZm9yLWNvZGluZykuIFx1MDBEQ2JlcnNjaHJlaWJ0IGRpZSBNb2RlbGxhdXN3YWhsIG9iZW4uJyxcbiAgICAnc2V0dGluZ3MuY3VzdG9tU21hbGxNb2RlbCc6ICdCZW51dHplcmRlZmluaWVydGVzIGtsZWluZXMvc2NobmVsbGVzIE1vZGVsbCcsXG4gICAgJ3NldHRpbmdzLmN1c3RvbVNtYWxsTW9kZWxEZXNjJzogJ0JlbnV0emVyZGVmaW5pZXJ0ZXIgTW9kZWxsbmFtZSBmXHUwMEZDciBzY2huZWxsZSBPcGVyYXRpb25lbiAoei5CLiBraW1pLWZvci1jb2RpbmcpJyxcbiAgICAnc2V0dGluZ3MubGFuZ3VhZ2UnOiAnU3ByYWNoZScsXG4gICAgJ3NldHRpbmdzLmxhbmd1YWdlRGVzYyc6ICdPYmVyZmxcdTAwRTRjaGVuc3ByYWNoZSBhdXN3XHUwMEU0aGxlbicsXG59OyIsICIvKipcbiAqIFBvcnR1Z3Vlc2UgdHJhbnNsYXRpb25zXG4gKi9cbmV4cG9ydCBjb25zdCBwdCA9IHtcbiAgICAvLyBIZWFkZXJcbiAgICAnaGVhZGVyLnRpdGxlJzogJ0Fzc2lzdGVudGUgQ2xhdWRlIENvZGUnLFxuICAgICdoZWFkZXIubm9Ob3RlU2VsZWN0ZWQnOiAnbmVuaHVtYSBub3RhIHNlbGVjaW9uYWRhJyxcblxuICAgIC8vIElucHV0IFNlY3Rpb25cbiAgICAnaW5wdXQubGFiZWwnOiAnU3VhcyBpbnN0cnVcdTAwRTdcdTAwRjVlczonLFxuICAgICdpbnB1dC5wbGFjZWhvbGRlcic6ICdleC4sIFwiQWRpY2lvbmUgbWFpcyBleGVtcGxvcyBhIGVzdGEgc2VcdTAwRTdcdTAwRTNvXCIgb3UgXCJSZW9yZ2FuaXplIGNvbSBtZWxob3JlcyB0XHUwMEVEdHVsb3NcIiAoRW50ZXIgcGFyYSBlbnZpYXIsIEN0cmwrRW50ZXIgcGFyYSBub3ZhIGxpbmhhKScsXG4gICAgJ2lucHV0LmNvbnZlcnNhdGlvbmFsTW9kZSc6ICdtb2RvIGNvbnZlcnNhY2lvbmFsIChzZW0gZWRpXHUwMEU3XHUwMEUzbyBkZSBhcnF1aXZvcyknLFxuICAgICdpbnB1dC5jb252ZXJzYXRpb25hbE1vZGVUb29sdGlwJzogJ0NvbnZlcnNlIGNvbSBDbGF1ZGUgc2VtIG1vZGlmaWNhciBhcnF1aXZvcycsXG4gICAgJ2lucHV0LnNlbGVjdGVkVGV4dE9ubHknOiAnRWRpdGFyIGFwZW5hcyB0ZXh0byBzZWxlY2lvbmFkbycsXG4gICAgJ2lucHV0LmF1dG9BY2NlcHQnOiAnQWNlaXRhciBhbHRlcmFcdTAwRTdcdTAwRjVlcyBhdXRvbWF0aWNhbWVudGUnLFxuICAgICdpbnB1dC5tb2RlbExhYmVsJzogJ01vZGVsbzonLFxuICAgICdpbnB1dC5tb2RlbERlZmF1bHQnOiAnUGFkclx1MDBFM28nLFxuICAgICdpbnB1dC5ydW5CdXR0b24nOiAnRXhlY3V0YXIgQ2xhdWRlIENvZGUnLFxuICAgICdpbnB1dC5ydW5uaW5nQnV0dG9uJzogJ0V4ZWN1dGFuZG8uLi4nLFxuICAgICdpbnB1dC5jYW5jZWxCdXR0b24nOiAnQ2FuY2VsYXInLFxuXG4gICAgLy8gUmVzdWx0IFNlY3Rpb25cbiAgICAncmVzdWx0LnRpdGxlJzogJ1Jlc3VsdGFkbycsXG5cbiAgICAvLyBPdXRwdXQgU2VjdGlvblxuICAgICdvdXRwdXQudGl0bGUnOiAnU2FcdTAwRURkYScsXG5cbiAgICAvLyBQcmV2aWV3IFNlY3Rpb25cbiAgICAncHJldmlldy50aXRsZSc6ICdWaXN1YWxpemFcdTAwRTdcdTAwRTNvJyxcbiAgICAncHJldmlldy50YWJSYXcnOiAnQnJ1dG8nLFxuICAgICdwcmV2aWV3LnRhYkRpZmYnOiAnRGlmZXJlblx1MDBFN2FzJyxcbiAgICAncHJldmlldy50YWJSZW5kZXJlZCc6ICdSZW5kZXJpemFkbycsXG4gICAgJ3ByZXZpZXcub3JpZ2luYWxDaGFycyc6ICdPcmlnaW5hbDonLFxuICAgICdwcmV2aWV3Lm1vZGlmaWVkQ2hhcnMnOiAnTW9kaWZpY2FkbzonLFxuICAgICdwcmV2aWV3LmNoYXJzJzogJ2NhcmFjdGVyZXMnLFxuICAgICdwcmV2aWV3LmFwcGx5QnV0dG9uJzogJ2FwbGljYXIgYWx0ZXJhXHUwMEU3XHUwMEY1ZXMnLFxuICAgICdwcmV2aWV3LnJlamVjdEJ1dHRvbic6ICdyZWplaXRhcicsXG5cbiAgICAvLyBIaXN0b3J5IFNlY3Rpb25cbiAgICAnaGlzdG9yeS50aXRsZSc6ICdIaXN0XHUwMEYzcmljbycsXG4gICAgJ2hpc3RvcnkuY2xlYXJCdXR0b24nOiAnTGltcGFyJyxcblxuICAgIC8vIEFnZW50IFNlY3Rpb25cbiAgICAnYWdlbnQucGxhblRpdGxlJzogJ3BsYW5vJyxcbiAgICAnYWdlbnQuYWN0aXZpdHlUaXRsZSc6ICdBdGl2aWRhZGUnLFxuICAgICdhZ2VudC5ub1BsYW4nOiAnTmVuaHVtIHBsYW5vIGNyaWFkbyBhaW5kYScsXG5cbiAgICAvLyBUb2RvIFN0YXR1c1xuICAgICd0b2RvLnBlbmRpbmcnOiAncGVuZGVudGUnLFxuICAgICd0b2RvLmluUHJvZ3Jlc3MnOiAnZW0gcHJvZ3Jlc3NvJyxcbiAgICAndG9kby5jb21wbGV0ZWQnOiAnY29uY2x1XHUwMEVEZG8nLFxuXG4gICAgLy8gSW50ZXJhY3RpdmUgUHJvbXB0XG4gICAgJ2ludGVyYWN0aXZlLmhlYWRlcic6ICdDbGF1ZGUgZXN0XHUwMEUxIHBlZGluZG8gY29uZmlybWFcdTAwRTdcdTAwRTNvJyxcbiAgICAnaW50ZXJhY3RpdmUueWVzQnV0dG9uJzogJ3NpbScsXG4gICAgJ2ludGVyYWN0aXZlLm5vQnV0dG9uJzogJ25cdTAwRTNvJyxcbiAgICAnaW50ZXJhY3RpdmUuY3VzdG9tUGxhY2Vob2xkZXInOiAnT3UgZGlnaXRlIHVtYSByZXNwb3N0YSBwZXJzb25hbGl6YWRhLi4uJyxcblxuICAgIC8vIFBlcm1pc3Npb24gQXBwcm92YWxcbiAgICAncGVybWlzc2lvbi5oZWFkZXInOiAncGVybWlzc1x1MDBFM28gbmVjZXNzXHUwMEUxcmlhJyxcbiAgICAncGVybWlzc2lvbi5tZXNzYWdlJzogJ0NsYXVkZSBlc3RcdTAwRTEgc29saWNpdGFuZG8gcGVybWlzc1x1MDBFM28gcGFyYSBleGVjdXRhciBhXHUwMEU3XHUwMEY1ZXMuJyxcbiAgICAncGVybWlzc2lvbi5hcHByb3ZlQnV0dG9uJzogJ2Fwcm92YXIgZSBjb250aW51YXInLFxuICAgICdwZXJtaXNzaW9uLmRlbnlCdXR0b24nOiAnbmVnYXInLFxuXG4gICAgLy8gU3RhdHVzIE1lc3NhZ2VzXG4gICAgJ3N0YXR1cy5wcm9jZXNzaW5nJzogJ0NsYXVkZSBlc3RcdTAwRTEgcHJvY2Vzc2FuZG8nLFxuICAgICdzdGF0dXMuYXV0b0FwcGx5aW5nJzogJ0FwbGljYW5kbyBhbHRlcmFcdTAwRTdcdTAwRjVlcyBhdXRvbWF0aWNhbWVudGUuLi4nLFxuICAgICdzdGF0dXMucnVubmluZ0F1dGhvcml6ZWQnOiAnRXhlY3V0YW5kbyB0YXJlZmFzIGF1dG9yaXphZGFzJyxcbiAgICAnc3RhdHVzLnJ1bm5pbmdJbkJhY2tncm91bmQnOiAnRXhlY3V0YW5kbyBlbSBzZWd1bmRvIHBsYW5vLi4uJyxcbiAgICAnc3RhdHVzLmZhaWxlZCc6ICdGYWxob3UgLSB2ZWphIG8gZXJybyBhYmFpeG8nLFxuXG4gICAgLy8gTm90aWZpY2F0aW9uc1xuICAgICdub3RpY2UuYWxyZWFkeVByb2Nlc3NpbmcnOiAnSlx1MDBFMSBlc3RcdTAwRTEgcHJvY2Vzc2FuZG8gdW1hIHNvbGljaXRhXHUwMEU3XHUwMEUzby4gUG9yIGZhdm9yLCBhZ3VhcmRlLicsXG4gICAgJ25vdGljZS5lbnRlclByb21wdCc6ICdQb3IgZmF2b3IsIGluc2lyYSB1bSBwcm9tcHQnLFxuICAgICdub3RpY2Uubm9BY3RpdmVOb3RlJzogJ05lbmh1bWEgbm90YSBhdGl2YSBlbmNvbnRyYWRhLCBwb3IgZmF2b3IgYWJyYSB1bWEgbm90YSBNYXJrZG93biBwcmltZWlybycsXG4gICAgJ25vdGljZS5ub0VkaXRvcic6ICdOZW5odW0gZWRpdG9yIE1hcmtkb3duIGVuY29udHJhZG8sIGNlcnRpZmlxdWUtc2UgZGUgcXVlIHZvY1x1MDBFQSB0ZW0gdW1hIG5vdGEgYWJlcnRhJyxcbiAgICAnbm90aWNlLm5vVmF1bHRQYXRoJzogJ05cdTAwRTNvIGZvaSBwb3NzXHUwMEVEdmVsIGRldGVybWluYXIgbyBjYW1pbmhvIGRvIHZhdWx0JyxcbiAgICAnbm90aWNlLmNvbXBsZXRlZCc6ICdDbGF1ZGUgQ29kZSBjb25jbHVcdTAwRURkbycsXG4gICAgJ25vdGljZS5jb21wbGV0ZWROb0NoYW5nZXMnOiAnQ2xhdWRlIENvZGUgY29uY2x1XHUwMEVEZG8gKHNlbSBhbHRlcmFcdTAwRTdcdTAwRjVlcyBkZSBhcnF1aXZvKScsXG4gICAgJ25vdGljZS5jaGFuZ2VzQXBwbGllZCc6ICdhbHRlcmFcdTAwRTdcdTAwRjVlcyBhcGxpY2FkYXMgYXV0b21hdGljYW1lbnRlJyxcbiAgICAnbm90aWNlLmNoYW5nZXNBcHBsaWVkU3VjY2Vzcyc6ICdhbHRlcmFcdTAwRTdcdTAwRjVlcyBhcGxpY2FkYXMgY29tIHN1Y2Vzc28nLFxuICAgICdub3RpY2UuZmFpbGVkQXBwbHlDaGFuZ2VzJzogJ2ZhbGhhIGFvIGFwbGljYXIgYWx0ZXJhXHUwMEU3XHUwMEY1ZXMnLFxuICAgICdub3RpY2UuY2hhbmdlc1JlamVjdGVkJzogJ0FsdGVyYVx1MDBFN1x1MDBGNWVzIHJlamVpdGFkYXMnLFxuICAgICdub3RpY2UuY2FuY2VsbGVkJzogJ0NhbmNlbGFkbycsXG4gICAgJ25vdGljZS5wZXJtaXNzaW9uUmVxdWVzdCc6ICdDbGF1ZGUgZXN0XHUwMEUxIHNvbGljaXRhbmRvIHBlcm1pc3NcdTAwRTNvIC0gcG9yIGZhdm9yIGFwcm92ZSBvdSBuZWd1ZScsXG4gICAgJ25vdGljZS5wZXJtaXNzaW9uRGVuaWVkJzogJ1Blcm1pc3NcdTAwRTNvIG5lZ2FkYSAtIENsYXVkZSBuXHUwMEUzbyBwcm9zc2VndWlyXHUwMEUxJyxcbiAgICAnbm90aWNlLm5vQ2hhbmdlc1RvQXBwbHknOiAnbmVuaHVtYSBhbHRlcmFcdTAwRTdcdTAwRTNvIHBhcmEgYXBsaWNhcicsXG4gICAgJ25vdGljZS5ub0FjdGl2ZUZpbGUnOiAnbmVuaHVtIGFycXVpdm8gYXRpdm8nLFxuICAgICdub3RpY2UuaGlzdG9yeVJlc3RvcmVkJzogJ0l0ZW0gZG8gaGlzdFx1MDBGM3JpY28gcmVzdGF1cmFkbycsXG4gICAgJ25vdGljZS5oaXN0b3J5UmVzdG9yZWRXaXRoQ2hhbmdlcyc6ICdJdGVtIGRvIGhpc3RcdTAwRjNyaWNvIHJlc3RhdXJhZG8gY29tIGFsdGVyYVx1MDBFN1x1MDBGNWVzIHByb3Bvc3RhcycsXG4gICAgJ25vdGljZS5oaXN0b3J5Q2xlYXJlZCc6ICdIaXN0XHUwMEYzcmljbyBsaW1wbycsXG5cbiAgICAvLyBEaWZmIFZpZXdcbiAgICAnZGlmZi5vcmlnaW5hbCc6ICdPcmlnaW5hbCcsXG4gICAgJ2RpZmYubW9kaWZpZWQnOiAnTW9kaWZpY2FkbycsXG5cbiAgICAvLyBSZXN1bHQgUmVuZGVyZXJcbiAgICAncmVzdWx0LmRpcmVjdEFuc3dlcic6ICdSZXNwb3N0YSBkaXJldGEnLFxuICAgICdyZXN1bHQuYWRkaXRpb25hbENvbnRleHQnOiAnQ29udGV4dG8gYWRpY2lvbmFsJyxcbiAgICAncmVzdWx0LnRva2Vucyc6ICd0b2tlbnMnLFxuICAgICdyZXN1bHQudG9rZW5zSW4nOiAnZW50cmFkYScsXG4gICAgJ3Jlc3VsdC50b2tlbnNPdXQnOiAnc2FcdTAwRURkYScsXG5cbiAgICAvLyBQcmV2aWV3IFN0YXRzXG4gICAgJ3ByZXZpZXcub3JpZ2luYWxMYWJlbCc6ICdPcmlnaW5hbDonLFxuICAgICdwcmV2aWV3Lm1vZGlmaWVkTGFiZWwnOiAnTW9kaWZpY2FkbzonLFxuICAgICdwcmV2aWV3LmNoYXJzTGFiZWwnOiAnY2FyYWN0ZXJlcycsXG5cbiAgICAvLyBNaXNjXG4gICAgJ21pc2Mubm9QZW5kaW5nUmVxdWVzdCc6ICdOZW5odW1hIHNvbGljaXRhXHUwMEU3XHUwMEUzbyBwZW5kZW50ZSBlbmNvbnRyYWRhJyxcbiAgICAnbWlzYy5sYW5ndWFnZUNoYW5nZWQnOiAnSWRpb21hIGFsdGVyYWRvLiBBbGd1bnMgZWxlbWVudG9zIGRhIGludGVyZmFjZSBzZXJcdTAwRTNvIGF0dWFsaXphZG9zIGFvIHJlY2FycmVnYXIuJyxcbiAgICAnbWlzYy50ZXN0RmFpbGVkJzogJ1Rlc3RlIGRvIENsYXVkZSBDb2RlIGZhbGhvdScsXG5cbiAgICAvLyBTZXR0aW5nc1xuICAgICdzZXR0aW5ncy5hdXRvRGV0ZWN0UGF0aCc6ICdEZXRlY3RhciBjYW1pbmhvIGRvIENsYXVkZSBDb2RlIGF1dG9tYXRpY2FtZW50ZScsXG4gICAgJ3NldHRpbmdzLmF1dG9EZXRlY3RQYXRoRGVzYyc6ICdEZXRlY3RhciBhdXRvbWF0aWNhbWVudGUgYSBsb2NhbGl6YVx1MDBFN1x1MDBFM28gZG8gZXhlY3V0XHUwMEUxdmVsIGRvIENsYXVkZSBDb2RlJyxcbiAgICAnc2V0dGluZ3MuZXhlY3V0YWJsZVBhdGgnOiAnQ2FtaW5obyBkbyBleGVjdXRcdTAwRTF2ZWwgZG8gQ2xhdWRlIENvZGUnLFxuICAgICdzZXR0aW5ncy5leGVjdXRhYmxlUGF0aERlc2MnOiAnQ2FtaW5obyBjb21wbGV0byBwYXJhIG8gZXhlY3V0XHUwMEUxdmVsIGRvIENsYXVkZSBDb2RlIChleC4sIC91c3IvbG9jYWwvYmluL2NsYXVkZSknLFxuICAgICdzZXR0aW5ncy50ZXN0SW5zdGFsbGF0aW9uJzogJ1Rlc3RhciBpbnN0YWxhXHUwMEU3XHUwMEUzbyBkbyBDbGF1ZGUgQ29kZScsXG4gICAgJ3NldHRpbmdzLnRlc3RJbnN0YWxsYXRpb25EZXNjJzogJ1ZlcmlmaWNhciBzZSBvIENsYXVkZSBDb2RlIGVzdFx1MDBFMSBhY2Vzc1x1MDBFRHZlbCBlIGZ1bmNpb25hbmRvJyxcbiAgICAnc2V0dGluZ3MudGVzdEJ1dHRvbic6ICdUZXN0YXInLFxuICAgICdzZXR0aW5ncy50ZXN0V29ya2luZyc6ICdmdW5jaW9uYW5kbyEnLFxuICAgICdzZXR0aW5ncy50ZXN0RmFpbGVkJzogJ2ZhbGhvdScsXG4gICAgJ3NldHRpbmdzLmN1c3RvbVByb21wdCc6ICdQcm9tcHQgZGUgc2lzdGVtYSBwZXJzb25hbGl6YWRvJyxcbiAgICAnc2V0dGluZ3MuY3VzdG9tUHJvbXB0RGVzYyc6ICdQcm9tcHQgZGUgc2lzdGVtYSBwZXJzb25hbGl6YWRvIG9wY2lvbmFsIHBhcmEgYWRpY2lvbmFyIGEgdG9kYXMgYXMgc29saWNpdGFcdTAwRTdcdTAwRjVlcycsXG4gICAgJ3NldHRpbmdzLmN1c3RvbVByb21wdFBsYWNlaG9sZGVyJzogJ1ZvY1x1MDBFQSBlc3RcdTAwRTEgYWp1ZGFuZG8gYSBlZGl0YXIgbm90YXMgbWFya2Rvd24uLi4nLFxuICAgICdzZXR0aW5ncy5wcmVzZXJ2ZUN1cnNvcic6ICdQcmVzZXJ2YXIgcG9zaVx1MDBFN1x1MDBFM28gZG8gY3Vyc29yJyxcbiAgICAnc2V0dGluZ3MucHJlc2VydmVDdXJzb3JEZXNjJzogJ1RlbnRhciBtYW50ZXIgYSBwb3NpXHUwMEU3XHUwMEUzbyBkbyBjdXJzb3IgYXBcdTAwRjNzIGFwbGljYXIgYWx0ZXJhXHUwMEU3XHUwMEY1ZXMnLFxuICAgICdzZXR0aW5ncy5hdXRvQWNjZXB0Q2hhbmdlcyc6ICdBY2VpdGFyIGFsdGVyYVx1MDBFN1x1MDBGNWVzIGF1dG9tYXRpY2FtZW50ZScsXG4gICAgJ3NldHRpbmdzLmF1dG9BY2NlcHRDaGFuZ2VzRGVzYyc6ICdBcGxpY2FyIGFsdGVyYVx1MDBFN1x1MDBGNWVzIGF1dG9tYXRpY2FtZW50ZSBzZW0gbW9zdHJhciB2aXN1YWxpemFcdTAwRTdcdTAwRTNvICh1c2UgY29tIGNhdXRlbGEhKScsXG4gICAgJ3NldHRpbmdzLm1vZGVsJzogJ01vZGVsbycsXG4gICAgJ3NldHRpbmdzLm1vZGVsRGVzYyc6ICdTZWxlY2lvbmUgbyBtb2RlbG8gQ2xhdWRlIGEgdXNhcjogU29ubmV0IChlcXVpbGlicmFkbyksIE9wdXMgKG1haXMgY2FwYXopLCBvdSBIYWlrdSAobWFpcyByXHUwMEUxcGlkbykuIERlaXhlIHZhemlvIHBhcmEgdXNhciBvIG1vZGVsbyBzdWJhZ2VudCBwYWRyXHUwMEUzby4nLFxuICAgICdzZXR0aW5ncy5tb2RlbERlZmF1bHQnOiAnUGFkclx1MDBFM28gKG1vZGVsbyBzdWJhZ2VudCknLFxuICAgICdzZXR0aW5ncy5tb2RlbFNvbm5ldCc6ICdTb25uZXQgKGVxdWlsaWJyYWRvKScsXG4gICAgJ3NldHRpbmdzLm1vZGVsT3B1cyc6ICdPcHVzIChtYWlzIGNhcGF6KScsXG4gICAgJ3NldHRpbmdzLm1vZGVsSGFpa3UnOiAnSGFpa3UgKG1haXMgclx1MDBFMXBpZG8pJyxcbiAgICAnc2V0dGluZ3MudmF1bHRBY2Nlc3MnOiAnUGVybWl0aXIgYWNlc3NvIGFvIHZhdWx0IGNvbXBsZXRvJyxcbiAgICAnc2V0dGluZ3MudmF1bHRBY2Nlc3NEZXNjJzogJ1Blcm1pdGlyIHF1ZSBDbGF1ZGUgbGVpYS9wZXNxdWlzZSBvdXRyb3MgYXJxdWl2b3Mgbm8gc2V1IHZhdWx0IChuXHUwMEUzbyBhcGVuYXMgYSBub3RhIGF0dWFsKScsXG4gICAgJ3NldHRpbmdzLnBlcm1pc3Npb25sZXNzTW9kZSc6ICdIYWJpbGl0YXIgbW9kbyBzZW0gcGVybWlzc1x1MDBGNWVzJyxcbiAgICAnc2V0dGluZ3MucGVybWlzc2lvbmxlc3NNb2RlRGVzYyc6ICdQZXJtaXRpciBxdWUgQ2xhdWRlIGV4ZWN1dGUgYVx1MDBFN1x1MDBGNWVzIHNlbSBwZWRpciBwZXJtaXNzXHUwMEUzbyBhIGNhZGEgdmV6ICh1c2UgY29tIGNhdXRlbGEhIENsYXVkZSB0ZXJcdTAwRTEgY29udHJvbGUgdG90YWwpJyxcbiAgICAnc2V0dGluZ3MudGltZW91dCc6ICdUZW1wbyBsaW1pdGUgKHNlZ3VuZG9zKScsXG4gICAgJ3NldHRpbmdzLnRpbWVvdXREZXNjJzogJ1RlbXBvIG1cdTAwRTF4aW1vIHBhcmEgYWd1YXJkYXIgcmVzcG9zdGEgZG8gQ2xhdWRlIENvZGUgKDAgPSBzZW0gbGltaXRlKScsXG4gICAgJ3NldHRpbmdzLmN1c3RvbUFwaUNvbmZpZyc6ICdDb25maWd1cmFcdTAwRTdcdTAwRTNvIGRlIEFQSSBwZXJzb25hbGl6YWRhJyxcbiAgICAnc2V0dGluZ3MuY3VzdG9tQXBpQ29uZmlnRGVzYyc6ICdDb25maWd1cmUgZW5kcG9pbnRzIGRlIEFQSSBwZXJzb25hbGl6YWRvcyBwYXJhIHJlZ2lcdTAwRjVlcyBvbmRlIENsYXVkZSBuXHUwMEUzbyBlc3RcdTAwRTEgZGlzcG9uXHUwMEVEdmVsIGRpcmV0YW1lbnRlLiBEZWl4ZSB2YXppbyBwYXJhIHVzYXIgY29uZmlndXJhXHUwMEU3XHUwMEY1ZXMgcGFkclx1MDBFM28uJyxcbiAgICAnc2V0dGluZ3MuYXBpQmFzZVVybCc6ICdVUkwgYmFzZSBkYSBBUEknLFxuICAgICdzZXR0aW5ncy5hcGlCYXNlVXJsRGVzYyc6ICdVUkwgZG8gZW5kcG9pbnQgZGUgQVBJIHBlcnNvbmFsaXphZG8gKGV4LiwgaHR0cHM6Ly9hcGkua2ltaS5jb20vY29kaW5nLyknLFxuICAgICdzZXR0aW5ncy5hcGlBdXRoVG9rZW4nOiAnVG9rZW4gZGUgYXV0ZW50aWNhXHUwMEU3XHUwMEUzbyBkYSBBUEknLFxuICAgICdzZXR0aW5ncy5hcGlBdXRoVG9rZW5EZXNjJzogJ1Rva2VuIGRlIGF1dGVudGljYVx1MDBFN1x1MDBFM28gcGVyc29uYWxpemFkbyBwYXJhIG8gZW5kcG9pbnQgZGEgQVBJJyxcbiAgICAnc2V0dGluZ3MuYXBpQXV0aFRva2VuUGxhY2Vob2xkZXInOiAnSW5zaXJhIHNldSB0b2tlbiBkZSBBUEknLFxuICAgICdzZXR0aW5ncy5jdXN0b21Nb2RlbCc6ICdNb2RlbG8gcGVyc29uYWxpemFkbycsXG4gICAgJ3NldHRpbmdzLmN1c3RvbU1vZGVsRGVzYyc6ICdOb21lIGRvIG1vZGVsbyBwZXJzb25hbGl6YWRvIGEgdXNhciAoZXguLCBraW1pLWZvci1jb2RpbmcpLiBTdWJzdGl0dWkgYSBzZWxlXHUwMEU3XHUwMEUzbyBkZSBtb2RlbG8gYWNpbWEuJyxcbiAgICAnc2V0dGluZ3MuY3VzdG9tU21hbGxNb2RlbCc6ICdNb2RlbG8gcGVxdWVuby9yXHUwMEUxcGlkbyBwZXJzb25hbGl6YWRvJyxcbiAgICAnc2V0dGluZ3MuY3VzdG9tU21hbGxNb2RlbERlc2MnOiAnTm9tZSBkbyBtb2RlbG8gcGVyc29uYWxpemFkbyBwYXJhIG9wZXJhXHUwMEU3XHUwMEY1ZXMgclx1MDBFMXBpZGFzIChleC4sIGtpbWktZm9yLWNvZGluZyknLFxuICAgICdzZXR0aW5ncy5sYW5ndWFnZSc6ICdJZGlvbWEnLFxuICAgICdzZXR0aW5ncy5sYW5ndWFnZURlc2MnOiAnU2VsZWNpb25lIG8gaWRpb21hIGRhIGludGVyZmFjZScsXG59OyIsICIvKipcbiAqIEludGVybmF0aW9uYWxpemF0aW9uIChpMThuKSBtb2R1bGUgZm9yIENsYXVkZSBDb2RlIHBsdWdpblxuICovXG5cbmltcG9ydCB7IGVuLCBUcmFuc2xhdGlvbktleSB9IGZyb20gJy4vbG9jYWxlcy9lbic7XG5pbXBvcnQgeyB6aCB9IGZyb20gJy4vbG9jYWxlcy96aCc7XG5pbXBvcnQgeyBlcyB9IGZyb20gJy4vbG9jYWxlcy9lcyc7XG5pbXBvcnQgeyBkZSB9IGZyb20gJy4vbG9jYWxlcy9kZSc7XG5pbXBvcnQgeyBwdCB9IGZyb20gJy4vbG9jYWxlcy9wdCc7XG5cbmV4cG9ydCB0eXBlIExvY2FsZSA9ICdlbicgfCAnemgnIHwgJ2VzJyB8ICdkZScgfCAncHQnO1xuXG50eXBlIFRyYW5zbGF0aW9uTWFwID0gUmVjb3JkPFRyYW5zbGF0aW9uS2V5LCBzdHJpbmc+O1xuXG5jb25zdCB0cmFuc2xhdGlvbnM6IFJlY29yZDxMb2NhbGUsIFRyYW5zbGF0aW9uTWFwPiA9IHtcbiAgICBlbjogZW4gYXMgVHJhbnNsYXRpb25NYXAsXG4gICAgemg6IHpoIGFzIFRyYW5zbGF0aW9uTWFwLFxuICAgIGVzOiBlcyBhcyBUcmFuc2xhdGlvbk1hcCxcbiAgICBkZTogZGUgYXMgVHJhbnNsYXRpb25NYXAsXG4gICAgcHQ6IHB0IGFzIFRyYW5zbGF0aW9uTWFwLFxufTtcblxubGV0IGN1cnJlbnRMb2NhbGU6IExvY2FsZSA9ICdlbic7XG5cbi8qKlxuICogU2V0IHRoZSBjdXJyZW50IGxvY2FsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0TG9jYWxlKGxvY2FsZTogTG9jYWxlKTogdm9pZCB7XG4gICAgaWYgKHRyYW5zbGF0aW9uc1tsb2NhbGVdKSB7XG4gICAgICAgIGN1cnJlbnRMb2NhbGUgPSBsb2NhbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBbaTE4bl0gVW5rbm93biBsb2NhbGU6ICR7bG9jYWxlfSwgZmFsbGluZyBiYWNrIHRvICdlbidgKTtcbiAgICAgICAgY3VycmVudExvY2FsZSA9ICdlbic7XG4gICAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBsb2NhbGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExvY2FsZSgpOiBMb2NhbGUge1xuICAgIHJldHVybiBjdXJyZW50TG9jYWxlO1xufVxuXG4vKipcbiAqIEdldCBhdmFpbGFibGUgbG9jYWxlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXZhaWxhYmxlTG9jYWxlcygpOiB7IGNvZGU6IExvY2FsZTsgbmFtZTogc3RyaW5nIH1bXSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgeyBjb2RlOiAnZW4nLCBuYW1lOiAnRW5nbGlzaCcgfSxcbiAgICAgICAgeyBjb2RlOiAnemgnLCBuYW1lOiAnXHU0RTJEXHU2NTg3IChcdTdCODBcdTRGNTMpJyB9LFxuICAgICAgICB7IGNvZGU6ICdlcycsIG5hbWU6ICdFc3BhXHUwMEYxb2wnIH0sXG4gICAgICAgIHsgY29kZTogJ2RlJywgbmFtZTogJ0RldXRzY2gnIH0sXG4gICAgICAgIHsgY29kZTogJ3B0JywgbmFtZTogJ1BvcnR1Z3VcdTAwRUFzJyB9LFxuICAgIF07XG59XG5cbi8qKlxuICogVHJhbnNsYXRlIGEga2V5IHRvIHRoZSBjdXJyZW50IGxvY2FsZVxuICogQHBhcmFtIGtleSBUaGUgdHJhbnNsYXRpb24ga2V5XG4gKiBAcGFyYW0gcGFyYW1zIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHN0cmluZyBpbnRlcnBvbGF0aW9uXG4gKiBAcmV0dXJucyBUaGUgdHJhbnNsYXRlZCBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHQoa2V5OiBUcmFuc2xhdGlvbktleSwgcGFyYW1zPzogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVtYmVyPik6IHN0cmluZyB7XG4gICAgbGV0IHRleHQgPSB0cmFuc2xhdGlvbnNbY3VycmVudExvY2FsZV0/LltrZXldIHx8IHRyYW5zbGF0aW9uc1snZW4nXVtrZXldIHx8IGtleTtcblxuICAgIC8vIEhhbmRsZSBwYXJhbWV0ZXIgc3Vic3RpdHV0aW9uXG4gICAgaWYgKHBhcmFtcykge1xuICAgICAgICBPYmplY3QuZW50cmllcyhwYXJhbXMpLmZvckVhY2goKFtwYXJhbUtleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKG5ldyBSZWdFeHAoYFxcXFx7JHtwYXJhbUtleX1cXFxcfWAsICdnJyksIFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dDtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIGkxOG4gd2l0aCBzeXN0ZW0vT2JzaWRpYW4gbG9jYWxlIGRldGVjdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdEkxOG4ocHJlZmVycmVkTG9jYWxlPzogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHByZWZlcnJlZExvY2FsZSAmJiB0cmFuc2xhdGlvbnNbcHJlZmVycmVkTG9jYWxlIGFzIExvY2FsZV0pIHtcbiAgICAgICAgc2V0TG9jYWxlKHByZWZlcnJlZExvY2FsZSBhcyBMb2NhbGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVHJ5IHRvIGRldGVjdCBmcm9tIE9ic2lkaWFuJ3MgbG9jYWxlIG9yIHN5c3RlbVxuICAgIGNvbnN0IHN5c3RlbUxvY2FsZSA9IG5hdmlnYXRvci5sYW5ndWFnZT8udG9Mb3dlckNhc2UoKSB8fCAnJztcblxuICAgIGlmIChzeXN0ZW1Mb2NhbGUuc3RhcnRzV2l0aCgnemgnKSkge1xuICAgICAgICBzZXRMb2NhbGUoJ3poJyk7XG4gICAgfSBlbHNlIGlmIChzeXN0ZW1Mb2NhbGUuc3RhcnRzV2l0aCgnZXMnKSkge1xuICAgICAgICBzZXRMb2NhbGUoJ2VzJyk7XG4gICAgfSBlbHNlIGlmIChzeXN0ZW1Mb2NhbGUuc3RhcnRzV2l0aCgnZGUnKSkge1xuICAgICAgICBzZXRMb2NhbGUoJ2RlJyk7XG4gICAgfSBlbHNlIGlmIChzeXN0ZW1Mb2NhbGUuc3RhcnRzV2l0aCgncHQnKSkge1xuICAgICAgICBzZXRMb2NhbGUoJ3B0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2V0TG9jYWxlKCdlbicpO1xuICAgIH1cbn1cblxuLy8gUmUtZXhwb3J0IHR5cGVzXG5leHBvcnQgdHlwZSB7IFRyYW5zbGF0aW9uS2V5IH07IiwgIi8qKlxuICogVUkgQnVpbGRlciAtIEhhbmRsZXMgY3JlYXRpb24gb2YgVUkgZWxlbWVudHMgZm9yIHRoZSBDbGF1ZGUgQ29kZSB2aWV3XG4gKi9cblxuaW1wb3J0IHsgdCB9IGZyb20gJy4uL2kxOG4nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVJRWxlbWVudHMge1xuICAgIHByb21wdElucHV0OiBIVE1MVGV4dEFyZWFFbGVtZW50O1xuICAgIHJ1bkJ1dHRvbjogSFRNTEJ1dHRvbkVsZW1lbnQ7XG4gICAgY2FuY2VsQnV0dG9uOiBIVE1MQnV0dG9uRWxlbWVudDtcbiAgICBvdXRwdXRBcmVhOiBIVE1MRGl2RWxlbWVudDtcbiAgICByZXN1bHRBcmVhOiBIVE1MRGl2RWxlbWVudDtcbiAgICBwcmV2aWV3QXJlYTogSFRNTERpdkVsZW1lbnQ7XG4gICAgcHJldmlld0NvbnRlbnRDb250YWluZXI6IEhUTUxEaXZFbGVtZW50O1xuICAgIHByZXZpZXdUYWJzQ29udGFpbmVyOiBIVE1MRGl2RWxlbWVudDtcbiAgICBhcHBseUJ1dHRvbjogSFRNTEJ1dHRvbkVsZW1lbnQ7XG4gICAgcmVqZWN0QnV0dG9uOiBIVE1MQnV0dG9uRWxlbWVudDtcbiAgICBzZWxlY3RlZFRleHRPbmx5Q2hlY2tib3g6IEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgYXV0b0FjY2VwdENoZWNrYm94OiBIVE1MSW5wdXRFbGVtZW50O1xuICAgIGNvbnZlcnNhdGlvbmFsTW9kZUNoZWNrYm94OiBIVE1MSW5wdXRFbGVtZW50O1xuICAgIHN0YXR1c0luZGljYXRvcjogSFRNTERpdkVsZW1lbnQ7XG4gICAgc3RhdHVzVGV4dDogSFRNTFNwYW5FbGVtZW50O1xuICAgIGludGVyYWN0aXZlUHJvbXB0U2VjdGlvbjogSFRNTERpdkVsZW1lbnQ7XG4gICAgcGVybWlzc2lvbkFwcHJvdmFsU2VjdGlvbjogSFRNTERpdkVsZW1lbnQ7XG4gICAgYXBwcm92ZVBlcm1pc3Npb25CdXR0b246IEhUTUxCdXR0b25FbGVtZW50O1xuICAgIGRlbnlQZXJtaXNzaW9uQnV0dG9uOiBIVE1MQnV0dG9uRWxlbWVudDtcbiAgICBjdXJyZW50Tm90ZUxhYmVsOiBIVE1MRGl2RWxlbWVudDtcbiAgICBoaXN0b3J5TGlzdDogSFRNTFVMaXN0RWxlbWVudDtcbiAgICBjb25uZWN0aW9uU3RhdHVzQmFyPzogSFRNTERpdkVsZW1lbnQ7XG4gICAgY29ubmVjdGlvblN0YXR1c0ljb24/OiBIVE1MU3BhbkVsZW1lbnQ7XG4gICAgY29ubmVjdGlvblN0YXR1c1RleHQ/OiBIVE1MU3BhbkVsZW1lbnQ7XG59XG5cbmV4cG9ydCBjbGFzcyBVSUJ1aWxkZXIge1xuICAgIC8qKlxuICAgICAqIEJ1aWxkIHRoZSBoZWFkZXIgc2VjdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBidWlsZEhlYWRlcihjb250YWluZXI6IEhUTUxFbGVtZW50KTogSFRNTERpdkVsZW1lbnQge1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBjb250YWluZXIuY3JlYXRlRWwoJ2RpdicsIHsgY2xzOiAnY2xhdWRlLWNvZGUtaGVhZGVyJyB9KTtcbiAgICAgICAgY29uc3QgaGVhZGVyVGl0bGUgPSBoZWFkZXIuY3JlYXRlRWwoJ2RpdicsIHsgY2xzOiAnY2xhdWRlLWNvZGUtaGVhZGVyLXRpdGxlJyB9KTtcbiAgICAgICAgaGVhZGVyVGl0bGUuY3JlYXRlRWwoJ2g0JywgeyB0ZXh0OiB0KCdoZWFkZXIudGl0bGUnKSB9KTtcblxuICAgICAgICBjb25zdCBjdXJyZW50Tm90ZUxhYmVsID0gaGVhZGVyLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ2NsYXVkZS1jb2RlLWN1cnJlbnQtbm90ZScgfSk7XG4gICAgICAgIHJldHVybiBjdXJyZW50Tm90ZUxhYmVsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ1aWxkIHRoZSBpbnB1dCBzZWN0aW9uIHdpdGggcHJvbXB0IHRleHRhcmVhIGFuZCBvcHRpb25zXG4gICAgICovXG4gICAgc3RhdGljIGJ1aWxkSW5wdXRTZWN0aW9uKFxuICAgICAgICBjb250YWluZXI6IEhUTUxFbGVtZW50LFxuICAgICAgICBhdXRvQWNjZXB0RGVmYXVsdDogYm9vbGVhbixcbiAgICAgICAgb25SdW46ICgpID0+IHZvaWQsXG4gICAgICAgIG9uQ2FuY2VsOiAoKSA9PiB2b2lkXG4gICAgKToge1xuICAgICAgICBwcm9tcHRJbnB1dDogSFRNTFRleHRBcmVhRWxlbWVudDtcbiAgICAgICAgc2VsZWN0ZWRUZXh0T25seUNoZWNrYm94OiBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgICBhdXRvQWNjZXB0Q2hlY2tib3g6IEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICAgIGNvbnZlcnNhdGlvbmFsTW9kZUNoZWNrYm94OiBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgICBtb2RlbFNlbGVjdDogSFRNTFNlbGVjdEVsZW1lbnQ7XG4gICAgICAgIHJ1bkJ1dHRvbjogSFRNTEJ1dHRvbkVsZW1lbnQ7XG4gICAgICAgIGNhbmNlbEJ1dHRvbjogSFRNTEJ1dHRvbkVsZW1lbnQ7XG4gICAgfSB7XG4gICAgICAgIGNvbnN0IGlucHV0U2VjdGlvbiA9IGNvbnRhaW5lci5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdjbGF1ZGUtY29kZS1pbnB1dC1zZWN0aW9uJyB9KTtcblxuICAgICAgICAvLyBQcm9tcHQgdGV4dGFyZWFcbiAgICAgICAgaW5wdXRTZWN0aW9uLmNyZWF0ZUVsKCdsYWJlbCcsIHsgdGV4dDogdCgnaW5wdXQubGFiZWwnKSB9KTtcbiAgICAgICAgY29uc3QgcHJvbXB0SW5wdXQgPSBpbnB1dFNlY3Rpb24uY3JlYXRlRWwoJ3RleHRhcmVhJywge1xuICAgICAgICAgICAgY2xzOiAnY2xhdWRlLWNvZGUtcHJvbXB0LWlucHV0JyxcbiAgICAgICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogdCgnaW5wdXQucGxhY2Vob2xkZXInKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcHJvbXB0SW5wdXQucm93cyA9IDQ7XG5cbiAgICAgICAgLy8gT3B0aW9uc1xuICAgICAgICBjb25zdCBvcHRpb25zRGl2ID0gaW5wdXRTZWN0aW9uLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ2NsYXVkZS1jb2RlLW9wdGlvbnMnIH0pO1xuXG4gICAgICAgIC8vIENvbnZlcnNhdGlvbmFsIG1vZGUgY2hlY2tib3hcbiAgICAgICAgY29uc3QgY29udmVyc2F0aW9uYWxMYWJlbCA9IG9wdGlvbnNEaXYuY3JlYXRlRWwoJ2xhYmVsJywgeyBjbHM6ICdjbGF1ZGUtY29kZS1jaGVja2JveC1sYWJlbCcgfSk7XG4gICAgICAgIGNvbnN0IGNvbnZlcnNhdGlvbmFsTW9kZUNoZWNrYm94ID0gY29udmVyc2F0aW9uYWxMYWJlbC5jcmVhdGVFbCgnaW5wdXQnLCB7IHR5cGU6ICdjaGVja2JveCcgfSk7XG4gICAgICAgIGNvbnZlcnNhdGlvbmFsTGFiZWwuYXBwZW5kVGV4dCgnICcgKyB0KCdpbnB1dC5jb252ZXJzYXRpb25hbE1vZGUnKSk7XG4gICAgICAgIGNvbnZlcnNhdGlvbmFsTGFiZWwudGl0bGUgPSB0KCdpbnB1dC5jb252ZXJzYXRpb25hbE1vZGVUb29sdGlwJyk7XG5cbiAgICAgICAgLy8gU2VsZWN0ZWQgdGV4dCBvbmx5IGNoZWNrYm94XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkVGV4dExhYmVsID0gb3B0aW9uc0Rpdi5jcmVhdGVFbCgnbGFiZWwnLCB7IGNsczogJ2NsYXVkZS1jb2RlLWNoZWNrYm94LWxhYmVsJyB9KTtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRUZXh0T25seUNoZWNrYm94ID0gc2VsZWN0ZWRUZXh0TGFiZWwuY3JlYXRlRWwoJ2lucHV0JywgeyB0eXBlOiAnY2hlY2tib3gnIH0pO1xuICAgICAgICBzZWxlY3RlZFRleHRMYWJlbC5hcHBlbmRUZXh0KCcgJyArIHQoJ2lucHV0LnNlbGVjdGVkVGV4dE9ubHknKSk7XG5cbiAgICAgICAgLy8gQXV0by1hY2NlcHQgY2hhbmdlcyBjaGVja2JveFxuICAgICAgICBjb25zdCBhdXRvQWNjZXB0TGFiZWwgPSBvcHRpb25zRGl2LmNyZWF0ZUVsKCdsYWJlbCcsIHsgY2xzOiAnY2xhdWRlLWNvZGUtY2hlY2tib3gtbGFiZWwnIH0pO1xuICAgICAgICBjb25zdCBhdXRvQWNjZXB0Q2hlY2tib3ggPSBhdXRvQWNjZXB0TGFiZWwuY3JlYXRlRWwoJ2lucHV0JywgeyB0eXBlOiAnY2hlY2tib3gnIH0pO1xuICAgICAgICBhdXRvQWNjZXB0Q2hlY2tib3guY2hlY2tlZCA9IGF1dG9BY2NlcHREZWZhdWx0O1xuICAgICAgICBhdXRvQWNjZXB0TGFiZWwuYXBwZW5kVGV4dCgnICcgKyB0KCdpbnB1dC5hdXRvQWNjZXB0JykpO1xuXG4gICAgICAgIC8vIE1vZGVsIHNlbGVjdG9yXG4gICAgICAgIGNvbnN0IG1vZGVsU2VsZWN0Q29udGFpbmVyID0gb3B0aW9uc0Rpdi5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdjbGF1ZGUtY29kZS1tb2RlbC1zZWxlY3QnIH0pO1xuICAgICAgICBtb2RlbFNlbGVjdENvbnRhaW5lci5jcmVhdGVFbCgnbGFiZWwnLCB7IHRleHQ6IHQoJ2lucHV0Lm1vZGVsTGFiZWwnKSArICcgJywgY2xzOiAnY2xhdWRlLWNvZGUtbW9kZWwtbGFiZWwnIH0pO1xuICAgICAgICBjb25zdCBtb2RlbFNlbGVjdCA9IG1vZGVsU2VsZWN0Q29udGFpbmVyLmNyZWF0ZUVsKCdzZWxlY3QnLCB7IGNsczogJ2NsYXVkZS1jb2RlLW1vZGVsLWRyb3Bkb3duJyB9KTtcbiAgICAgICAgbW9kZWxTZWxlY3QuY3JlYXRlRWwoJ29wdGlvbicsIHsgdmFsdWU6ICcnLCB0ZXh0OiB0KCdpbnB1dC5tb2RlbERlZmF1bHQnKSB9KTtcbiAgICAgICAgbW9kZWxTZWxlY3QuY3JlYXRlRWwoJ29wdGlvbicsIHsgdmFsdWU6ICdzb25uZXQnLCB0ZXh0OiAnU29ubmV0JyB9KTtcbiAgICAgICAgbW9kZWxTZWxlY3QuY3JlYXRlRWwoJ29wdGlvbicsIHsgdmFsdWU6ICdvcHVzJywgdGV4dDogJ09wdXMnIH0pO1xuICAgICAgICBtb2RlbFNlbGVjdC5jcmVhdGVFbCgnb3B0aW9uJywgeyB2YWx1ZTogJ2hhaWt1JywgdGV4dDogJ0hhaWt1JyB9KTtcblxuICAgICAgICAvLyBCdXR0b24gY29udGFpbmVyXG4gICAgICAgIGNvbnN0IGJ1dHRvbkNvbnRhaW5lciA9IGlucHV0U2VjdGlvbi5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdjbGF1ZGUtY29kZS1idXR0b24tY29udGFpbmVyJyB9KTtcblxuICAgICAgICBjb25zdCBydW5CdXR0b24gPSBidXR0b25Db250YWluZXIuY3JlYXRlRWwoJ2J1dHRvbicsIHtcbiAgICAgICAgICAgIGNsczogJ21vZC1jdGEnLFxuICAgICAgICAgICAgdGV4dDogdCgnaW5wdXQucnVuQnV0dG9uJylcbiAgICAgICAgfSk7XG4gICAgICAgIHJ1bkJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uUnVuKTtcblxuICAgICAgICBjb25zdCBjYW5jZWxCdXR0b24gPSBidXR0b25Db250YWluZXIuY3JlYXRlRWwoJ2J1dHRvbicsIHtcbiAgICAgICAgICAgIHRleHQ6IHQoJ2lucHV0LmNhbmNlbEJ1dHRvbicpLFxuICAgICAgICAgICAgY2xzOiAnY2xhdWRlLWNvZGUtY2FuY2VsLWJ1dHRvbiBjbGF1ZGUtY29kZS1oaWRkZW4nXG4gICAgICAgIH0pO1xuICAgICAgICBjYW5jZWxCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbkNhbmNlbCk7XG5cbiAgICAgICAgLy8gTm90ZTogU3RhdHVzIGluZGljYXRvciBoYXMgYmVlbiBtb3ZlZCBpbnRvIFJlc3VsdCBzZWN0aW9uIChidWlsZFJlc3VsdFNlY3Rpb24pXG4gICAgICAgIC8vIE5vIGxvbmdlciBjcmVhdGluZyBhIHNlcGFyYXRlIHN0YXR1cyBpbmRpY2F0b3IgaGVyZVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm9tcHRJbnB1dCxcbiAgICAgICAgICAgIHNlbGVjdGVkVGV4dE9ubHlDaGVja2JveCxcbiAgICAgICAgICAgIGF1dG9BY2NlcHRDaGVja2JveCxcbiAgICAgICAgICAgIGNvbnZlcnNhdGlvbmFsTW9kZUNoZWNrYm94LFxuICAgICAgICAgICAgbW9kZWxTZWxlY3QsXG4gICAgICAgICAgICBydW5CdXR0b24sXG4gICAgICAgICAgICBjYW5jZWxCdXR0b25cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCdWlsZCB0aGUgY29tYmluZWQgYWdlbnQgc2VjdGlvbiAocGxhbiArIGFjdGl2aXR5IGluIHR3byBjb2x1bW5zKVxuICAgICAqL1xuICAgIHN0YXRpYyBidWlsZEFnZW50U2VjdGlvbihjb250YWluZXI6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgICAgIC8vIE1haW4gY29udGFpbmVyIGZvciB0aGUgZW50aXJlIGFnZW50IHNlY3Rpb25cbiAgICAgICAgY29uc3QgYWdlbnRDb250YWluZXIgPSBjb250YWluZXIuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgICAgICAgIGNsczogJ2NsYXVkZS1jb2RlLWFnZW50LWNvbnRhaW5lciBjbGF1ZGUtY29kZS1oaWRkZW4nXG4gICAgICAgIH0pO1xuICAgICAgICBhZ2VudENvbnRhaW5lci5pZCA9ICdjbGF1ZGUtY29kZS1hZ2VudC1jb250YWluZXInO1xuXG4gICAgICAgIC8vIExlZnQgY29sdW1uOiBDbGF1ZGUncyBQbGFuICh0b2RvcylcbiAgICAgICAgY29uc3QgcGxhbkNvbHVtbiA9IGFnZW50Q29udGFpbmVyLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ2NsYXVkZS1jb2RlLWFnZW50LWNvbHVtbiBjbGF1ZGUtY29kZS1wbGFuLWNvbHVtbiBjbGF1ZGUtY29kZS1oaWRkZW4nIH0pO1xuICAgICAgICAvLyBIaWRkZW4gYnkgZGVmYXVsdCAtIG9ubHkgc2hvd24gd2hlbiB0aGVyZSdzIGEgcGxhblxuXG4gICAgICAgIGNvbnN0IHBsYW5IZWFkZXIgPSBwbGFuQ29sdW1uLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ2NsYXVkZS1jb2RlLWFnZW50LWNvbHVtbi1oZWFkZXInIH0pO1xuICAgICAgICBwbGFuSGVhZGVyLmNyZWF0ZUVsKCdzcGFuJywgeyB0ZXh0OiAnXHVEODNEXHVEQ0NCICcgKyB0KCdhZ2VudC5wbGFuVGl0bGUnKSB9KTtcblxuICAgICAgICBwbGFuQ29sdW1uLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICAgICAgICBjbHM6ICdjbGF1ZGUtY29kZS10b2RvLWxpc3QgY2xhdWRlLWNvZGUtaGlkZGVuJyxcbiAgICAgICAgICAgIGF0dHI6IHsgaWQ6ICdjbGF1ZGUtY29kZS10b2RvLWxpc3QnIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEhpZGRlbiBieSBkZWZhdWx0XG5cbiAgICAgICAgY29uc3QgZW1wdHlQbGFuTWVzc2FnZSA9IHBsYW5Db2x1bW4uY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgICAgICAgIGNsczogJ2NsYXVkZS1jb2RlLWVtcHR5LW1lc3NhZ2UgY2xhdWRlLWNvZGUtaGlkZGVuJyxcbiAgICAgICAgICAgIHRleHQ6IHQoJ2FnZW50Lm5vUGxhbicpXG4gICAgICAgIH0pO1xuICAgICAgICBlbXB0eVBsYW5NZXNzYWdlLmlkID0gJ2NsYXVkZS1jb2RlLWVtcHR5LXBsYW4nO1xuICAgICAgICAvLyBIaWRkZW4gYnkgZGVmYXVsdFxuXG4gICAgICAgIC8vIFJpZ2h0IGNvbHVtbjogQWdlbnQgQWN0aXZpdHkgKHRvb2wgZXhlY3V0aW9ucylcbiAgICAgICAgY29uc3QgYWN0aXZpdHlDb2x1bW4gPSBhZ2VudENvbnRhaW5lci5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdjbGF1ZGUtY29kZS1hZ2VudC1jb2x1bW4gY2xhdWRlLWNvZGUtYWN0aXZpdHktY29sdW1uIGNsYXVkZS1jb2RlLWhpZGRlbicgfSk7XG4gICAgICAgIC8vIEhpZGRlbiBieSBkZWZhdWx0IHVudGlsIHN0ZXBzIGFyZSBhZGRlZFxuXG4gICAgICAgIGNvbnN0IGFjdGl2aXR5SGVhZGVyID0gYWN0aXZpdHlDb2x1bW4uY3JlYXRlRWwoJ2RpdicsIHsgY2xzOiAnY2xhdWRlLWNvZGUtYWdlbnQtY29sdW1uLWhlYWRlciBjb2xsYXBzaWJsZS1oZWFkZXInIH0pO1xuICAgICAgICBjb25zdCBhY3Rpdml0eVRpdGxlID0gYWN0aXZpdHlIZWFkZXIuY3JlYXRlRWwoJ3NwYW4nLCB7IGNsczogJ2NvbGxhcHNpYmxlLXRpdGxlJyB9KTtcbiAgICAgICAgYWN0aXZpdHlUaXRsZS5jcmVhdGVFbCgnc3BhbicsIHsgY2xzOiAnY29sbGFwc2UtaW5kaWNhdG9yJywgdGV4dDogJ1x1MjVCQyAnIH0pO1xuICAgICAgICBhY3Rpdml0eVRpdGxlLmFwcGVuZFRleHQodCgnYWdlbnQuYWN0aXZpdHlUaXRsZScpKTtcblxuICAgICAgICBjb25zdCBhY3Rpdml0eVN0ZXBzID0gYWN0aXZpdHlDb2x1bW4uY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgICAgICAgIGNsczogJ2NsYXVkZS1jb2RlLWFnZW50LXN0ZXBzIGNvbGxhcHNpYmxlLWNvbnRlbnQnLFxuICAgICAgICAgICAgYXR0cjogeyBpZDogJ2NsYXVkZS1jb2RlLWFnZW50LXN0ZXBzJyB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFkZCBjbGljayBoYW5kbGVyIHRvIHRvZ2dsZSBjb2xsYXBzZVxuICAgICAgICBhY3Rpdml0eUhlYWRlci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzQ29sbGFwc2VkID0gYWN0aXZpdHlTdGVwcy5oYXNDbGFzcygnY2xhdWRlLWNvZGUtaGlkZGVuJyk7XG4gICAgICAgICAgICBhY3Rpdml0eVN0ZXBzLnRvZ2dsZUNsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nLCAhaXNDb2xsYXBzZWQpO1xuICAgICAgICAgICAgY29uc3QgaW5kaWNhdG9yID0gYWN0aXZpdHlIZWFkZXIucXVlcnlTZWxlY3RvcignLmNvbGxhcHNlLWluZGljYXRvcicpO1xuICAgICAgICAgICAgaWYgKGluZGljYXRvcikge1xuICAgICAgICAgICAgICAgIGluZGljYXRvci50ZXh0Q29udGVudCA9IGlzQ29sbGFwc2VkID8gJ1x1MjVCQyAnIDogJ1x1MjVCNiAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVG9nZ2xlIGNvbGxhcHNlZCBjbGFzcyBvbiBjb250YWluZXJcbiAgICAgICAgICAgIGFnZW50Q29udGFpbmVyLnRvZ2dsZUNsYXNzKCdjb2xsYXBzZWQnLCAhaXNDb2xsYXBzZWQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCdWlsZCB0aGUgaW50ZXJhY3RpdmUgcHJvbXB0IHNlY3Rpb24gKGZvciBmdXR1cmUgdXNlKVxuICAgICAqL1xuICAgIHN0YXRpYyBidWlsZEludGVyYWN0aXZlUHJvbXB0U2VjdGlvbihcbiAgICAgICAgY29udGFpbmVyOiBIVE1MRWxlbWVudCxcbiAgICAgICAgb25SZXNwb25kOiAocmVzcG9uc2U6IHN0cmluZykgPT4gdm9pZFxuICAgICk6IEhUTUxEaXZFbGVtZW50IHtcbiAgICAgICAgY29uc3QgaW50ZXJhY3RpdmVQcm9tcHRTZWN0aW9uID0gY29udGFpbmVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICAgICAgICBjbHM6ICdjbGF1ZGUtY29kZS1pbnRlcmFjdGl2ZS1wcm9tcHQgY2xhdWRlLWNvZGUtaGlkZGVuJ1xuICAgICAgICB9KTtcbiAgICAgICAgaW50ZXJhY3RpdmVQcm9tcHRTZWN0aW9uLmlkID0gJ2NsYXVkZS1jb2RlLWludGVyYWN0aXZlLXByb21wdCc7XG5cbiAgICAgICAgaW50ZXJhY3RpdmVQcm9tcHRTZWN0aW9uLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICAgICAgICBjbHM6ICdpbnRlcmFjdGl2ZS1wcm9tcHQtaGVhZGVyJyxcbiAgICAgICAgICAgIHRleHQ6ICdcdTI3NTMgJyArIHQoJ2ludGVyYWN0aXZlLmhlYWRlcicpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGludGVyYWN0aXZlUHJvbXB0U2VjdGlvbi5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgICAgICAgY2xzOiAnaW50ZXJhY3RpdmUtcHJvbXB0LXF1ZXN0aW9uJyxcbiAgICAgICAgICAgIGF0dHI6IHsgaWQ6ICdpbnRlcmFjdGl2ZS1wcm9tcHQtcXVlc3Rpb24nIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcHJvbXB0QnV0dG9ucyA9IGludGVyYWN0aXZlUHJvbXB0U2VjdGlvbi5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgICAgICAgY2xzOiAnaW50ZXJhY3RpdmUtcHJvbXB0LWJ1dHRvbnMnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHllc0J1dHRvbiA9IHByb21wdEJ1dHRvbnMuY3JlYXRlRWwoJ2J1dHRvbicsIHtcbiAgICAgICAgICAgIGNsczogJ21vZC1jdGEnLFxuICAgICAgICAgICAgdGV4dDogJ1x1MjcxMyAnICsgdCgnaW50ZXJhY3RpdmUueWVzQnV0dG9uJylcbiAgICAgICAgfSk7XG4gICAgICAgIHllc0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IG9uUmVzcG9uZCgneWVzJykpO1xuXG4gICAgICAgIGNvbnN0IG5vQnV0dG9uID0gcHJvbXB0QnV0dG9ucy5jcmVhdGVFbCgnYnV0dG9uJywge1xuICAgICAgICAgICAgdGV4dDogJ1x1MjcxNyAnICsgdCgnaW50ZXJhY3RpdmUubm9CdXR0b24nKVxuICAgICAgICB9KTtcbiAgICAgICAgbm9CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiBvblJlc3BvbmQoJ25vJykpO1xuXG4gICAgICAgIGNvbnN0IGN1c3RvbVJlc3BvbnNlSW5wdXQgPSBpbnRlcmFjdGl2ZVByb21wdFNlY3Rpb24uY3JlYXRlRWwoJ2lucHV0Jywge1xuICAgICAgICAgICAgY2xzOiAnaW50ZXJhY3RpdmUtcHJvbXB0LWlucHV0JyxcbiAgICAgICAgICAgIGF0dHI6IHtcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogdCgnaW50ZXJhY3RpdmUuY3VzdG9tUGxhY2Vob2xkZXInKSxcbiAgICAgICAgICAgICAgICBpZDogJ2ludGVyYWN0aXZlLXByb21wdC1pbnB1dCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGN1c3RvbVJlc3BvbnNlSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZS5rZXkgPT09ICdFbnRlcicpIHtcbiAgICAgICAgICAgICAgICBvblJlc3BvbmQoY3VzdG9tUmVzcG9uc2VJbnB1dC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBpbnRlcmFjdGl2ZVByb21wdFNlY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnVpbGQgdGhlIHBlcm1pc3Npb24gYXBwcm92YWwgc2VjdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBidWlsZFBlcm1pc3Npb25BcHByb3ZhbFNlY3Rpb24oXG4gICAgICAgIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsXG4gICAgICAgIG9uQXBwcm92ZTogKCkgPT4gdm9pZCxcbiAgICAgICAgb25EZW55OiAoKSA9PiB2b2lkXG4gICAgKToge1xuICAgICAgICBwZXJtaXNzaW9uQXBwcm92YWxTZWN0aW9uOiBIVE1MRGl2RWxlbWVudDtcbiAgICAgICAgYXBwcm92ZVBlcm1pc3Npb25CdXR0b246IEhUTUxCdXR0b25FbGVtZW50O1xuICAgICAgICBkZW55UGVybWlzc2lvbkJ1dHRvbjogSFRNTEJ1dHRvbkVsZW1lbnQ7XG4gICAgfSB7XG4gICAgICAgIGNvbnN0IHBlcm1pc3Npb25BcHByb3ZhbFNlY3Rpb24gPSBjb250YWluZXIuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgICAgICAgIGNsczogJ2NsYXVkZS1jb2RlLXBlcm1pc3Npb24tYXBwcm92YWwgY2xhdWRlLWNvZGUtaGlkZGVuJ1xuICAgICAgICB9KTtcbiAgICAgICAgcGVybWlzc2lvbkFwcHJvdmFsU2VjdGlvbi5pZCA9ICdjbGF1ZGUtY29kZS1wZXJtaXNzaW9uLWFwcHJvdmFsJztcblxuICAgICAgICBwZXJtaXNzaW9uQXBwcm92YWxTZWN0aW9uLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICAgICAgICBjbHM6ICdwZXJtaXNzaW9uLWFwcHJvdmFsLWhlYWRlcicsXG4gICAgICAgICAgICB0ZXh0OiAnXHVEODNEXHVERDEwICcgKyB0KCdwZXJtaXNzaW9uLmhlYWRlcicpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBlcm1pc3Npb25BcHByb3ZhbFNlY3Rpb24uY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgICAgICAgIGNsczogJ3Blcm1pc3Npb24tYXBwcm92YWwtbWVzc2FnZScsXG4gICAgICAgICAgICB0ZXh0OiB0KCdwZXJtaXNzaW9uLm1lc3NhZ2UnKVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBhcHByb3ZhbEJ1dHRvbnMgPSBwZXJtaXNzaW9uQXBwcm92YWxTZWN0aW9uLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICAgICAgICBjbHM6ICdwZXJtaXNzaW9uLWFwcHJvdmFsLWJ1dHRvbnMnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGFwcHJvdmVQZXJtaXNzaW9uQnV0dG9uID0gYXBwcm92YWxCdXR0b25zLmNyZWF0ZUVsKCdidXR0b24nLCB7XG4gICAgICAgICAgICBjbHM6ICdtb2QtY3RhJyxcbiAgICAgICAgICAgIHRleHQ6ICdcdTI3MTMgJyArIHQoJ3Blcm1pc3Npb24uYXBwcm92ZUJ1dHRvbicpXG4gICAgICAgIH0pO1xuICAgICAgICBhcHByb3ZlUGVybWlzc2lvbkJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQXBwcm92ZSk7XG5cbiAgICAgICAgY29uc3QgZGVueVBlcm1pc3Npb25CdXR0b24gPSBhcHByb3ZhbEJ1dHRvbnMuY3JlYXRlRWwoJ2J1dHRvbicsIHtcbiAgICAgICAgICAgIGNsczogJ21vZC13YXJuaW5nJyxcbiAgICAgICAgICAgIHRleHQ6ICdcdTI3MTcgJyArIHQoJ3Blcm1pc3Npb24uZGVueUJ1dHRvbicpXG4gICAgICAgIH0pO1xuICAgICAgICBkZW55UGVybWlzc2lvbkJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uRGVueSk7XG5cbiAgICAgICAgcmV0dXJuIHsgcGVybWlzc2lvbkFwcHJvdmFsU2VjdGlvbiwgYXBwcm92ZVBlcm1pc3Npb25CdXR0b24sIGRlbnlQZXJtaXNzaW9uQnV0dG9uIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnVpbGQgdGhlIHJlc3VsdCBzZWN0aW9uIChmb3Igbm9uLWVkaXQgcmVzcG9uc2VzKVxuICAgICAqL1xuICAgIHN0YXRpYyBidWlsZFJlc3VsdFNlY3Rpb24oY29udGFpbmVyOiBIVE1MRWxlbWVudCk6IHsgcmVzdWx0QXJlYTogSFRNTERpdkVsZW1lbnQ7IHN0YXR1c0FyZWE6IEhUTUxEaXZFbGVtZW50OyBzdGF0dXNUZXh0OiBIVE1MU3BhbkVsZW1lbnQ7IGxhc3RQcm9tcHRBcmVhOiBIVE1MRGl2RWxlbWVudCB9IHtcbiAgICAgICAgY29uc3QgcmVzdWx0U2VjdGlvbiA9IGNvbnRhaW5lci5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdjbGF1ZGUtY29kZS1yZXN1bHQtc2VjdGlvbiBjbGF1ZGUtY29kZS1oaWRkZW4nIH0pO1xuICAgICAgICByZXN1bHRTZWN0aW9uLmlkID0gJ2NsYXVkZS1jb2RlLXJlc3VsdC1zZWN0aW9uJztcblxuICAgICAgICBjb25zdCByZXN1bHRIZWFkZXIgPSByZXN1bHRTZWN0aW9uLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ2NsYXVkZS1jb2RlLXJlc3VsdC1oZWFkZXIgY29sbGFwc2libGUtaGVhZGVyJyB9KTtcbiAgICAgICAgY29uc3QgaGVhZGVyVGl0bGUgPSByZXN1bHRIZWFkZXIuY3JlYXRlRWwoJ3NwYW4nLCB7IGNsczogJ2NvbGxhcHNpYmxlLXRpdGxlJyB9KTtcbiAgICAgICAgaGVhZGVyVGl0bGUuY3JlYXRlRWwoJ3NwYW4nLCB7IGNsczogJ2NvbGxhcHNlLWluZGljYXRvcicsIHRleHQ6ICdcdTI1QkMgJyB9KTtcbiAgICAgICAgaGVhZGVyVGl0bGUuYXBwZW5kVGV4dCh0KCdyZXN1bHQudGl0bGUnKSk7XG5cbiAgICAgICAgY29uc3QgY29udGVudFdyYXBwZXIgPSByZXN1bHRTZWN0aW9uLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ2NvbGxhcHNpYmxlLWNvbnRlbnQnIH0pO1xuXG4gICAgICAgIC8vIExhc3QgcHJvbXB0IGFyZWEgKHNob3dzIHdoYXQgdGhlIHVzZXIgYXNrZWQpXG4gICAgICAgIGNvbnN0IGxhc3RQcm9tcHRBcmVhID0gY29udGVudFdyYXBwZXIuY3JlYXRlRWwoJ2RpdicsIHsgY2xzOiAnY2xhdWRlLWNvZGUtbGFzdC1wcm9tcHQgY2xhdWRlLWNvZGUtaGlkZGVuJyB9KTtcbiAgICAgICAgbGFzdFByb21wdEFyZWEuaWQgPSAnY2xhdWRlLWNvZGUtbGFzdC1wcm9tcHQnO1xuXG4gICAgICAgIC8vIFN0YXR1cyBhcmVhIChzaG93biBkdXJpbmcgcHJvY2Vzc2luZylcbiAgICAgICAgY29uc3Qgc3RhdHVzQXJlYSA9IGNvbnRlbnRXcmFwcGVyLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ2NsYXVkZS1jb2RlLXN0YXR1cy1hcmVhIGNsYXVkZS1jb2RlLWhpZGRlbicgfSk7XG5cbiAgICAgICAgY29uc3Qgc3RhdHVzVGV4dENvbnRhaW5lciA9IHN0YXR1c0FyZWEuY3JlYXRlRWwoJ2RpdicsIHsgY2xzOiAnY2xhdWRlLWNvZGUtc3RhdHVzLXRleHQnIH0pO1xuICAgICAgICBzdGF0dXNUZXh0Q29udGFpbmVyLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ2NsYXVkZS1jb2RlLXN0YXR1cy1zcGlubmVyJyB9KTtcbiAgICAgICAgY29uc3Qgc3RhdHVzVGV4dCA9IHN0YXR1c1RleHRDb250YWluZXIuY3JlYXRlRWwoJ3NwYW4nKTtcblxuICAgICAgICBjb25zdCBwcm9ncmVzc0JhckNvbnRhaW5lciA9IHN0YXR1c0FyZWEuY3JlYXRlRWwoJ2RpdicsIHsgY2xzOiAnY2xhdWRlLWNvZGUtcHJvZ3Jlc3MtYmFyLWNvbnRhaW5lcicgfSk7XG4gICAgICAgIHByb2dyZXNzQmFyQ29udGFpbmVyLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ2NsYXVkZS1jb2RlLXByb2dyZXNzLWJhcicgfSk7XG5cbiAgICAgICAgLy8gUmVzdWx0IGFyZWEgKHNob3duIHdoZW4gdGhlcmUncyBhIHJlc3VsdClcbiAgICAgICAgY29uc3QgcmVzdWx0QXJlYSA9IGNvbnRlbnRXcmFwcGVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICAgICAgICBjbHM6ICdjbGF1ZGUtY29kZS1yZXN1bHQtYXJlYSBtYXJrZG93bi1yZW5kZXJlZCBjbGF1ZGUtY29kZS1oaWRkZW4nXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFkZCBjbGljayBoYW5kbGVyIHRvIHRvZ2dsZSBjb2xsYXBzZVxuICAgICAgICByZXN1bHRIZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc0NvbGxhcHNlZCA9IGNvbnRlbnRXcmFwcGVyLmhhc0NsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgICAgIGNvbnRlbnRXcmFwcGVyLnRvZ2dsZUNsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nLCAhaXNDb2xsYXBzZWQpO1xuICAgICAgICAgICAgY29uc3QgaW5kaWNhdG9yID0gcmVzdWx0SGVhZGVyLnF1ZXJ5U2VsZWN0b3IoJy5jb2xsYXBzZS1pbmRpY2F0b3InKTtcbiAgICAgICAgICAgIGlmIChpbmRpY2F0b3IpIHtcbiAgICAgICAgICAgICAgICBpbmRpY2F0b3IudGV4dENvbnRlbnQgPSBpc0NvbGxhcHNlZCA/ICdcdTI1QkMgJyA6ICdcdTI1QjYgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRvZ2dsZSBjb2xsYXBzZWQgY2xhc3Mgb24gc2VjdGlvblxuICAgICAgICAgICAgcmVzdWx0U2VjdGlvbi50b2dnbGVDbGFzcygnY29sbGFwc2VkJywgIWlzQ29sbGFwc2VkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0QXJlYSwgc3RhdHVzQXJlYSwgc3RhdHVzVGV4dCwgbGFzdFByb21wdEFyZWEgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCdWlsZCB0aGUgb3V0cHV0IHNlY3Rpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgYnVpbGRPdXRwdXRTZWN0aW9uKGNvbnRhaW5lcjogSFRNTEVsZW1lbnQpOiB7IG91dHB1dEFyZWE6IEhUTUxEaXZFbGVtZW50OyBvdXRwdXRTZWN0aW9uOiBIVE1MRGl2RWxlbWVudCB9IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0U2VjdGlvbiA9IGNvbnRhaW5lci5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdjbGF1ZGUtY29kZS1vdXRwdXQtc2VjdGlvbiBjbGF1ZGUtY29kZS1oaWRkZW4nIH0pO1xuICAgICAgICBjb25zdCBvdXRwdXRIZWFkZXIgPSBvdXRwdXRTZWN0aW9uLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ2NsYXVkZS1jb2RlLW91dHB1dC1oZWFkZXIgY29sbGFwc2libGUtaGVhZGVyJyB9KTtcblxuICAgICAgICBjb25zdCBoZWFkZXJUaXRsZSA9IG91dHB1dEhlYWRlci5jcmVhdGVFbCgnc3BhbicsIHsgY2xzOiAnY29sbGFwc2libGUtdGl0bGUnIH0pO1xuICAgICAgICAvLyBTdGFydCBjb2xsYXBzZWQgYnkgZGVmYXVsdFxuICAgICAgICBoZWFkZXJUaXRsZS5jcmVhdGVFbCgnc3BhbicsIHsgY2xzOiAnY29sbGFwc2UtaW5kaWNhdG9yJywgdGV4dDogJ1x1MjVCNiAnIH0pO1xuICAgICAgICBoZWFkZXJUaXRsZS5hcHBlbmRUZXh0KHQoJ291dHB1dC50aXRsZScpKTtcblxuICAgICAgICAvLyBTdGFydCBjb2xsYXBzZWQgYnkgZGVmYXVsdFxuICAgICAgICBjb25zdCBvdXRwdXRBcmVhID0gb3V0cHV0U2VjdGlvbi5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgICAgICAgY2xzOiAnY2xhdWRlLWNvZGUtb3V0cHV0LWFyZWEgY29sbGFwc2libGUtY29udGVudCBjbGF1ZGUtY29kZS1oaWRkZW4nXG4gICAgICAgIH0pO1xuICAgICAgICBvdXRwdXRTZWN0aW9uLmFkZENsYXNzKCdjb2xsYXBzZWQnKTtcblxuICAgICAgICAvLyBUb2dnbGUgb3V0cHV0IHZpc2liaWxpdHkgd2hlbiBjbGlja2luZyBoZWFkZXJcbiAgICAgICAgb3V0cHV0SGVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNDb2xsYXBzZWQgPSBvdXRwdXRBcmVhLmhhc0NsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgICAgIG91dHB1dEFyZWEudG9nZ2xlQ2xhc3MoJ2NsYXVkZS1jb2RlLWhpZGRlbicsICFpc0NvbGxhcHNlZCk7XG4gICAgICAgICAgICBjb25zdCBpbmRpY2F0b3IgPSBvdXRwdXRIZWFkZXIucXVlcnlTZWxlY3RvcignLmNvbGxhcHNlLWluZGljYXRvcicpO1xuICAgICAgICAgICAgaWYgKGluZGljYXRvcikge1xuICAgICAgICAgICAgICAgIGluZGljYXRvci50ZXh0Q29udGVudCA9IGlzQ29sbGFwc2VkID8gJ1x1MjVCQyAnIDogJ1x1MjVCNiAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVG9nZ2xlIGNvbGxhcHNlZCBjbGFzcyBvbiBzZWN0aW9uXG4gICAgICAgICAgICBvdXRwdXRTZWN0aW9uLnRvZ2dsZUNsYXNzKCdjb2xsYXBzZWQnLCAhaXNDb2xsYXBzZWQpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4geyBvdXRwdXRBcmVhLCBvdXRwdXRTZWN0aW9uIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnVpbGQgdGhlIHByZXZpZXcgc2VjdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBidWlsZFByZXZpZXdTZWN0aW9uKFxuICAgICAgICBjb250YWluZXI6IEhUTUxFbGVtZW50LFxuICAgICAgICBvbkFwcGx5OiAoKSA9PiB2b2lkLFxuICAgICAgICBvblJlamVjdDogKCkgPT4gdm9pZFxuICAgICk6IHtcbiAgICAgICAgcHJldmlld0FyZWE6IEhUTUxEaXZFbGVtZW50O1xuICAgICAgICBwcmV2aWV3Q29udGVudENvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQ7XG4gICAgICAgIHByZXZpZXdUYWJzQ29udGFpbmVyOiBIVE1MRGl2RWxlbWVudDtcbiAgICAgICAgYXBwbHlCdXR0b246IEhUTUxCdXR0b25FbGVtZW50O1xuICAgICAgICByZWplY3RCdXR0b246IEhUTUxCdXR0b25FbGVtZW50O1xuICAgIH0ge1xuICAgICAgICBjb25zdCBwcmV2aWV3U2VjdGlvbiA9IGNvbnRhaW5lci5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdjbGF1ZGUtY29kZS1wcmV2aWV3LXNlY3Rpb24gY2xhdWRlLWNvZGUtaGlkZGVuJyB9KTtcbiAgICAgICAgcHJldmlld1NlY3Rpb24uaWQgPSAnY2xhdWRlLWNvZGUtcHJldmlldy1zZWN0aW9uJztcblxuICAgICAgICBjb25zdCBwcmV2aWV3SGVhZGVyID0gcHJldmlld1NlY3Rpb24uY3JlYXRlRWwoJ2RpdicsIHsgY2xzOiAnY2xhdWRlLWNvZGUtcHJldmlldy1oZWFkZXIgY29sbGFwc2libGUtaGVhZGVyJyB9KTtcbiAgICAgICAgY29uc3QgaGVhZGVyVGl0bGUgPSBwcmV2aWV3SGVhZGVyLmNyZWF0ZUVsKCdzcGFuJywgeyBjbHM6ICdjb2xsYXBzaWJsZS10aXRsZScgfSk7XG4gICAgICAgIGhlYWRlclRpdGxlLmNyZWF0ZUVsKCdzcGFuJywgeyBjbHM6ICdjb2xsYXBzZS1pbmRpY2F0b3InLCB0ZXh0OiAnXHUyNUJDICcgfSk7XG4gICAgICAgIGhlYWRlclRpdGxlLmFwcGVuZFRleHQodCgncHJldmlldy50aXRsZScpKTtcblxuICAgICAgICBjb25zdCBwcmV2aWV3Q29udGVudCA9IHByZXZpZXdTZWN0aW9uLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ2NsYXVkZS1jb2RlLXByZXZpZXctY29udGVudC13cmFwcGVyIGNvbGxhcHNpYmxlLWNvbnRlbnQnIH0pO1xuXG4gICAgICAgIC8vIFRhYnMgY29udGFpbmVyXG4gICAgICAgIGNvbnN0IHByZXZpZXdUYWJzQ29udGFpbmVyID0gcHJldmlld0NvbnRlbnQuY3JlYXRlRWwoJ2RpdicsIHsgY2xzOiAnY2xhdWRlLWNvZGUtcHJldmlldy10YWJzJyB9KTtcblxuICAgICAgICBjb25zdCByYXdUYWIgPSBwcmV2aWV3VGFic0NvbnRhaW5lci5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdwcmV2aWV3LXRhYicsIHRleHQ6IHQoJ3ByZXZpZXcudGFiUmF3JykgfSk7XG4gICAgICAgIGNvbnN0IGRpZmZUYWIgPSBwcmV2aWV3VGFic0NvbnRhaW5lci5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdwcmV2aWV3LXRhYiBhY3RpdmUnLCB0ZXh0OiB0KCdwcmV2aWV3LnRhYkRpZmYnKSB9KTtcbiAgICAgICAgY29uc3QgcmVuZGVyZWRUYWIgPSBwcmV2aWV3VGFic0NvbnRhaW5lci5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdwcmV2aWV3LXRhYicsIHRleHQ6IHQoJ3ByZXZpZXcudGFiUmVuZGVyZWQnKSB9KTtcblxuICAgICAgICAvLyBDb250ZW50IGNvbnRhaW5lciB0aGF0IGhvbGRzIGFsbCB2aWV3c1xuICAgICAgICBjb25zdCBwcmV2aWV3Q29udGVudENvbnRhaW5lciA9IHByZXZpZXdDb250ZW50LmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ2NsYXVkZS1jb2RlLXByZXZpZXctY29udGVudC1jb250YWluZXInIH0pO1xuXG4gICAgICAgIC8vIFJhdyBwcmV2aWV3IGFyZWEgKHNob3duIGJ5IGRlZmF1bHQpXG4gICAgICAgIGNvbnN0IHByZXZpZXdBcmVhID0gcHJldmlld0NvbnRlbnRDb250YWluZXIuY3JlYXRlRWwoJ2RpdicsIHsgY2xzOiAnY2xhdWRlLWNvZGUtcHJldmlldy1hcmVhJyB9KTtcblxuICAgICAgICBjb25zdCBwcmV2aWV3QnV0dG9ucyA9IHByZXZpZXdDb250ZW50LmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ2NsYXVkZS1jb2RlLXByZXZpZXctYnV0dG9ucycgfSk7XG5cbiAgICAgICAgY29uc3QgYXBwbHlCdXR0b24gPSBwcmV2aWV3QnV0dG9ucy5jcmVhdGVFbCgnYnV0dG9uJywge1xuICAgICAgICAgICAgY2xzOiAnbW9kLWN0YScsXG4gICAgICAgICAgICB0ZXh0OiAnXHUyNzEzICcgKyB0KCdwcmV2aWV3LmFwcGx5QnV0dG9uJylcbiAgICAgICAgfSk7XG4gICAgICAgIGFwcGx5QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25BcHBseSk7XG5cbiAgICAgICAgY29uc3QgcmVqZWN0QnV0dG9uID0gcHJldmlld0J1dHRvbnMuY3JlYXRlRWwoJ2J1dHRvbicsIHtcbiAgICAgICAgICAgIGNsczogJ21vZC13YXJuaW5nJyxcbiAgICAgICAgICAgIHRleHQ6ICdcdTI3MTcgJyArIHQoJ3ByZXZpZXcucmVqZWN0QnV0dG9uJylcbiAgICAgICAgfSk7XG4gICAgICAgIHJlamVjdEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uUmVqZWN0KTtcblxuICAgICAgICAvLyBUYWIgc3dpdGNoaW5nIGxvZ2ljXG4gICAgICAgIHJhd1RhYi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIHJhd1RhYi5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICBkaWZmVGFiLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgIHJlbmRlcmVkVGFiLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgIHByZXZpZXdBcmVhLnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgICAgIGNvbnN0IGRpZmZBcmVhID0gcHJldmlld0NvbnRlbnRDb250YWluZXIucXVlcnlTZWxlY3RvcignLmNsYXVkZS1jb2RlLXByZXZpZXctZGlmZicpO1xuICAgICAgICAgICAgY29uc3QgcmVuZGVyZWRBcmVhID0gcHJldmlld0NvbnRlbnRDb250YWluZXIucXVlcnlTZWxlY3RvcignLmNsYXVkZS1jb2RlLXByZXZpZXctcmVuZGVyZWQnKTtcbiAgICAgICAgICAgIGlmIChkaWZmQXJlYSkgZGlmZkFyZWEuYWRkQ2xhc3MoJ2NsYXVkZS1jb2RlLWhpZGRlbicpO1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVkQXJlYSkgcmVuZGVyZWRBcmVhLmFkZENsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGlmZlRhYi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIGRpZmZUYWIuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgcmF3VGFiLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgIHJlbmRlcmVkVGFiLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgIHByZXZpZXdBcmVhLmFkZENsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgICAgIGNvbnN0IGRpZmZBcmVhID0gcHJldmlld0NvbnRlbnRDb250YWluZXIucXVlcnlTZWxlY3RvcignLmNsYXVkZS1jb2RlLXByZXZpZXctZGlmZicpO1xuICAgICAgICAgICAgY29uc3QgcmVuZGVyZWRBcmVhID0gcHJldmlld0NvbnRlbnRDb250YWluZXIucXVlcnlTZWxlY3RvcignLmNsYXVkZS1jb2RlLXByZXZpZXctcmVuZGVyZWQnKTtcbiAgICAgICAgICAgIGlmIChkaWZmQXJlYSkgZGlmZkFyZWEucmVtb3ZlQ2xhc3MoJ2NsYXVkZS1jb2RlLWhpZGRlbicpO1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVkQXJlYSkgcmVuZGVyZWRBcmVhLmFkZENsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVuZGVyZWRUYWIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICByZW5kZXJlZFRhYi5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICByYXdUYWIucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgZGlmZlRhYi5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICBwcmV2aWV3QXJlYS5hZGRDbGFzcygnY2xhdWRlLWNvZGUtaGlkZGVuJyk7XG4gICAgICAgICAgICBjb25zdCBkaWZmQXJlYSA9IHByZXZpZXdDb250ZW50Q29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5jbGF1ZGUtY29kZS1wcmV2aWV3LWRpZmYnKTtcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVkQXJlYSA9IHByZXZpZXdDb250ZW50Q29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5jbGF1ZGUtY29kZS1wcmV2aWV3LXJlbmRlcmVkJyk7XG4gICAgICAgICAgICBpZiAoZGlmZkFyZWEpIGRpZmZBcmVhLmFkZENsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgICAgIGlmIChyZW5kZXJlZEFyZWEpIHJlbmRlcmVkQXJlYS5yZW1vdmVDbGFzcygnY2xhdWRlLWNvZGUtaGlkZGVuJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFkZCBjbGljayBoYW5kbGVyIHRvIHRvZ2dsZSBjb2xsYXBzZVxuICAgICAgICBoZWFkZXJUaXRsZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzQ29sbGFwc2VkID0gcHJldmlld0NvbnRlbnQuaGFzQ2xhc3MoJ2NsYXVkZS1jb2RlLWhpZGRlbicpO1xuICAgICAgICAgICAgcHJldmlld0NvbnRlbnQudG9nZ2xlQ2xhc3MoJ2NsYXVkZS1jb2RlLWhpZGRlbicsICFpc0NvbGxhcHNlZCk7XG4gICAgICAgICAgICBjb25zdCBpbmRpY2F0b3IgPSBwcmV2aWV3SGVhZGVyLnF1ZXJ5U2VsZWN0b3IoJy5jb2xsYXBzZS1pbmRpY2F0b3InKTtcbiAgICAgICAgICAgIGlmIChpbmRpY2F0b3IpIHtcbiAgICAgICAgICAgICAgICBpbmRpY2F0b3IudGV4dENvbnRlbnQgPSBpc0NvbGxhcHNlZCA/ICdcdTI1QkMgJyA6ICdcdTI1QjYgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRvZ2dsZSBjb2xsYXBzZWQgY2xhc3Mgb24gc2VjdGlvblxuICAgICAgICAgICAgcHJldmlld1NlY3Rpb24udG9nZ2xlQ2xhc3MoJ2NvbGxhcHNlZCcsICFpc0NvbGxhcHNlZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7IHByZXZpZXdBcmVhLCBwcmV2aWV3Q29udGVudENvbnRhaW5lciwgcHJldmlld1RhYnNDb250YWluZXIsIGFwcGx5QnV0dG9uLCByZWplY3RCdXR0b24gfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCdWlsZCB0aGUgaGlzdG9yeSBzZWN0aW9uXG4gICAgICovXG4gICAgc3RhdGljIGJ1aWxkSGlzdG9yeVNlY3Rpb24oXG4gICAgICAgIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsXG4gICAgICAgIG9uQ2xlYXJIaXN0b3J5OiAoKSA9PiB2b2lkXG4gICAgKTogSFRNTFVMaXN0RWxlbWVudCB7XG4gICAgICAgIGNvbnN0IGhpc3RvcnlTZWN0aW9uID0gY29udGFpbmVyLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ2NsYXVkZS1jb2RlLWhpc3Rvcnktc2VjdGlvbiBjbGF1ZGUtY29kZS1oaWRkZW4nIH0pO1xuICAgICAgICBoaXN0b3J5U2VjdGlvbi5pZCA9ICdjbGF1ZGUtY29kZS1oaXN0b3J5LXNlY3Rpb24nO1xuXG4gICAgICAgIGNvbnN0IGhpc3RvcnlIZWFkZXIgPSBoaXN0b3J5U2VjdGlvbi5jcmVhdGVFbCgnZGl2JywgeyBjbHM6ICdjbGF1ZGUtY29kZS1oaXN0b3J5LWhlYWRlciBjb2xsYXBzaWJsZS1oZWFkZXInIH0pO1xuICAgICAgICBjb25zdCBoZWFkZXJUaXRsZSA9IGhpc3RvcnlIZWFkZXIuY3JlYXRlRWwoJ3NwYW4nLCB7IGNsczogJ2NvbGxhcHNpYmxlLXRpdGxlJyB9KTtcbiAgICAgICAgLy8gU3RhcnQgY29sbGFwc2VkIGJ5IGRlZmF1bHRcbiAgICAgICAgaGVhZGVyVGl0bGUuY3JlYXRlRWwoJ3NwYW4nLCB7IGNsczogJ2NvbGxhcHNlLWluZGljYXRvcicsIHRleHQ6ICdcdTI1QjYgJyB9KTtcbiAgICAgICAgaGVhZGVyVGl0bGUuYXBwZW5kVGV4dCh0KCdoaXN0b3J5LnRpdGxlJykpO1xuXG4gICAgICAgIGNvbnN0IGNsZWFySGlzdG9yeUJ0biA9IGhpc3RvcnlIZWFkZXIuY3JlYXRlRWwoJ2J1dHRvbicsIHtcbiAgICAgICAgICAgIHRleHQ6IHQoJ2hpc3RvcnkuY2xlYXJCdXR0b24nKSxcbiAgICAgICAgICAgIGNsczogJ2NsYXVkZS1jb2RlLWNsZWFyLWhpc3RvcnknXG4gICAgICAgIH0pO1xuICAgICAgICBjbGVhckhpc3RvcnlCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTsgLy8gUHJldmVudCBoZWFkZXIgY2xpY2tcbiAgICAgICAgICAgIG9uQ2xlYXJIaXN0b3J5KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFN0YXJ0IGNvbGxhcHNlZCBieSBkZWZhdWx0XG4gICAgICAgIGNvbnN0IGhpc3RvcnlMaXN0ID0gaGlzdG9yeVNlY3Rpb24uY3JlYXRlRWwoJ3VsJywgeyBjbHM6ICdjbGF1ZGUtY29kZS1oaXN0b3J5LWxpc3QgY29sbGFwc2libGUtY29udGVudCBjbGF1ZGUtY29kZS1oaWRkZW4nIH0pO1xuICAgICAgICBoaXN0b3J5U2VjdGlvbi5hZGRDbGFzcygnY29sbGFwc2VkJyk7XG5cbiAgICAgICAgLy8gQWRkIGNsaWNrIGhhbmRsZXIgdG8gdG9nZ2xlIGNvbGxhcHNlXG4gICAgICAgIGhlYWRlclRpdGxlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNDb2xsYXBzZWQgPSBoaXN0b3J5TGlzdC5oYXNDbGFzcygnY2xhdWRlLWNvZGUtaGlkZGVuJyk7XG4gICAgICAgICAgICBoaXN0b3J5TGlzdC50b2dnbGVDbGFzcygnY2xhdWRlLWNvZGUtaGlkZGVuJywgIWlzQ29sbGFwc2VkKTtcbiAgICAgICAgICAgIGNvbnN0IGluZGljYXRvciA9IGhpc3RvcnlIZWFkZXIucXVlcnlTZWxlY3RvcignLmNvbGxhcHNlLWluZGljYXRvcicpO1xuICAgICAgICAgICAgaWYgKGluZGljYXRvcikge1xuICAgICAgICAgICAgICAgIGluZGljYXRvci50ZXh0Q29udGVudCA9IGlzQ29sbGFwc2VkID8gJ1x1MjVCQyAnIDogJ1x1MjVCNiAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVG9nZ2xlIGNvbGxhcHNlZCBjbGFzcyBvbiBzZWN0aW9uXG4gICAgICAgICAgICBoaXN0b3J5U2VjdGlvbi50b2dnbGVDbGFzcygnY29sbGFwc2VkJywgIWlzQ29sbGFwc2VkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGhpc3RvcnlMaXN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ1aWxkIFdlYlNvY2tldCBjb25uZWN0aW9uIHN0YXR1cyBiYXJcbiAgICAgKi9cbiAgICBzdGF0aWMgYnVpbGRDb25uZWN0aW9uU3RhdHVzQmFyKGNvbnRhaW5lcjogSFRNTEVsZW1lbnQpOiB7XG4gICAgICAgIHN0YXR1c0JhcjogSFRNTERpdkVsZW1lbnQ7XG4gICAgICAgIHN0YXR1c0ljb246IEhUTUxTcGFuRWxlbWVudDtcbiAgICAgICAgc3RhdHVzVGV4dDogSFRNTFNwYW5FbGVtZW50O1xuICAgIH0ge1xuICAgICAgICBjb25zdCBzdGF0dXNCYXIgPSBjb250YWluZXIuY3JlYXRlRWwoJ2RpdicsIHsgY2xzOiAnY2xhdWRlLWNvZGUtY29ubmVjdGlvbi1zdGF0dXMnIH0pO1xuXG4gICAgICAgIC8vIFN0YXR1cyBpY29uIChjb2xvcmVkIGRvdClcbiAgICAgICAgY29uc3Qgc3RhdHVzSWNvbiA9IHN0YXR1c0Jhci5jcmVhdGVFbCgnc3BhbicsIHtcbiAgICAgICAgICAgIGNsczogJ2NsYXVkZS1jb2RlLWNvbm5lY3Rpb24taWNvbiBkaXNjb25uZWN0ZWQnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFN0YXR1cyB0ZXh0XG4gICAgICAgIGNvbnN0IHN0YXR1c1RleHQgPSBzdGF0dXNCYXIuY3JlYXRlRWwoJ3NwYW4nLCB7XG4gICAgICAgICAgICBjbHM6ICdjbGF1ZGUtY29kZS1jb25uZWN0aW9uLXRleHQnLFxuICAgICAgICAgICAgdGV4dDogJ0Rpc2Nvbm5lY3RlZCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzQmFyLCBzdGF0dXNJY29uLCBzdGF0dXNUZXh0IH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGNvbm5lY3Rpb24gc3RhdHVzIGRpc3BsYXlcbiAgICAgKi9cbiAgICBzdGF0aWMgdXBkYXRlQ29ubmVjdGlvblN0YXR1cyhcbiAgICAgICAgc3RhdHVzSWNvbjogSFRNTFNwYW5FbGVtZW50LFxuICAgICAgICBzdGF0dXNUZXh0OiBIVE1MU3BhbkVsZW1lbnQsXG4gICAgICAgIHN0YXRlOiBzdHJpbmcsXG4gICAgICAgIGNvbm5lY3Rpb25Nb2RlPzogJ3N0ZGlvJyB8ICd3ZWJzb2NrZXQnXG4gICAgKTogdm9pZCB7XG4gICAgICAgIC8vIFJlbW92ZSBhbGwgc3RhdGUgY2xhc3Nlc1xuICAgICAgICBzdGF0dXNJY29uLnJlbW92ZUNsYXNzKCdkaXNjb25uZWN0ZWQnLCAnY29ubmVjdGluZycsICdjb25uZWN0ZWQnLCAnZXJyb3InKTtcblxuICAgICAgICAvLyBBZGQgYXBwcm9wcmlhdGUgY2xhc3MgYW5kIHRleHRcbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICBzdGF0dXNJY29uLmFkZENsYXNzKCdjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICBzdGF0dXNUZXh0LnRleHRDb250ZW50ID0gY29ubmVjdGlvbk1vZGUgPT09ICd3ZWJzb2NrZXQnXG4gICAgICAgICAgICAgICAgICAgID8gJ1dlYlNvY2tldCBDb25uZWN0ZWQnXG4gICAgICAgICAgICAgICAgICAgIDogJ0Nvbm5lY3RlZCAoc3RkaW8pJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RpbmcnOlxuICAgICAgICAgICAgY2FzZSAncmVjb25uZWN0aW5nJzpcbiAgICAgICAgICAgICAgICBzdGF0dXNJY29uLmFkZENsYXNzKCdjb25uZWN0aW5nJyk7XG4gICAgICAgICAgICAgICAgc3RhdHVzVGV4dC50ZXh0Q29udGVudCA9ICdDb25uZWN0aW5nLi4uJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgICBzdGF0dXNJY29uLmFkZENsYXNzKCdlcnJvcicpO1xuICAgICAgICAgICAgICAgIHN0YXR1c1RleHQudGV4dENvbnRlbnQgPSAnQ29ubmVjdGlvbiBFcnJvcic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkaXNjb25uZWN0ZWQnOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBzdGF0dXNJY29uLmFkZENsYXNzKCdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICBzdGF0dXNUZXh0LnRleHRDb250ZW50ID0gY29ubmVjdGlvbk1vZGUgPT09ICd3ZWJzb2NrZXQnXG4gICAgICAgICAgICAgICAgICAgID8gJ1dlYlNvY2tldCBEaXNjb25uZWN0ZWQnXG4gICAgICAgICAgICAgICAgICAgIDogJ0Rpc2Nvbm5lY3RlZCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiLyoqXG4gKiBPdXRwdXQgUmVuZGVyZXIgLSBIYW5kbGVzIHJlbmRlcmluZyBvZiBvdXRwdXQgYW5kIG1hcmtkb3duIGNvbnRlbnRcbiAqL1xuXG5pbXBvcnQgeyBNYXJrZG93blJlbmRlcmVyLCBDb21wb25lbnQsIEFwcCB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IEFnZW50U3RlcCB9IGZyb20gJy4uL2NvcmUvdHlwZXMnO1xuaW1wb3J0IHsgQWdlbnRBY3Rpdml0eVBhcnNlciB9IGZyb20gJy4vcGFyc2Vycy9hZ2VudC1hY3Rpdml0eS1wYXJzZXInO1xuXG5leHBvcnQgY2xhc3MgT3V0cHV0UmVuZGVyZXIge1xuICAgIHByaXZhdGUgb3V0cHV0QXJlYTogSFRNTERpdkVsZW1lbnQ7XG4gICAgcHJpdmF0ZSBvdXRwdXRTZWN0aW9uOiBIVE1MRGl2RWxlbWVudCB8IG51bGwgPSBudWxsO1xuICAgIHByaXZhdGUgY29tcG9uZW50OiBDb21wb25lbnQ7XG4gICAgcHJpdmF0ZSBhcHA6IEFwcDtcbiAgICBwcml2YXRlIG5vdGVQYXRoOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBjdXJyZW50U3RyZWFtaW5nRWxlbWVudDogSFRNTERpdkVsZW1lbnQgfCBudWxsID0gbnVsbDtcblxuICAgIGNvbnN0cnVjdG9yKG91dHB1dEFyZWE6IEhUTUxEaXZFbGVtZW50LCBjb21wb25lbnQ6IENvbXBvbmVudCwgYXBwOiBBcHAsIG5vdGVQYXRoOiBzdHJpbmcsIG91dHB1dFNlY3Rpb24/OiBIVE1MRGl2RWxlbWVudCkge1xuICAgICAgICB0aGlzLm91dHB1dEFyZWEgPSBvdXRwdXRBcmVhO1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgICAgIHRoaXMubm90ZVBhdGggPSBub3RlUGF0aDtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RyZWFtaW5nRWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMub3V0cHV0U2VjdGlvbiA9IG91dHB1dFNlY3Rpb24gfHwgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIG5vdGUgcGF0aCBmb3IgbWFya2Rvd24gcmVuZGVyaW5nXG4gICAgICovXG4gICAgc2V0Tm90ZVBhdGgobm90ZVBhdGg6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLm5vdGVQYXRoID0gbm90ZVBhdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwZW5kIGEgbGluZSBvZiBvdXRwdXRcbiAgICAgKi9cbiAgICBhcHBlbmRMaW5lKHRleHQ6IHN0cmluZywgaXNNYXJrZG93bjogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XG4gICAgICAgIC8vIFNob3cgdGhlIG91dHB1dCBzZWN0aW9uIHdoZW4gdGhlcmUncyBjb250ZW50XG4gICAgICAgIHRoaXMuc2hvd091dHB1dFNlY3Rpb24oKTtcblxuICAgICAgICBjb25zdCBsaW5lID0gdGhpcy5vdXRwdXRBcmVhLmNyZWF0ZUVsKCdkaXYnLCB7IGNsczogJ2NsYXVkZS1jb2RlLW91dHB1dC1saW5lJyB9KTtcblxuICAgICAgICBpZiAoaXNNYXJrZG93bikge1xuICAgICAgICAgICAgbGluZS5jbGFzc0xpc3QuYWRkKCdtYXJrZG93bi1yZW5kZXJlZCcpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2b2lkIE1hcmtkb3duUmVuZGVyZXIucmVuZGVyKHRoaXMuYXBwLCB0ZXh0LCBsaW5lLCB0aGlzLm5vdGVQYXRoLCB0aGlzLmNvbXBvbmVudCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tNQVJLRE9XTiBSRU5ERVIgRVJST1JdJywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIGxpbmUudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGluZS50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBdXRvLXNjcm9sbCB0byBib3R0b21cbiAgICAgICAgdGhpcy5vdXRwdXRBcmVhLnNjcm9sbFRvcCA9IHRoaXMub3V0cHV0QXJlYS5zY3JvbGxIZWlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwZW5kIHN0cmVhbWluZyB0ZXh0IChhY2N1bXVsYXRlcyBpbiB0aGUgc2FtZSBlbGVtZW50KVxuICAgICAqL1xuICAgIGFwcGVuZFN0cmVhbWluZ1RleHQodGV4dDogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIC8vIFNob3cgdGhlIG91dHB1dCBzZWN0aW9uIHdoZW4gdGhlcmUncyBjb250ZW50XG4gICAgICAgIHRoaXMuc2hvd091dHB1dFNlY3Rpb24oKTtcblxuICAgICAgICAvLyBDcmVhdGUgbmV3IHN0cmVhbWluZyBlbGVtZW50IGlmIG5lZWRlZFxuICAgICAgICBpZiAoIXRoaXMuY3VycmVudFN0cmVhbWluZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFN0cmVhbWluZ0VsZW1lbnQgPSB0aGlzLm91dHB1dEFyZWEuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBjbHM6ICdjbGF1ZGUtY29kZS1vdXRwdXQtbGluZSBjbGF1ZGUtY29kZS1zdHJlYW1pbmcnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdyYXAgZWFjaCBjaHVuayBpbiBhIHNwYW4gd2l0aCBmYWRlLWluIGFuaW1hdGlvblxuICAgICAgICB0aGlzLmN1cnJlbnRTdHJlYW1pbmdFbGVtZW50LmNyZWF0ZUVsKCdzcGFuJywge1xuICAgICAgICAgICAgY2xzOiAnc3RyZWFtaW5nLXRleHQtY2h1bmsnLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBdXRvLXNjcm9sbCB0byBib3R0b21cbiAgICAgICAgdGhpcy5vdXRwdXRBcmVhLnNjcm9sbFRvcCA9IHRoaXMub3V0cHV0QXJlYS5zY3JvbGxIZWlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluaXNoIHRoZSBjdXJyZW50IHN0cmVhbWluZyBibG9ja1xuICAgICAqL1xuICAgIGZpbmlzaFN0cmVhbWluZ0Jsb2NrKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmN1cnJlbnRTdHJlYW1pbmdFbGVtZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgb3V0cHV0XG4gICAgICovXG4gICAgY2xlYXIoKTogdm9pZCB7XG4gICAgICAgIHRoaXMub3V0cHV0QXJlYS5lbXB0eSgpO1xuICAgICAgICAvLyBIaWRlIHRoZSBvdXRwdXQgc2VjdGlvbiB3aGVuIGNsZWFyZWRcbiAgICAgICAgdGhpcy5oaWRlT3V0cHV0U2VjdGlvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3cgdGhlIG91dHB1dCBzZWN0aW9uXG4gICAgICovXG4gICAgcHJpdmF0ZSBzaG93T3V0cHV0U2VjdGlvbigpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0U2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRTZWN0aW9uLnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhpZGUgdGhlIG91dHB1dCBzZWN0aW9uXG4gICAgICovXG4gICAgcHJpdmF0ZSBoaWRlT3V0cHV0U2VjdGlvbigpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0U2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRTZWN0aW9uLmFkZENsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIGFuZCBleHRyYWN0IGFnZW50IGFjdGl2aXR5IGZyb20gb3V0cHV0IHRleHRcbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VBZ2VudEFjdGl2aXR5KHRleHQ6IHN0cmluZyk6IEFnZW50U3RlcCB8IG51bGwge1xuICAgICAgICByZXR1cm4gQWdlbnRBY3Rpdml0eVBhcnNlci5wYXJzZUFnZW50QWN0aXZpdHkodGV4dCk7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IEFnZW50U3RlcCB9IGZyb20gJy4uLy4uL2NvcmUvdHlwZXMnO1xuXG4vKipcbiAqIFV0aWxpdHkgZm9yIHBhcnNpbmcgYWdlbnQgYWN0aXZpdHkgZnJvbSBvdXRwdXQgdGV4dFxuICovXG5leHBvcnQgY2xhc3MgQWdlbnRBY3Rpdml0eVBhcnNlciB7XG4gICAgLyoqXG4gICAgICogUGFyc2UgYW5kIGV4dHJhY3QgYWdlbnQgYWN0aXZpdHkgZnJvbSBvdXRwdXQgdGV4dFxuICAgICAqXG4gICAgICogQHBhcmFtIHRleHQgT3V0cHV0IHRleHQgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJucyBBZ2VudFN0ZXAgb2JqZWN0IGlmIGFjdGl2aXR5IGRldGVjdGVkLCBudWxsIG90aGVyd2lzZVxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZUFnZW50QWN0aXZpdHkodGV4dDogc3RyaW5nKTogQWdlbnRTdGVwIHwgbnVsbCB7XG4gICAgICAgIC8vIFN5c3RlbSBldmVudHNcbiAgICAgICAgaWYgKHRleHQuaW5jbHVkZXMoJ1Jlc3VtaW5nIHNlc3Npb246JykgfHwgdGV4dC5pbmNsdWRlcygnXHUyNzEzIFJlc3VtaW5nIHNlc3Npb246JykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdGNoQW5kQ3JlYXRlKFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgLyg/Olx1MjcxMyApP1Jlc3VtaW5nIHNlc3Npb246ICguKykvLFxuICAgICAgICAgICAgICAgICdcdUQ4M0RcdUREMDQnLFxuICAgICAgICAgICAgICAgICdSZXN1bWUnLFxuICAgICAgICAgICAgICAgICdyZXN1bWUnLFxuICAgICAgICAgICAgICAgIChtYXRjaCkgPT4gdGhpcy50cnVuY2F0ZShtYXRjaFsxXSwgOCwgZmFsc2UpICsgJy4uLidcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dC5pbmNsdWRlcygnXHUyMTkyIFN0YXJ0aW5nIG5ldyBzZXNzaW9uJykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVN0ZXAoJ1x1RDgzQ1x1REQ5NScsICdOZXcnLCAnc2Vzc2lvbiBzdGFydGVkJywgJ25ldy1zZXNzaW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dC5pbmNsdWRlcygnVmF1bHQgYWNjZXNzIGVuYWJsZWQ6JykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdGNoQW5kQ3JlYXRlKFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgL1ZhdWx0IGFjY2VzcyBlbmFibGVkOiAoLispLyxcbiAgICAgICAgICAgICAgICAnXHVEODNEXHVEREMyXHVGRTBGJyxcbiAgICAgICAgICAgICAgICAnVmF1bHQnLFxuICAgICAgICAgICAgICAgICd2YXVsdCcsXG4gICAgICAgICAgICAgICAgKG1hdGNoKSA9PiB0aGlzLmV4dHJhY3RGaWxlbmFtZShtYXRjaFsxXSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dC5pbmNsdWRlcygnXHVEODNEXHVERDI3IFNlc3Npb24gaW5pdGlhbGl6ZWQ6JykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdGNoQW5kQ3JlYXRlKFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgL1x1RDgzRFx1REQyNyBTZXNzaW9uIGluaXRpYWxpemVkOiAoLispLyxcbiAgICAgICAgICAgICAgICAnXHVEODNEXHVERTgwJyxcbiAgICAgICAgICAgICAgICAnSW5pdGlhbGl6ZScsXG4gICAgICAgICAgICAgICAgJ2luaXQnXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHQuaW5jbHVkZXMoJ1x1RDgzRFx1RENCRSBTZXNzaW9uIElEOicpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXRjaEFuZENyZWF0ZShcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgIC9cdUQ4M0RcdURDQkUgU2Vzc2lvbiBJRDogKC4rKS8sXG4gICAgICAgICAgICAgICAgJ1x1RDgzRFx1RENCRScsXG4gICAgICAgICAgICAgICAgJ1Nlc3Npb24nLFxuICAgICAgICAgICAgICAgICdzZXNzaW9uJyxcbiAgICAgICAgICAgICAgICAobWF0Y2gpID0+IHRoaXMudHJ1bmNhdGUobWF0Y2hbMV0sIDgsIGZhbHNlKSArICcuLi4nXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHQuaW5jbHVkZXMoJ1x1RDgzRFx1RENFNiBBdmFpbGFibGUgdG9vbHM6JykpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdGV4dC5tYXRjaCgvXHVEODNEXHVEQ0U2IEF2YWlsYWJsZSB0b29sczogKC4rKS8pO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vbHMgPSBtYXRjaFsxXS5zcGxpdCgnLCAnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTdGVwKCdcdUQ4M0RcdURDRTYnLCAnVG9vbHMnLCBgJHt0b29scy5sZW5ndGh9IGF2YWlsYWJsZWAsICd0b29scycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVG9vbCB1c2FnZSAoc3BlY2lhbCBjYXNlOiBhY3Rpb24gY29tZXMgZnJvbSBtYXRjaClcbiAgICAgICAgaWYgKHRleHQuaW5jbHVkZXMoJ1x1RDgzRFx1REQyNyBVc2luZyB0b29sOicpKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHRleHQubWF0Y2goL1x1RDgzRFx1REQyNyBVc2luZyB0b29sOiAoXFx3KykvKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVN0ZXAoJ1x1RDgzRFx1REQyNycsIG1hdGNoWzFdLCAnc3RhcnRpbmcuLi4nLCBgdG9vbC0ke21hdGNoWzFdfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmFzaCBjb21tYW5kc1xuICAgICAgICBpZiAodGV4dC5pbmNsdWRlcygnJCAnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hBbmRDcmVhdGUoXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAvXFwkICguKykvLFxuICAgICAgICAgICAgICAgICdcdTI2QTEnLFxuICAgICAgICAgICAgICAgICdCYXNoJyxcbiAgICAgICAgICAgICAgICAnYmFzaCcsXG4gICAgICAgICAgICAgICAgKG1hdGNoKSA9PiB0aGlzLnRydW5jYXRlKG1hdGNoWzFdLCA2MClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZWIgc2VhcmNoIHdpdGggcXVlcnlcbiAgICAgICAgaWYgKHRleHQuaW5jbHVkZXMoJ1F1ZXJ5OicpICYmICh0ZXh0LmluY2x1ZGVzKCdcdUQ4M0RcdUREMEQnKSB8fCB0ZXh0LmluY2x1ZGVzKCdzZWFyY2gnKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdGNoQW5kQ3JlYXRlKFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgLyg/Olx1RDgzRFx1REQwRCApP1F1ZXJ5OiBcIiguKz8pXCIvLFxuICAgICAgICAgICAgICAgICdcdUQ4M0RcdUREMEQnLFxuICAgICAgICAgICAgICAgICdTZWFyY2gnLFxuICAgICAgICAgICAgICAgICdzZWFyY2gnLFxuICAgICAgICAgICAgICAgIChtYXRjaCkgPT4gdGhpcy50cnVuY2F0ZShtYXRjaFsxXSwgNTApXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVG9vbCByZXN1bHRzXG4gICAgICAgIGlmICh0ZXh0LmluY2x1ZGVzKCdcdUQ4M0RcdURDRTUgVG9vbCByZXN1bHQnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hBbmRDcmVhdGUoXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAvXHVEODNEXHVEQ0U1IFRvb2wgcmVzdWx0IFxcKCguKz8pXFwpOi8sXG4gICAgICAgICAgICAgICAgJ1x1RDgzRFx1RENFNScsXG4gICAgICAgICAgICAgICAgJ1Jlc3VsdCcsXG4gICAgICAgICAgICAgICAgJ3Jlc3VsdCcsXG4gICAgICAgICAgICAgICAgKG1hdGNoKSA9PiB0aGlzLnRydW5jYXRlKG1hdGNoWzFdLCAyMClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZWIgZmV0Y2ggd2l0aCBVUkxcbiAgICAgICAgaWYgKHRleHQuaW5jbHVkZXMoJ1x1RDgzQ1x1REYxMCBVUkw6JykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdGNoQW5kQ3JlYXRlKFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgL1x1RDgzQ1x1REYxMCBVUkw6ICguKykvLFxuICAgICAgICAgICAgICAgICdcdUQ4M0NcdURGMTAnLFxuICAgICAgICAgICAgICAgICdGZXRjaCcsXG4gICAgICAgICAgICAgICAgJ2ZldGNoJyxcbiAgICAgICAgICAgICAgICAobWF0Y2gpID0+IHRoaXMudHJ1bmNhdGUobWF0Y2hbMV0sIDUwKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbGUgb3BlcmF0aW9ucyB3aXRoIGFjdHVhbCBmaWxlbmFtZXNcbiAgICAgICAgaWYgKHRleHQuaW5jbHVkZXMoJ1x1RDgzRFx1RENENicpICYmICh0ZXh0LmluY2x1ZGVzKCdGaWxlOicpIHx8IHRleHQuaW5jbHVkZXMoJ1JlYWRpbmcgZmlsZTonKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdGNoQW5kQ3JlYXRlKFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgLyg/OkZpbGU6fFJlYWRpbmcgZmlsZTopXFxzKyguKykvLFxuICAgICAgICAgICAgICAgICdcdUQ4M0RcdURDRDYnLFxuICAgICAgICAgICAgICAgICdSZWFkJyxcbiAgICAgICAgICAgICAgICAncmVhZCcsXG4gICAgICAgICAgICAgICAgKG1hdGNoKSA9PiB0aGlzLmV4dHJhY3RGaWxlbmFtZShtYXRjaFsxXSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dC5pbmNsdWRlcygnXHUyNzBEXHVGRTBGJykgJiYgKHRleHQuaW5jbHVkZXMoJ0ZpbGU6JykgfHwgdGV4dC5pbmNsdWRlcygnV3JpdGluZyBmaWxlOicpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hBbmRDcmVhdGUoXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAvKD86RmlsZTp8V3JpdGluZyBmaWxlOilcXHMrKC4rKS8sXG4gICAgICAgICAgICAgICAgJ1x1MjcwRFx1RkUwRicsXG4gICAgICAgICAgICAgICAgJ1dyaXRlJyxcbiAgICAgICAgICAgICAgICAnd3JpdGUnLFxuICAgICAgICAgICAgICAgIChtYXRjaCkgPT4gdGhpcy5leHRyYWN0RmlsZW5hbWUobWF0Y2hbMV0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHQuaW5jbHVkZXMoJ1x1MjcwRlx1RkUwRicpICYmICh0ZXh0LmluY2x1ZGVzKCdGaWxlOicpIHx8IHRleHQuaW5jbHVkZXMoJ0VkaXRpbmcgZmlsZTonKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdGNoQW5kQ3JlYXRlKFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgLyg/OkZpbGU6fEVkaXRpbmcgZmlsZTopXFxzKyguKykvLFxuICAgICAgICAgICAgICAgICdcdTI3MEZcdUZFMEYnLFxuICAgICAgICAgICAgICAgICdFZGl0JyxcbiAgICAgICAgICAgICAgICAnZWRpdCcsXG4gICAgICAgICAgICAgICAgKG1hdGNoKSA9PiB0aGlzLmV4dHJhY3RGaWxlbmFtZShtYXRjaFsxXSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQYXR0ZXJuIHNlYXJjaGVzXG4gICAgICAgIGlmICh0ZXh0LmluY2x1ZGVzKCdQYXR0ZXJuOicpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXRjaEFuZENyZWF0ZShcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgIC9QYXR0ZXJuOiAoLispLyxcbiAgICAgICAgICAgICAgICAnXHVEODNEXHVERDBFJyxcbiAgICAgICAgICAgICAgICAnU2VhcmNoJyxcbiAgICAgICAgICAgICAgICAncGF0dGVybicsXG4gICAgICAgICAgICAgICAgKG1hdGNoKSA9PiB0aGlzLnRydW5jYXRlKG1hdGNoWzFdLCA0MClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZ2VudCBsYXVuY2hlc1xuICAgICAgICBpZiAodGV4dC5pbmNsdWRlcygnQWdlbnQ6JykgfHwgdGV4dC5pbmNsdWRlcygnVHlwZTonKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hBbmRDcmVhdGUoXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAvKD86QWdlbnQ6fFR5cGU6KVxccysoLispLyxcbiAgICAgICAgICAgICAgICAnXHVEODNFXHVERDE2JyxcbiAgICAgICAgICAgICAgICAnQWdlbnQnLFxuICAgICAgICAgICAgICAgICdhZ2VudCdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21wbGV0aW9uIHJlc3VsdHNcbiAgICAgICAgaWYgKHRleHQuaW5jbHVkZXMoJ1x1MjcwNSBDb21wbGV0ZSEnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU3RlcCgnXHUyNzA1JywgJ0NvbXBsZXRlJywgJ1N1Y2Nlc3MnLCAnY29tcGxldGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0LmluY2x1ZGVzKCdcdUQ4M0RcdURDQjAgQ29zdDonKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hBbmRDcmVhdGUoXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAvXHVEODNEXHVEQ0IwIENvc3Q6IFxcJChcXGQrXFwuXFxkKykvLFxuICAgICAgICAgICAgICAgICdcdUQ4M0RcdURDQjAnLFxuICAgICAgICAgICAgICAgICdDb3N0JyxcbiAgICAgICAgICAgICAgICAnY29zdCcsXG4gICAgICAgICAgICAgICAgKG1hdGNoKSA9PiBgJCR7bWF0Y2hbMV19YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0LmluY2x1ZGVzKCdcdUQ4M0RcdURDQ0EgVG9rZW5zOicpKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHRleHQubWF0Y2goL1x1RDgzRFx1RENDQSBUb2tlbnM6IChcXGQrKSBpbiwgKFxcZCspIG91dC8pO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU3RlcCgnXHVEODNEXHVEQ0NBJywgJ1Rva2VucycsIGAke21hdGNoWzFdfSBcdTIxOTIgJHttYXRjaFsyXX1gLCAndG9rZW5zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dC5pbmNsdWRlcygnXHUyM0YxXHVGRTBGJykgJiYgdGV4dC5pbmNsdWRlcygnRHVyYXRpb246JykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdGNoQW5kQ3JlYXRlKFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgL1x1MjNGMVx1RkUwRlxcc3syfUR1cmF0aW9uOiAoXFxkKyltcy8sXG4gICAgICAgICAgICAgICAgJ1x1MjNGMVx1RkUwRicsXG4gICAgICAgICAgICAgICAgJ0R1cmF0aW9uJyxcbiAgICAgICAgICAgICAgICAnZHVyYXRpb24nLFxuICAgICAgICAgICAgICAgIChtYXRjaCkgPT4gYCR7KHBhcnNlSW50KG1hdGNoWzFdKSAvIDEwMDApLnRvRml4ZWQoMSl9c2BcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5hbCByZXNwb25zZSBpbmRpY2F0b3JcbiAgICAgICAgaWYgKHRleHQuaW5jbHVkZXMoJ1x1MjcxMyBDbGF1ZGUgQ29kZSBjb21wbGV0ZWQnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU3RlcCgnXHVEODNDXHVERjg5JywgJ0ZpbmlzaGVkJywgJ1N1Y2Nlc3NmdWxseScsICdmaW5pc2hlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIHRvIGNyZWF0ZSBBZ2VudFN0ZXAgZnJvbSBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgY3JlYXRlU3RlcChcbiAgICAgICAgaWNvbjogc3RyaW5nLFxuICAgICAgICBhY3Rpb246IHN0cmluZyxcbiAgICAgICAgdGFyZ2V0OiBzdHJpbmcsXG4gICAgICAgIGtleVByZWZpeDogc3RyaW5nXG4gICAgKTogQWdlbnRTdGVwIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGljb24sXG4gICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBrZXk6IGAke2tleVByZWZpeH0tJHtEYXRlLm5vdygpfWBcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgdG8gbWF0Y2ggcGF0dGVybiBhbmQgY3JlYXRlIHN0ZXAgd2l0aCBvcHRpb25hbCB0YXJnZXQgdHJhbnNmb3JtYXRpb25cbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBtYXRjaEFuZENyZWF0ZShcbiAgICAgICAgdGV4dDogc3RyaW5nLFxuICAgICAgICBwYXR0ZXJuOiBSZWdFeHAsXG4gICAgICAgIGljb246IHN0cmluZyxcbiAgICAgICAgYWN0aW9uOiBzdHJpbmcsXG4gICAgICAgIGtleVByZWZpeDogc3RyaW5nLFxuICAgICAgICB0YXJnZXRUcmFuc2Zvcm0/OiAobWF0Y2g6IFJlZ0V4cE1hdGNoQXJyYXkpID0+IHN0cmluZ1xuICAgICk6IEFnZW50U3RlcCB8IG51bGwge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHRleHQubWF0Y2gocGF0dGVybik7XG4gICAgICAgIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldFRyYW5zZm9ybSA/IHRhcmdldFRyYW5zZm9ybShtYXRjaCkgOiBtYXRjaFsxXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU3RlcChpY29uLCBhY3Rpb24sIHRhcmdldCwga2V5UHJlZml4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgdG8gZXh0cmFjdCBmaWxlbmFtZSBmcm9tIHBhdGhcbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBleHRyYWN0RmlsZW5hbWUocGF0aDogc3RyaW5nLCBtYXhMZW5ndGg6IG51bWJlciA9IDQwKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBwYXRoLnNwbGl0KCcvJykucG9wKCkgfHwgcGF0aDtcbiAgICAgICAgcmV0dXJuIGZpbGVuYW1lLnN1YnN0cmluZygwLCBtYXhMZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciB0byB0cnVuY2F0ZSB0ZXh0XG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgdHJ1bmNhdGUodGV4dDogc3RyaW5nLCBtYXhMZW5ndGg6IG51bWJlciwgYWRkRWxsaXBzaXM6IGJvb2xlYW4gPSB0cnVlKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoIDw9IG1heExlbmd0aCkgcmV0dXJuIHRleHQ7XG4gICAgICAgIHJldHVybiBhZGRFbGxpcHNpcyA/IHRleHQuc3Vic3RyaW5nKDAsIG1heExlbmd0aCkgKyAnLi4uJyA6IHRleHQuc3Vic3RyaW5nKDAsIG1heExlbmd0aCk7XG4gICAgfVxufVxuIiwgIi8qKlxuICogQWdlbnQgQWN0aXZpdHkgVHJhY2tlciAtIE1hbmFnZXMgYWdlbnQgYWN0aXZpdHkgZGlzcGxheVxuICovXG5cbmltcG9ydCB7IEFnZW50U3RlcCB9IGZyb20gJy4uL2NvcmUvdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgQWdlbnRBY3Rpdml0eVRyYWNrZXIge1xuICAgIHByaXZhdGUgYWdlbnRTdGVwczogTWFwPHN0cmluZywgSFRNTEVsZW1lbnQ+ID0gbmV3IE1hcCgpO1xuICAgIHByaXZhdGUgYWdlbnRTdGVwc0NvbnRhaW5lcjogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbDtcbiAgICBwcml2YXRlIGFnZW50QWN0aXZpdHlTZWN0aW9uOiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsO1xuICAgIHByaXZhdGUgYWdlbnRDb250YWluZXI6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBzdGVwVGltZXJzOiBNYXA8c3RyaW5nLCBOb2RlSlMuVGltZW91dD4gPSBuZXcgTWFwKCk7XG4gICAgcHJpdmF0ZSBzdGVwU3RhcnRUaW1lczogTWFwPHN0cmluZywgbnVtYmVyPiA9IG5ldyBNYXAoKTtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIHRyYWNrZXIgd2l0aCBET00gZWxlbWVudHNcbiAgICAgKi9cbiAgICBpbml0aWFsaXplKGFnZW50QWN0aXZpdHlTZWN0aW9uOiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLmFnZW50QWN0aXZpdHlTZWN0aW9uID0gYWdlbnRBY3Rpdml0eVNlY3Rpb247XG4gICAgICAgIHRoaXMuYWdlbnRTdGVwc0NvbnRhaW5lciA9IGFnZW50QWN0aXZpdHlTZWN0aW9uLnF1ZXJ5U2VsZWN0b3IoJyNjbGF1ZGUtY29kZS1hZ2VudC1zdGVwcycpO1xuICAgICAgICAvLyBHZXQgcmVmZXJlbmNlIHRvIHRoZSBtYWluIGNvbnRhaW5lclxuICAgICAgICB0aGlzLmFnZW50Q29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NsYXVkZS1jb2RlLWFnZW50LWNvbnRhaW5lcicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBvciB1cGRhdGUgYW4gYWdlbnQgc3RlcFxuICAgICAqL1xuICAgIGFkZFN0ZXAoc3RlcDogQWdlbnRTdGVwKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5hZ2VudFN0ZXBzQ29udGFpbmVyIHx8ICF0aGlzLmFnZW50QWN0aXZpdHlTZWN0aW9uKSByZXR1cm47XG5cbiAgICAgICAgLy8gU2hvdyB0aGUgYWN0aXZpdHkgc2VjdGlvbiB3aGVuIGFkZGluZyBzdGVwc1xuICAgICAgICB0aGlzLmFnZW50QWN0aXZpdHlTZWN0aW9uLnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS1oaWRkZW4nKTtcblxuICAgICAgICAvLyBTaG93IHRoZSBhZ2VudCBjb250YWluZXJcbiAgICAgICAgaWYgKHRoaXMuYWdlbnRDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYWdlbnRDb250YWluZXIucmVtb3ZlQ2xhc3MoJ2NsYXVkZS1jb2RlLWhpZGRlbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgYWxyZWFkeSBoYXZlIHRoaXMgc3RlcCAtIHVwZGF0ZSBpdCBpZiBzb1xuICAgICAgICBpZiAodGhpcy5hZ2VudFN0ZXBzLmhhcyhzdGVwLmtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nRWwgPSB0aGlzLmFnZW50U3RlcHMuZ2V0KHN0ZXAua2V5KSE7XG5cbiAgICAgICAgICAgIC8vIElmIGR1cmF0aW9uIGlzIHByb3ZpZGVkLCB0aGlzIHN0ZXAgaXMgY29tcGxldGVcbiAgICAgICAgICAgIGlmIChzdGVwLmR1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBTdG9wIHRoZSBsaXZlIHRpbWVyIGZvciB0aGlzIHN0ZXBcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BTdGVwVGltZXIoc3RlcC5rZXkpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG9sZCBkdXJhdGlvbiBpZiBleGlzdHNcbiAgICAgICAgICAgICAgICBjb25zdCBvbGREdXJhdGlvbiA9IGV4aXN0aW5nRWwucXVlcnlTZWxlY3RvcignLmFnZW50LXN0ZXAtZHVyYXRpb24nKTtcbiAgICAgICAgICAgICAgICBpZiAob2xkRHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkRHVyYXRpb24ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWRkIGZpbmFsIGR1cmF0aW9uIGJhZGdlXG4gICAgICAgICAgICAgICAgY29uc3QgZHVyYXRpb25UZXh0ID0gdGhpcy5mb3JtYXREdXJhdGlvbihzdGVwLmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICBleGlzdGluZ0VsLmNyZWF0ZUVsKCdzcGFuJywge1xuICAgICAgICAgICAgICAgICAgICBjbHM6ICdhZ2VudC1zdGVwLWR1cmF0aW9uIGFnZW50LXN0ZXAtZHVyYXRpb24tY29tcGxldGUnLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBkdXJhdGlvblRleHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgc3RlcCBlbGVtZW50XG4gICAgICAgIGNvbnN0IHN0ZXBFbCA9IHRoaXMuYWdlbnRTdGVwc0NvbnRhaW5lci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgICAgICAgY2xzOiAnY2xhdWRlLWNvZGUtYWdlbnQtc3RlcCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3RlcEVsLmNyZWF0ZUVsKCdzcGFuJywge1xuICAgICAgICAgICAgY2xzOiAnYWdlbnQtc3RlcC1pY29uJyxcbiAgICAgICAgICAgIHRleHQ6IHN0ZXAuaWNvblxuICAgICAgICB9KTtcblxuICAgICAgICBzdGVwRWwuY3JlYXRlRWwoJ3NwYW4nLCB7XG4gICAgICAgICAgICBjbHM6ICdhZ2VudC1zdGVwLWFjdGlvbicsXG4gICAgICAgICAgICB0ZXh0OiBzdGVwLmFjdGlvblxuICAgICAgICB9KTtcblxuICAgICAgICBzdGVwRWwuY3JlYXRlRWwoJ3NwYW4nLCB7XG4gICAgICAgICAgICBjbHM6ICdhZ2VudC1zdGVwLXRhcmdldCcsXG4gICAgICAgICAgICB0ZXh0OiBzdGVwLnRhcmdldFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBZGQgdGltaW5nIGluZm9ybWF0aW9uXG4gICAgICAgIGlmIChzdGVwLmR1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFN0ZXAgaXMgYWxyZWFkeSBjb21wbGV0ZVxuICAgICAgICAgICAgY29uc3QgZHVyYXRpb25UZXh0ID0gdGhpcy5mb3JtYXREdXJhdGlvbihzdGVwLmR1cmF0aW9uKTtcbiAgICAgICAgICAgIHN0ZXBFbC5jcmVhdGVFbCgnc3BhbicsIHtcbiAgICAgICAgICAgICAgICBjbHM6ICdhZ2VudC1zdGVwLWR1cmF0aW9uIGFnZW50LXN0ZXAtZHVyYXRpb24tY29tcGxldGUnLFxuICAgICAgICAgICAgICAgIHRleHQ6IGR1cmF0aW9uVGV4dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RlcC5zdGFydFRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gU3RlcCBpcyBpbiBwcm9ncmVzcyAtIHNob3cgbGl2ZSBlbGFwc2VkIHRpbWVcbiAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uRWwgPSBzdGVwRWwuY3JlYXRlRWwoJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgY2xzOiAnYWdlbnQtc3RlcC1kdXJhdGlvbiBhZ2VudC1zdGVwLWR1cmF0aW9uLWxpdmUnLFxuICAgICAgICAgICAgICAgIHRleHQ6ICcwLjBzJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IGxpdmUgdGltZXJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRTdGVwVGltZXIoc3RlcC5rZXksIHN0ZXAuc3RhcnRUaW1lLCBkdXJhdGlvbkVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0b3JlIHRoZSBlbGVtZW50XG4gICAgICAgIHRoaXMuYWdlbnRTdGVwcy5zZXQoc3RlcC5rZXksIHN0ZXBFbCk7XG5cbiAgICAgICAgLy8gQXV0by1zY3JvbGwgdG8gdGhlIGJvdHRvbSB0byBzaG93IHRoZSBsYXRlc3Qgc3RlcFxuICAgICAgICB0aGlzLmFnZW50U3RlcHNDb250YWluZXIuc2Nyb2xsVG9wID0gdGhpcy5hZ2VudFN0ZXBzQ29udGFpbmVyLnNjcm9sbEhlaWdodDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBhIGxpdmUgdGltZXIgZm9yIGEgc3RlcFxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhcnRTdGVwVGltZXIoa2V5OiBzdHJpbmcsIHN0YXJ0VGltZTogbnVtYmVyLCBkdXJhdGlvbkVsOiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgICAgICAvLyBTdG9yZSBzdGFydCB0aW1lXG4gICAgICAgIHRoaXMuc3RlcFN0YXJ0VGltZXMuc2V0KGtleSwgc3RhcnRUaW1lKTtcblxuICAgICAgICAvLyBVcGRhdGUgZXZlcnkgMTAwbXNcbiAgICAgICAgY29uc3QgdGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZCA9IHRoaXMuZm9ybWF0RHVyYXRpb24oZWxhcHNlZCk7XG4gICAgICAgICAgICBkdXJhdGlvbkVsLnRleHRDb250ZW50ID0gZm9ybWF0dGVkO1xuICAgICAgICB9LCAxMDApO1xuXG4gICAgICAgIHRoaXMuc3RlcFRpbWVycy5zZXQoa2V5LCB0aW1lcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgbGl2ZSB0aW1lciBmb3IgYSBzdGVwXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdG9wU3RlcFRpbWVyKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRpbWVyID0gdGhpcy5zdGVwVGltZXJzLmdldChrZXkpO1xuICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xuICAgICAgICAgICAgdGhpcy5zdGVwVGltZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RlcFN0YXJ0VGltZXMuZGVsZXRlKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIGFnZW50IHN0ZXBzXG4gICAgICovXG4gICAgY2xlYXIoKTogdm9pZCB7XG4gICAgICAgIC8vIFN0b3AgYWxsIHRpbWVyc1xuICAgICAgICBmb3IgKGNvbnN0IHRpbWVyIG9mIHRoaXMuc3RlcFRpbWVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGVwVGltZXJzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuc3RlcFN0YXJ0VGltZXMuY2xlYXIoKTtcblxuICAgICAgICBpZiAodGhpcy5hZ2VudFN0ZXBzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmFnZW50U3RlcHNDb250YWluZXIuZW1wdHkoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFnZW50U3RlcHMuY2xlYXIoKTtcblxuICAgICAgICAvLyBIaWRlIHRoZSBhY3Rpdml0eSBjb2x1bW4gd2hlbiBlbXB0eVxuICAgICAgICBpZiAodGhpcy5hZ2VudEFjdGl2aXR5U2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5hZ2VudEFjdGl2aXR5U2VjdGlvbi5hZGRDbGFzcygnY2xhdWRlLWNvZGUtaGlkZGVuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3RlOiBXZSBkb24ndCBoaWRlIHRoZSBtYWluIGNvbnRhaW5lciBoZXJlIGJlY2F1c2UgdGhlIHRvZG8gbGlzdCBtaWdodCBzdGlsbCBiZSB2aXNpYmxlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZSBhZ2VudCBzdGVwcyBmcm9tIGFuIGFycmF5XG4gICAgICovXG4gICAgcmVzdG9yZShzdGVwczogQWdlbnRTdGVwW10pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICBmb3IgKGNvbnN0IHN0ZXAgb2Ygc3RlcHMpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkU3RlcChzdGVwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgY3VycmVudCBzdGVwc1xuICAgICAqL1xuICAgIGdldFN0ZXBzKCk6IEFnZW50U3RlcFtdIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5hZ2VudFN0ZXBzLmtleXMoKSkubWFwKGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbYWN0aW9uLCB0YXJnZXRdID0ga2V5LnNwbGl0KCctJyk7XG4gICAgICAgICAgICBjb25zdCBzdGVwRWwgPSB0aGlzLmFnZW50U3RlcHMuZ2V0KGtleSkhO1xuICAgICAgICAgICAgY29uc3QgaWNvbiA9IHN0ZXBFbC5xdWVyeVNlbGVjdG9yKCcuYWdlbnQtc3RlcC1pY29uJyk/LnRleHRDb250ZW50IHx8ICdcdUQ4M0RcdUREMjcnO1xuICAgICAgICAgICAgcmV0dXJuIHsgaWNvbiwgYWN0aW9uLCB0YXJnZXQsIGtleSB9O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgZHVyYXRpb24gaW4gYSBodW1hbi1yZWFkYWJsZSB3YXlcbiAgICAgKi9cbiAgICBwcml2YXRlIGZvcm1hdER1cmF0aW9uKG1zOiBudW1iZXIpOiBzdHJpbmcge1xuICAgICAgICBpZiAobXMgPCAxMDAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7bXN9bXNgO1xuICAgICAgICB9IGVsc2UgaWYgKG1zIDwgNjAwMDApIHtcbiAgICAgICAgICAgIHJldHVybiBgJHsobXMgLyAxMDAwKS50b0ZpeGVkKDEpfXNgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbWludXRlcyA9IE1hdGguZmxvb3IobXMgLyA2MDAwMCk7XG4gICAgICAgICAgICBjb25zdCBzZWNvbmRzID0gTWF0aC5mbG9vcigobXMgJSA2MDAwMCkgLyAxMDAwKTtcbiAgICAgICAgICAgIHJldHVybiBgJHttaW51dGVzfW0gJHtzZWNvbmRzfXNgO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwgIi8qKlxuICogTm90ZSBDb250ZXh0IE1hbmFnZXIgLSBNYW5hZ2VzIHBlci1ub3RlIGNvbnZlcnNhdGlvbiBjb250ZXh0c1xuICovXG5cbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBjcnlwdG8gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IE5vdGVDb250ZXh0IH0gZnJvbSAnLi4vY29yZS90eXBlcyc7XG5pbXBvcnQgeyBDbGF1ZGVDb2RlUnVubmVyIH0gZnJvbSAnLi4vY29yZS9jbGF1ZGUtY29kZS1ydW5uZXInO1xuaW1wb3J0IHsgQ2xhdWRlQ29kZVNldHRpbmdzIH0gZnJvbSAnLi4vY29yZS9zZXR0aW5ncyc7XG5cbmludGVyZmFjZSBTZXNzaW9uRGF0YSB7XG4gICAgaGlzdG9yeT86IHVua25vd25bXTtcbiAgICBzZXNzaW9uSWQ/OiBzdHJpbmc7XG4gICAgb3V0cHV0TGluZXM/OiBzdHJpbmdbXTtcbiAgICBhZ2VudFN0ZXBzPzogdW5rbm93bltdO1xuICAgIG5vdGVQYXRoPzogc3RyaW5nO1xuICAgIHBlbmRpbmdQcmV2aWV3Q29udGVudD86IHN0cmluZztcbiAgICBvcmlnaW5hbFByZXZpZXdDb250ZW50Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgTm90ZUNvbnRleHRNYW5hZ2VyIHtcbiAgICBwcml2YXRlIGNvbnRleHRzOiBNYXA8c3RyaW5nLCBOb3RlQ29udGV4dD4gPSBuZXcgTWFwKCk7XG4gICAgcHJpdmF0ZSBzZXR0aW5nczogQ2xhdWRlQ29kZVNldHRpbmdzO1xuICAgIHByaXZhdGUgZGF0YURpcjogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3M6IENsYXVkZUNvZGVTZXR0aW5ncywgZGF0YURpcjogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgdGhpcy5kYXRhRGlyID0gZGF0YURpcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgb3IgY3JlYXRlIGNvbnRleHQgZm9yIGEgbm90ZVxuICAgICAqL1xuICAgIGdldENvbnRleHQobm90ZVBhdGg6IHN0cmluZyk6IE5vdGVDb250ZXh0IHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHRzLmhhcyhub3RlUGF0aCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dHMuc2V0KG5vdGVQYXRoLCB0aGlzLmNyZWF0ZU5ld0NvbnRleHQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dHMuZ2V0KG5vdGVQYXRoKSE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGVtcHR5IGNvbnRleHRcbiAgICAgKi9cbiAgICBwcml2YXRlIGNyZWF0ZU5ld0NvbnRleHQoKTogTm90ZUNvbnRleHQge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGlzdG9yeTogW10sXG4gICAgICAgICAgICBzZXNzaW9uSWQ6IG51bGwsXG4gICAgICAgICAgICBjdXJyZW50UmVzcG9uc2U6IG51bGwsXG4gICAgICAgICAgICBjdXJyZW50UmVxdWVzdDogbnVsbCxcbiAgICAgICAgICAgIG91dHB1dExpbmVzOiBbXSxcbiAgICAgICAgICAgIGFnZW50U3RlcHM6IFtdLFxuICAgICAgICAgICAgcnVubmVyOiBuZXcgQ2xhdWRlQ29kZVJ1bm5lcih0aGlzLnNldHRpbmdzKSxcbiAgICAgICAgICAgIGlzUnVubmluZzogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIGFsbCBub3RlIGNvbnRleHRzIGZyb20gZGlza1xuICAgICAqL1xuICAgIGxvYWRDb250ZXh0cyh2YXVsdFBhdGg6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBjb25zdCBjb250ZXh0c0RpciA9IHBhdGguam9pbih2YXVsdFBhdGgsIHRoaXMuZGF0YURpcik7XG5cbiAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGNvbnRleHRzRGlyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVhZCBhbGwgbm90ZSBjb250ZXh0IGRpcmVjdG9yaWVzXG4gICAgICAgIGNvbnN0IG5vdGVEaXJzID0gZnMucmVhZGRpclN5bmMoY29udGV4dHNEaXIpO1xuXG4gICAgICAgIGZvciAoY29uc3Qgbm90ZUhhc2ggb2Ygbm90ZURpcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHRGaWxlID0gcGF0aC5qb2luKGNvbnRleHRzRGlyLCBub3RlSGFzaCwgJ2NvbnRleHQuanNvbicpO1xuXG4gICAgICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhjb250ZXh0RmlsZSkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMoY29udGV4dEZpbGUsICd1dGY4JykpIGFzIFNlc3Npb25EYXRhO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY29uc3RydWN0IHRoZSBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHQ6IE5vdGVDb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGlzdG9yeTogKGRhdGEuaGlzdG9yeSA/PyBbXSkgYXMgTm90ZUNvbnRleHRbJ2hpc3RvcnknXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25JZDogZGF0YS5zZXNzaW9uSWQgPz8gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXNwb25zZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXF1ZXN0OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0TGluZXM6IGRhdGEub3V0cHV0TGluZXMgPz8gW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2VudFN0ZXBzOiAoZGF0YS5hZ2VudFN0ZXBzID8/IFtdKSBhcyBOb3RlQ29udGV4dFsnYWdlbnRTdGVwcyddLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmVyOiBuZXcgQ2xhdWRlQ29kZVJ1bm5lcih0aGlzLnNldHRpbmdzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUnVubmluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nUHJldmlld0NvbnRlbnQ6IGRhdGEucGVuZGluZ1ByZXZpZXdDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxQcmV2aWV3Q29udGVudDogZGF0YS5vcmlnaW5hbFByZXZpZXdDb250ZW50XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgdXNpbmcgdGhlIG5vdGUgcGF0aCBmcm9tIHRoZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLm5vdGVQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRzLnNldChkYXRhLm5vdGVQYXRoLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIGNvbnRleHRzIHRoYXQgZmFpbCB0byBsb2FkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2F2ZSBhIG5vdGUncyBjb250ZXh0IHRvIGRpc2tcbiAgICAgKi9cbiAgICBzYXZlQ29udGV4dChub3RlUGF0aDogc3RyaW5nLCB2YXVsdFBhdGg6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0cy5nZXQobm90ZVBhdGgpO1xuICAgICAgICBpZiAoIWNvbnRleHQpIHJldHVybjtcblxuICAgICAgICBjb25zdCBub3RlSGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKCdtZDUnKS51cGRhdGUobm90ZVBhdGgpLmRpZ2VzdCgnaGV4Jyk7XG4gICAgICAgIGNvbnN0IGNvbnRleHREaXIgPSBwYXRoLmpvaW4odmF1bHRQYXRoLCB0aGlzLmRhdGFEaXIsIG5vdGVIYXNoKTtcblxuICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoY29udGV4dERpcikpIHtcbiAgICAgICAgICAgIGZzLm1rZGlyU3luYyhjb250ZXh0RGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbnRleHRGaWxlID0gcGF0aC5qb2luKGNvbnRleHREaXIsICdjb250ZXh0Lmpzb24nKTtcblxuICAgICAgICBjb25zdCBkYXRhVG9TYXZlID0ge1xuICAgICAgICAgICAgbm90ZVBhdGg6IG5vdGVQYXRoLFxuICAgICAgICAgICAgc2Vzc2lvbklkOiBjb250ZXh0LnNlc3Npb25JZCxcbiAgICAgICAgICAgIGhpc3Rvcnk6IGNvbnRleHQuaGlzdG9yeSxcbiAgICAgICAgICAgIG91dHB1dExpbmVzOiBjb250ZXh0Lm91dHB1dExpbmVzLFxuICAgICAgICAgICAgYWdlbnRTdGVwczogY29udGV4dC5hZ2VudFN0ZXBzLFxuICAgICAgICAgICAgcGVuZGluZ1ByZXZpZXdDb250ZW50OiBjb250ZXh0LnBlbmRpbmdQcmV2aWV3Q29udGVudCxcbiAgICAgICAgICAgIG9yaWdpbmFsUHJldmlld0NvbnRlbnQ6IGNvbnRleHQub3JpZ2luYWxQcmV2aWV3Q29udGVudCxcbiAgICAgICAgICAgIHNhdmVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9O1xuXG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMoY29udGV4dEZpbGUsIEpTT04uc3RyaW5naWZ5KGRhdGFUb1NhdmUsIG51bGwsIDIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTYXZlIGFsbCBjb250ZXh0c1xuICAgICAqL1xuICAgIHNhdmVBbGxDb250ZXh0cyh2YXVsdFBhdGg6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBmb3IgKGNvbnN0IG5vdGVQYXRoIG9mIHRoaXMuY29udGV4dHMua2V5cygpKSB7XG4gICAgICAgICAgICB0aGlzLnNhdmVDb250ZXh0KG5vdGVQYXRoLCB2YXVsdFBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgaGlzdG9yeSBmb3IgYSBub3RlXG4gICAgICovXG4gICAgY2xlYXJIaXN0b3J5KG5vdGVQYXRoOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dHMuZ2V0KG5vdGVQYXRoKTtcbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnRleHQuaGlzdG9yeSA9IFtdO1xuICAgICAgICAgICAgY29udGV4dC5vdXRwdXRMaW5lcyA9IFtdO1xuICAgICAgICAgICAgY29udGV4dC5hZ2VudFN0ZXBzID0gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIGNvbnRleHRzXG4gICAgICovXG4gICAgZ2V0QWxsQ29udGV4dHMoKTogTWFwPHN0cmluZywgTm90ZUNvbnRleHQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBub3RlIGhhcyBhIGNvbnRleHRcbiAgICAgKi9cbiAgICBoYXNDb250ZXh0KG5vdGVQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dHMuaGFzKG5vdGVQYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY291bnQgb2YgcnVubmluZyBwcm9jZXNzZXNcbiAgICAgKi9cbiAgICBnZXRSdW5uaW5nQ291bnQoKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBjb250ZXh0IG9mIHRoaXMuY29udGV4dHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LmlzUnVubmluZykge1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBsaXN0IG9mIG5vdGUgcGF0aHMgdGhhdCBhcmUgY3VycmVudGx5IHJ1bm5pbmdcbiAgICAgKi9cbiAgICBnZXRSdW5uaW5nTm90ZVBhdGhzKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3QgcnVubmluZzogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBbbm90ZVBhdGgsIGNvbnRleHRdIG9mIHRoaXMuY29udGV4dHMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dC5pc1J1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBydW5uaW5nLnB1c2gobm90ZVBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW5uaW5nO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBDaGlsZFByb2Nlc3MgfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBTdHJpbmdEZWNvZGVyIH0gZnJvbSAnc3RyaW5nX2RlY29kZXInO1xuaW1wb3J0IHsgQ2xhdWRlQ29kZVNldHRpbmdzIH0gZnJvbSAnLi9zZXR0aW5ncyc7XG5pbXBvcnQgeyBTdHJlYW1FdmVudFByb2Nlc3NvciB9IGZyb20gJy4vc3RyZWFtaW5nL3N0cmVhbS1ldmVudC1wcm9jZXNzb3InO1xuaW1wb3J0IHsgU2Vzc2lvbk1hbmFnZXIgfSBmcm9tICcuL3Nlc3Npb24tbWFuYWdlcic7XG5pbXBvcnQgeyBQcm9tcHRCdWlsZGVyIH0gZnJvbSAnLi9wcm9tcHQtYnVpbGRlcic7XG5pbXBvcnQgeyBDbGlBcmdzQnVpbGRlciB9IGZyb20gJy4vY2xpLWFyZ3MtYnVpbGRlcic7XG5pbXBvcnQgeyBQcm9jZXNzU3Bhd25lciB9IGZyb20gJy4vcHJvY2Vzcy1zcGF3bmVyJztcbmltcG9ydCB7IFJlc3BvbnNlUGFyc2VyIH0gZnJvbSAnLi9yZXNwb25zZS1wYXJzZXInO1xuaW1wb3J0IHsgUmVzcG9uc2VDb250ZW50RXh0cmFjdG9yIH0gZnJvbSAnLi9zdHJlYW1pbmcvcmVzcG9uc2UtY29udGVudC1leHRyYWN0b3InO1xuXG5leHBvcnQgaW50ZXJmYWNlIENsYXVkZUNvZGVSZXF1ZXN0IHtcbiAgICBub3RlQ29udGVudDogc3RyaW5nO1xuICAgIHVzZXJQcm9tcHQ6IHN0cmluZztcbiAgICBub3RlUGF0aDogc3RyaW5nO1xuICAgIHNlbGVjdGVkVGV4dD86IHN0cmluZztcbiAgICB2YXVsdFBhdGg/OiBzdHJpbmc7XG4gICAgY29uZmlnRGlyOiBzdHJpbmc7ICAvLyBPYnNpZGlhbiBjb25maWcgZGlyZWN0b3J5IGZyb20gVmF1bHQuY29uZmlnRGlyXG4gICAgYnlwYXNzUGVybWlzc2lvbnM/OiBib29sZWFuO1xuICAgIHJ1bnRpbWVNb2RlbE92ZXJyaWRlPzogc3RyaW5nO1xuICAgIGNvbnZlcnNhdGlvbmFsTW9kZT86IGJvb2xlYW47ICAvLyBXaGVuIHRydWUsIG5vIGZpbGUgbW9kaWZpY2F0aW9ucyBhcmUgYWxsb3dlZFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENsYXVkZUNvZGVSZXNwb25zZSB7XG4gICAgc3VjY2VzczogYm9vbGVhbjtcbiAgICBtb2RpZmllZENvbnRlbnQ/OiBzdHJpbmc7XG4gICAgYXNzaXN0YW50TWVzc2FnZT86IHN0cmluZztcbiAgICBlcnJvcj86IHN0cmluZztcbiAgICBvdXRwdXQ6IHN0cmluZ1tdO1xuICAgIHRva2VuVXNhZ2U/OiB7XG4gICAgICAgIGlucHV0VG9rZW5zPzogbnVtYmVyO1xuICAgICAgICBvdXRwdXRUb2tlbnM/OiBudW1iZXI7XG4gICAgICAgIHRvdGFsVG9rZW5zPzogbnVtYmVyO1xuICAgIH07XG4gICAgaXNQZXJtaXNzaW9uUmVxdWVzdD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBDbGF1ZGVDb2RlUnVubmVyIHtcbiAgICBwcml2YXRlIHNldHRpbmdzOiBDbGF1ZGVDb2RlU2V0dGluZ3M7XG4gICAgcHJpdmF0ZSBjdXJyZW50UHJvY2VzczogQ2hpbGRQcm9jZXNzIHwgbnVsbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBvdXRwdXRDYWxsYmFjazogKChsaW5lOiBzdHJpbmcsIGlzTWFya2Rvd24/OiBib29sZWFuLCBpc1N0cmVhbWluZz86IGJvb2xlYW4gfCBzdHJpbmcsIGlzQXNzaXN0YW50TWVzc2FnZT86IGJvb2xlYW4pID0+IHZvaWQpIHwgbnVsbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBjdXJyZW50U2Vzc2lvbklkOiBzdHJpbmcgfCBudWxsID0gbnVsbDsgIC8vIFN0b3JlIHNlc3Npb24gSUQgZnJvbSBpbml0IGV2ZW50XG5cbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5nczogQ2xhdWRlQ29kZVNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW4gQ2xhdWRlIENvZGUgd2l0aCB0aGUgZ2l2ZW4gcmVxdWVzdFxuICAgICAqL1xuICAgIGFzeW5jIHJ1bihyZXF1ZXN0OiBDbGF1ZGVDb2RlUmVxdWVzdCwgb25PdXRwdXQ/OiAobGluZTogc3RyaW5nLCBpc01hcmtkb3duPzogYm9vbGVhbiwgaXNTdHJlYW1pbmc/OiBib29sZWFuIHwgc3RyaW5nKSA9PiB2b2lkKTogUHJvbWlzZTxDbGF1ZGVDb2RlUmVzcG9uc2U+IHtcbiAgICAgICAgdGhpcy5vdXRwdXRDYWxsYmFjayA9IG9uT3V0cHV0IHx8IG51bGw7XG5cbiAgICAgICAgbGV0IGNsYXVkZVBhdGggPSB0aGlzLnNldHRpbmdzLmNsYXVkZUNvZGVQYXRoIHx8ICdjbGF1ZGUnO1xuXG4gICAgICAgIC8vIEV4cGFuZCB+IHRvIGhvbWUgZGlyZWN0b3J5ICh1c2UgVVNFUlBST0ZJTEUgb24gV2luZG93cywgSE9NRSBvbiBVbml4KVxuICAgICAgICBpZiAoY2xhdWRlUGF0aC5zdGFydHNXaXRoKCd+JykpIHtcbiAgICAgICAgICAgIGNvbnN0IGhvbWVEaXIgPSBwcm9jZXNzLmVudi5IT01FIHx8IHByb2Nlc3MuZW52LlVTRVJQUk9GSUxFIHx8ICcnO1xuICAgICAgICAgICAgY2xhdWRlUGF0aCA9IGNsYXVkZVBhdGgucmVwbGFjZSgnficsIGhvbWVEaXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgdGhhdCBDbGF1ZGUgQ29kZSBpcyBhdmFpbGFibGVcbiAgICAgICAgaWYgKCFjbGF1ZGVQYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiAnQ2xhdWRlIENvZGUgcGF0aCBub3QgY29uZmlndXJlZC4gUGxlYXNlIHNldCBpdCBpbiBwbHVnaW4gc2V0dGluZ3MuJyxcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmV4ZWN1dGVDbGF1ZGVDb2RlKGNsYXVkZVBhdGgsIHJlcXVlc3QpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogYEZhaWxlZCB0byBleGVjdXRlIENsYXVkZSBDb2RlOiAke2Vycm9yfWAsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgQ2xhdWRlIENvZGUgcHJvY2VzcyBhbmQgY2FwdHVyZSBvdXRwdXRcbiAgICAgKi9cbiAgICBwcml2YXRlIGFzeW5jIGV4ZWN1dGVDbGF1ZGVDb2RlKFxuICAgICAgICBjbGF1ZGVQYXRoOiBzdHJpbmcsXG4gICAgICAgIHJlcXVlc3Q6IENsYXVkZUNvZGVSZXF1ZXN0XG4gICAgKTogUHJvbWlzZTxDbGF1ZGVDb2RlUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXQ6IHN0cmluZ1tdID0gW107XG4gICAgICAgICAgICBsZXQgZXJyb3JPdXRwdXQgPSAnJztcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7ICAvLyBUcmFjayBvdmVyYWxsIGV4ZWN1dGlvbiB0aW1lXG5cbiAgICAgICAgICAgIC8vIDEuIFNldHVwIHNlc3Npb25cbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JbmZvID0gU2Vzc2lvbk1hbmFnZXIuZ2V0U2Vzc2lvbkluZm8oXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5ub3RlUGF0aCxcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnZhdWx0UGF0aCB8fCAnJyxcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmNvbmZpZ0RpclxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhpcy5zZW5kT3V0cHV0KHNlc3Npb25JbmZvLmlzTmV3U2Vzc2lvblxuICAgICAgICAgICAgICAgID8gYFx1MjE5MiBTdGFydGluZyBuZXcgc2Vzc2lvblxcbmBcbiAgICAgICAgICAgICAgICA6IGBcdTI3MTMgUmVzdW1pbmcgc2Vzc2lvbjogJHtzZXNzaW9uSW5mby5zZXNzaW9uSWR9XFxuYFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gMWEuIENyZWF0ZSBub3RlLm1kIGZpbGUgaW4gc2Vzc2lvbiBkaXJlY3RvcnkgZm9yIENsYXVkZSB0byBlZGl0XG4gICAgICAgICAgICBjb25zdCBub3RlRmlsZVBhdGggPSBwYXRoLmpvaW4oc2Vzc2lvbkluZm8uc2Vzc2lvbkRpciwgJ25vdGUubWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRUb0VkaXQgPSByZXF1ZXN0LnNlbGVjdGVkVGV4dCB8fCByZXF1ZXN0Lm5vdGVDb250ZW50O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmcy53cml0ZUZpbGVTeW5jKG5vdGVGaWxlUGF0aCwgY29udGVudFRvRWRpdCwgJ3V0ZjgnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRPdXRwdXQoYFx1RDgzRFx1RENERCBDcmVhdGVkIG5vdGUubWQgZm9yIGVkaXRpbmdcXG5gKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRPdXRwdXQoYFx1MjZBMFx1RkUwRiBFcnJvciBjcmVhdGluZyBub3RlLm1kOiAke2V9XFxuYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIDIuIEJ1aWxkIHByb21wdFxuICAgICAgICAgICAgY29uc3QgZnVsbFByb21wdCA9IFByb21wdEJ1aWxkZXIuYnVpbGRQcm9tcHQoXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBzZXNzaW9uSW5mby5zZXNzaW9uRGlyLFxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuY3VzdG9tU3lzdGVtUHJvbXB0LFxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuYWxsb3dWYXVsdEFjY2VzcyxcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmVuYWJsZVBlcm1pc3Npb25sZXNzTW9kZSB8fCByZXF1ZXN0LmJ5cGFzc1Blcm1pc3Npb25zXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyAzLiBCdWlsZCBDTEkgYXJndW1lbnRzXG4gICAgICAgICAgICBjb25zdCBhcmdzID0gQ2xpQXJnc0J1aWxkZXIuYnVpbGRBcmdzKHtcbiAgICAgICAgICAgICAgICBzZXR0aW5nczogdGhpcy5zZXR0aW5ncyxcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQ6IHNlc3Npb25JbmZvLnNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICB2YXVsdFBhdGg6IHJlcXVlc3QudmF1bHRQYXRoIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgYnlwYXNzUGVybWlzc2lvbnM6IHJlcXVlc3QuYnlwYXNzUGVybWlzc2lvbnMgfHwgZmFsc2UsXG4gICAgICAgICAgICAgICAgcnVudGltZU1vZGVsT3ZlcnJpZGU6IHJlcXVlc3QucnVudGltZU1vZGVsT3ZlcnJpZGVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBPdXRwdXQgY29uZmlndXJhdGlvbiBpbmZvXG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5lbmFibGVQZXJtaXNzaW9ubGVzc01vZGUgfHwgcmVxdWVzdC5ieXBhc3NQZXJtaXNzaW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZE91dHB1dChgXHVEODNEXHVERDEzIFBlcm1pc3Npb25sZXNzIG1vZGUgZW5hYmxlZFxcbmApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRPdXRwdXQoYFx1RDgzRFx1REQxMiBQZXJtaXNzaW9uIG1vZGU6IGludGVyYWN0aXZlIChDbGF1ZGUgd2lsbCBhc2sgZm9yIHBlcm1pc3Npb24pXFxuYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmFsbG93VmF1bHRBY2Nlc3MgJiYgcmVxdWVzdC52YXVsdFBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRPdXRwdXQoYFZhdWx0IGFjY2VzcyBlbmFibGVkOiAke3JlcXVlc3QudmF1bHRQYXRofVxcbmApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyA0LiBTcGF3biBwcm9jZXNzXG4gICAgICAgICAgICBjb25zdCB3b3JraW5nRGlyID0gcmVxdWVzdC52YXVsdFBhdGggfHwgcHJvY2Vzcy5jd2QoKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZE91dHB1dChgV29ya2luZyBkaXI6ICR7d29ya2luZ0Rpcn1cXG5gKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZE91dHB1dChgU3RhcnRpbmcgQ2xhdWRlIENvZGUuLi5cXG5gKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZE91dHB1dChgU2Vzc2lvbiBkaXJlY3Rvcnk6ICR7c2Vzc2lvbkluZm8uc2Vzc2lvbkRpcn1cXG5gKTtcblxuICAgICAgICAgICAgLy8gRGVidWcgZW52aXJvbm1lbnQgYmVmb3JlIHNwYXduaW5nXG4gICAgICAgICAgICB0aGlzLnNlbmRPdXRwdXQoYFtERUJVR10gQ2hlY2tpbmcgZW52aXJvbm1lbnQuLi5cXG5gKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZE91dHB1dChgW0RFQlVHXSBTSEVMTDogJHtwcm9jZXNzLmVudi5TSEVMTH1cXG5gKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZE91dHB1dChgW0RFQlVHXSBIT01FOiAke3Byb2Nlc3MuZW52LkhPTUV9XFxuYCk7XG4gICAgICAgICAgICB0aGlzLnNlbmRPdXRwdXQoYFtERUJVR10gQ2xhdWRlIHBhdGg6ICR7Y2xhdWRlUGF0aH1cXG5gKTtcblxuICAgICAgICAgICAgLy8gQnVpbGQgY3VzdG9tIGVudmlyb25tZW50IHZhcmlhYmxlcyBmcm9tIHNldHRpbmdzXG4gICAgICAgICAgICBjb25zdCBjdXN0b21FbnZWYXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5hbnRocm9waWNCYXNlVXJsKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tRW52VmFyc1snQU5USFJPUElDX0JBU0VfVVJMJ10gPSB0aGlzLnNldHRpbmdzLmFudGhyb3BpY0Jhc2VVcmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5hbnRocm9waWNBdXRoVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjdXN0b21FbnZWYXJzWydBTlRIUk9QSUNfQVVUSF9UT0tFTiddID0gdGhpcy5zZXR0aW5ncy5hbnRocm9waWNBdXRoVG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5hbnRocm9waWNNb2RlbCkge1xuICAgICAgICAgICAgICAgIGN1c3RvbUVudlZhcnNbJ0FOVEhST1BJQ19NT0RFTCddID0gdGhpcy5zZXR0aW5ncy5hbnRocm9waWNNb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmFudGhyb3BpY1NtYWxsRmFzdE1vZGVsKSB7XG4gICAgICAgICAgICAgICAgY3VzdG9tRW52VmFyc1snQU5USFJPUElDX1NNQUxMX0ZBU1RfTU9ERUwnXSA9IHRoaXMuc2V0dGluZ3MuYW50aHJvcGljU21hbGxGYXN0TW9kZWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UHJvY2VzcyA9IFByb2Nlc3NTcGF3bmVyLnNwYXduKHtcbiAgICAgICAgICAgICAgICAgICAgY2xhdWRlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgd29ya2luZ0RpcixcbiAgICAgICAgICAgICAgICAgICAgb25EZWJ1Z091dHB1dDogKG1zZykgPT4gdGhpcy5zZW5kT3V0cHV0KG1zZyksXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbUVudlZhcnM6IE9iamVjdC5rZXlzKGN1c3RvbUVudlZhcnMpLmxlbmd0aCA+IDAgPyBjdXN0b21FbnZWYXJzIDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kT3V0cHV0KGBbREVCVUddIFByb2Nlc3Mgc3Bhd25lZCBzdWNjZXNzZnVsbHksIFBJRDogJHt0aGlzLmN1cnJlbnRQcm9jZXNzLnBpZH1cXG5gKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHNwYXduRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRPdXRwdXQoYFxcblx1Mjc0QyBGYWlsZWQgdG8gc3Bhd24gcHJvY2VzczogJHtzcGF3bkVycm9yfWApO1xuICAgICAgICAgICAgICAgIHRocm93IHNwYXduRXJyb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIDUuIFNlbmQgcHJvbXB0IHZpYSBzdGRpblxuICAgICAgICAgICAgUHJvY2Vzc1NwYXduZXIuc2VuZElucHV0KHRoaXMuY3VycmVudFByb2Nlc3MsIGZ1bGxQcm9tcHQpO1xuXG4gICAgICAgICAgICAvLyBTZXQgdGltZW91dCBpZiBjb25maWd1cmVkXG4gICAgICAgICAgICBsZXQgdGltZW91dElkOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudGltZW91dFNlY29uZHMgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRQcm9jZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRPdXRwdXQoYFxcblRpbWVvdXQgYWZ0ZXIgJHt0aGlzLnNldHRpbmdzLnRpbWVvdXRTZWNvbmRzfSBzZWNvbmRzLCB0ZXJtaW5hdGluZy4uLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UHJvY2Vzcy5raWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzLnNldHRpbmdzLnRpbWVvdXRTZWNvbmRzICogMTAwMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhcHR1cmUgc3Rkb3V0IChzdHJlYW0tanNvbiBmb3JtYXQgLSBvbmUgSlNPTiBvYmplY3QgcGVyIGxpbmUpXG4gICAgICAgICAgICAvLyBVc2UgU3RyaW5nRGVjb2RlciB0byBwcm9wZXJseSBoYW5kbGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAvLyB0aGF0IG1heSBiZSBzcGxpdCBhY3Jvc3MgY2h1bmsgYm91bmRhcmllcyAoZS5nLiwgXHUwMEJELCBcdTAwQkMsIFx1MDBCRSwgZXRjLilcbiAgICAgICAgICAgIGNvbnN0IHN0ZG91dERlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcigndXRmOCcpO1xuICAgICAgICAgICAgbGV0IGJ1ZmZlciA9ICcnO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UHJvY2Vzcy5zdGRvdXQ/Lm9uKCdkYXRhJywgKGRhdGE6IEJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFVzZSBTdHJpbmdEZWNvZGVyIHRvIHByb3Blcmx5IGRlY29kZSBVVEYtOCwgaGFuZGxpbmcgc3BsaXQgbXVsdGktYnl0ZSBjaGFyc1xuICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBzdGRvdXREZWNvZGVyLndyaXRlKGRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gYnVmZmVyLnNwbGl0KCdcXG4nKTtcblxuICAgICAgICAgICAgICAgIC8vIEtlZXAgdGhlIGxhc3QgaW5jb21wbGV0ZSBsaW5lIGluIHRoZSBidWZmZXJcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBsaW5lcy5wb3AoKSB8fCAnJztcblxuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgY29tcGxldGUgbGluZXNcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsaW5lLnRyaW0oKSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gSlNPTi5wYXJzZShsaW5lKSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coZXZlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChsaW5lKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgZXZlbnQgKHdpbGwgaGFuZGxlIHN0cmVhbWluZyBvdXRwdXQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVN0cmVhbUV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRPdXRwdXQoYFtyYXddICR7bGluZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBDYXB0dXJlIHN0ZGVyciAoYWxzbyB1c2UgU3RyaW5nRGVjb2RlciBmb3IgcHJvcGVyIFVURi04IGhhbmRsaW5nKVxuICAgICAgICAgICAgY29uc3Qgc3RkZXJyRGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKCd1dGY4Jyk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9jZXNzLnN0ZGVycj8ub24oJ2RhdGEnLCAoZGF0YTogQnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IHN0ZGVyckRlY29kZXIud3JpdGUoZGF0YSk7XG4gICAgICAgICAgICAgICAgZXJyb3JPdXRwdXQgKz0gdGV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRPdXRwdXQoYFtzdGRlcnJdICR7dGV4dH1gKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBBZGQgZGVidWcgbG9nZ2luZ1xuICAgICAgICAgICAgdGhpcy5zZW5kT3V0cHV0KGBcXG5bREVCVUddIFByb2Nlc3Mgc3Bhd25lZCwgUElEOiAke3RoaXMuY3VycmVudFByb2Nlc3MucGlkfWApO1xuICAgICAgICAgICAgdGhpcy5zZW5kT3V0cHV0KGBbREVCVUddIFdvcmtpbmcgZGlyOiAke3dvcmtpbmdEaXJ9YCk7XG4gICAgICAgICAgICB0aGlzLnNlbmRPdXRwdXQoYFtERUJVR10gU2Vzc2lvbiBkaXI6ICR7c2Vzc2lvbkluZm8uc2Vzc2lvbkRpcn1gKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZE91dHB1dChgW0RFQlVHXSBXYWl0aW5nIGZvciBvdXRwdXQuLi5cXG5gKTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlIHByb2Nlc3MgZXhpdCAoaGFwcGVucyBiZWZvcmUgY2xvc2UpXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9jZXNzLm9uKCdleGl0JywgKGNvZGU6IG51bWJlciwgc2lnbmFsOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRPdXRwdXQoYFxcbltERUJVR10gUHJvY2VzcyBleGl0ZWQgd2l0aCBjb2RlOiAke2NvZGV9LCBzaWduYWw6ICR7c2lnbmFsfWApO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBwcm9jZXNzIGNvbXBsZXRpb25cbiAgICAgICAgICAgIHRoaXMuY3VycmVudFByb2Nlc3Mub24oJ2Nsb3NlJywgKGNvZGU6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZE91dHB1dChgXFxuW0RFQlVHXSBQcm9jZXNzIGNsb3NlZCB3aXRoIGNvZGU6ICR7Y29kZX1gKTtcblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIC5jbGF1ZGUgZGlyZWN0b3J5IHdhcyBjcmVhdGVkIChkZWJ1ZyBvbmx5KVxuICAgICAgICAgICAgICAgIGNvbnN0IGNsYXVkZURpciA9IHBhdGguam9pbihzZXNzaW9uSW5mby5zZXNzaW9uRGlyLCAnLmNsYXVkZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsYXVkZURpckNyZWF0ZWQgPSBmcy5leGlzdHNTeW5jKGNsYXVkZURpcik7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kT3V0cHV0KGBcXG5bREVCVUddIC5jbGF1ZGUgZGlyZWN0b3J5IGFmdGVyIHJ1bjogJHtjbGF1ZGVEaXJDcmVhdGVkID8gJ0VYSVNUUycgOiAnTk9UIEZPVU5EJ31gKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xhdWRlRGlyQ3JlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBMaXN0IGNvbnRlbnRzXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50cyA9IGZzLnJlYWRkaXJTeW5jKGNsYXVkZURpcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRPdXRwdXQoYFxcbltERUJVR10gLmNsYXVkZSBjb250ZW50czogJHtjb250ZW50cy5qb2luKCcsICcpfWApO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRPdXRwdXQoYFxcbltERUJVR10gRXJyb3IgcmVhZGluZyAuY2xhdWRlOiAke2V9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFByb2Nlc3MgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kT3V0cHV0KGBcXG5bREVCVUddIFByb2Nlc3NpbmcgJHtvdXRwdXQubGVuZ3RofSBvdXRwdXQgbGluZXNgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyA2LiBQYXJzZSBvdXRwdXRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gUmVzcG9uc2VQYXJzZXIucGFyc2VPdXRwdXQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNQZXJtaXNzaW9uUmVxdWVzdCA9IFJlc3BvbnNlQ29udGVudEV4dHJhY3Rvci5kZXRlY3RQZXJtaXNzaW9uUmVxdWVzdChwYXJzZWQuYXNzaXN0YW50VGV4dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kT3V0cHV0KGBcXG5bREVCVUddIEZ1bGwgcmVzcG9uc2UgbGVuZ3RoOiAke3BhcnNlZC5hc3Npc3RhbnRUZXh0Lmxlbmd0aH0gY2hhcnNgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyA3LiBSZWFkIHRoZSBtb2RpZmllZCBub3RlLm1kIGZpbGUgKGlmIGl0IHdhcyBtb2RpZmllZClcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1vZGlmaWVkQ29udGVudDogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMobm90ZUZpbGVQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdGVDb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKG5vdGVGaWxlUGF0aCwgJ3V0ZjgnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGNvbnRlbnQgYWN0dWFsbHkgY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub3RlQ29udGVudCAhPT0gY29udGVudFRvRWRpdCAmJiAhcmVxdWVzdC5jb252ZXJzYXRpb25hbE1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRDb250ZW50ID0gbm90ZUNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZE91dHB1dChgXFxuXHUyNzA1IG5vdGUubWQgd2FzIG1vZGlmaWVkIGJ5IENsYXVkZVxcbmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZE91dHB1dChgXFxuIFx1MjEzOVx1RkUwRiAgbm90ZS5tZCB1bmNoYW5nZWQgKGxpa2VseSBhIHF1ZXN0aW9uL2FuYWx5c2lzKVxcbmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kT3V0cHV0KGBcXG5cdTI2QTBcdUZFMEYgIG5vdGUubWQgbm90IGZvdW5kIGFmdGVyIGV4ZWN1dGlvblxcbmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRPdXRwdXQoYFxcblx1MjZBMFx1RkUwRiAgRXJyb3IgcmVhZGluZyBub3RlLm1kOiAke2V9XFxuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyA4LiBTYXZlIHNlc3Npb24gZGF0YVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgU2Vzc2lvbk1hbmFnZXIuc2F2ZUNvbnZlcnNhdGlvbkhpc3RvcnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbkluZm8uc2Vzc2lvbkRpcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnVzZXJQcm9tcHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkLmFzc2lzdGFudFRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRPdXRwdXQoYFxcblx1RDgzRFx1RENCRSBDb252ZXJzYXRpb24gaGlzdG9yeSBzYXZlZFxcbmApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2Vzc2lvbklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU2Vzc2lvbk1hbmFnZXIuc2F2ZVNlc3Npb25JZChzZXNzaW9uSW5mby5zZXNzaW9uRGlyLCB0aGlzLmN1cnJlbnRTZXNzaW9uSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZE91dHB1dChgXHVEODNEXHVEQ0JFIFNlc3Npb24gSUQgc2F2ZWQ6ICR7dGhpcy5jdXJyZW50U2Vzc2lvbklkfVxcbmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRPdXRwdXQoYFxcblx1MjZBMCBFcnJvciBzYXZpbmcgc2Vzc2lvbiBkYXRhOiAke2V9XFxuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyA5LiBCdWlsZCBhbmQgcmV0dXJuIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvdGFsRHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZTogQ2xhdWRlQ29kZVJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkQ29udGVudDogbW9kaWZpZWRDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzaXN0YW50TWVzc2FnZTogcGFyc2VkLmFzc2lzdGFudFRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IG91dHB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuVXNhZ2U6IHBhcnNlZC50b2tlblVzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQZXJtaXNzaW9uUmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kaWZpZWRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kT3V0cHV0KGBcXG5cdTI3MTMgQ2xhdWRlIENvZGUgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSBpbiAkeyh0b3RhbER1cmF0aW9uIC8gMTAwMCkudG9GaXhlZCgyKX1zYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzUGVybWlzc2lvblJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRPdXRwdXQoYFxcblx1MjZBMFx1RkUwRiBQZXJtaXNzaW9uIHJlcXVlc3QgZGV0ZWN0ZWQgLSB3YWl0aW5nIGZvciB1c2VyIGFwcHJvdmFsYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZE91dHB1dChgXFxuXHUyNzEzIEFuYWx5c2lzIGNvbXBsZXRlZCAobm8gZmlsZSBtb2RpZmljYXRpb25zKSBpbiAkeyh0b3RhbER1cmF0aW9uIC8gMTAwMCkudG9GaXhlZCgyKX1zYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBFcnJvclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRPdXRwdXQoYFxcblx1MjcxNyBDbGF1ZGUgQ29kZSBmYWlsZWQgd2l0aCBjb2RlICR7Y29kZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yT3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRPdXRwdXQoYEVycm9yIG91dHB1dDogJHtlcnJvck91dHB1dH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoUmVzcG9uc2VQYXJzZXIuYnVpbGRFcnJvclJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgYENsYXVkZSBDb2RlIGV4aXRlZCB3aXRoIGNvZGUgJHtjb2RlfS4gJHtlcnJvck91dHB1dH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0XG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGUgcHJvY2VzcyBlcnJvcnNcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFByb2Nlc3Mub24oJ2Vycm9yJywgKGVycjogRXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFByb2Nlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZE91dHB1dChgXFxuXHUyNzE3IEVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShSZXNwb25zZVBhcnNlci5idWlsZEVycm9yUmVzcG9uc2UoXG4gICAgICAgICAgICAgICAgICAgIGBGYWlsZWQgdG8gc3Bhd24gQ2xhdWRlIENvZGU6ICR7ZXJyLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0XG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZCBpbnB1dCB0byB0aGUgY3VycmVudCBDbGF1ZGUgQ29kZSBwcm9jZXNzIHN0ZGluXG4gICAgICovXG4gICAgc2VuZElucHV0KGlucHV0OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFByb2Nlc3MgJiYgdGhpcy5jdXJyZW50UHJvY2Vzcy5zdGRpbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9jZXNzLnN0ZGluLndyaXRlKGlucHV0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRPdXRwdXQoYFxcbltVc2VyIGlucHV0IHNlbnRdOiAke2lucHV0LnRyaW0oKX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHdyaXRlIHRvIHN0ZGluOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRPdXRwdXQoYFxcblx1MjcxNyBGYWlsZWQgdG8gc2VuZCBpbnB1dDogJHtlcnJvcn1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcignQ2Fubm90IHNlbmQgaW5wdXQ6IG5vIGFjdGl2ZSBwcm9jZXNzIG9yIHN0ZGluIG5vdCBhdmFpbGFibGUnKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlcm1pbmF0ZSB0aGUgY3VycmVudCBDbGF1ZGUgQ29kZSBwcm9jZXNzIGlmIHJ1bm5pbmdcbiAgICAgKi9cbiAgICB0ZXJtaW5hdGUoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQcm9jZXNzKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9jZXNzLmtpbGwoKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFByb2Nlc3MgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zZW5kT3V0cHV0KCdcXG5cdTI2QTAgUHJvY2VzcyB0ZXJtaW5hdGVkIGJ5IHVzZXInKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIENsYXVkZSBDb2RlIGlzIGN1cnJlbnRseSBydW5uaW5nXG4gICAgICovXG4gICAgaXNSdW5uaW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50UHJvY2VzcyAhPT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgc3RyZWFtLWpzb24gZXZlbnRzXG4gICAgICovXG4gICAgcHJpdmF0ZSBoYW5kbGVTdHJlYW1FdmVudChldmVudDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiB2b2lkIHtcbiAgICAgICAgLy8gRXZlbnQgY29tZXMgZnJvbSBKU09OLnBhcnNlIG9mIENMSSBvdXRwdXQgLSBoYXMgaW5kZXggc2lnbmF0dXJlIGNvbXBhdGlibGUgd2l0aCBTdHJlYW1FdmVudERhdGFcbiAgICAgICAgU3RyZWFtRXZlbnRQcm9jZXNzb3IucHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgZXZlbnQgYXMgUGFyYW1ldGVyczx0eXBlb2YgU3RyZWFtRXZlbnRQcm9jZXNzb3IucHJvY2Vzc0V2ZW50PlswXSxcbiAgICAgICAgICAgICh0ZXh0OiBzdHJpbmcsIGlzTWFya2Rvd24/OiBib29sZWFuLCBpc1N0cmVhbWluZz86IGJvb2xlYW4gfCAnZmluaXNoJywgaXNBc3Npc3RhbnRNZXNzYWdlPzogYm9vbGVhbikgPT4gdGhpcy5zZW5kT3V0cHV0KHRleHQsIGlzTWFya2Rvd24sIGlzU3RyZWFtaW5nLCBpc0Fzc2lzdGFudE1lc3NhZ2UpLFxuICAgICAgICAgICAgKHNlc3Npb25JZDogc3RyaW5nKSA9PiB7IHRoaXMuY3VycmVudFNlc3Npb25JZCA9IHNlc3Npb25JZDsgfVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmQgb3V0cHV0IHRvIGNhbGxiYWNrXG4gICAgICovXG4gICAgcHJpdmF0ZSBzZW5kT3V0cHV0KHRleHQ6IHN0cmluZywgaXNNYXJrZG93bjogYm9vbGVhbiA9IGZhbHNlLCBpc1N0cmVhbWluZz86IGJvb2xlYW4gfCBzdHJpbmcsIGlzQXNzaXN0YW50TWVzc2FnZT86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0Q2FsbGJhY2sodGV4dCwgaXNNYXJrZG93biwgaXNTdHJlYW1pbmcsIGlzQXNzaXN0YW50TWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsICIvKipcbiAqIFRvb2wgaW5wdXQgdHlwZSAtIGZsZXhpYmxlIHJlY29yZCBmb3IgdmFyaW91cyB0b29sIGlucHV0c1xuICovXG5pbnRlcmZhY2UgVG9vbElucHV0IHtcbiAgICBjb21tYW5kPzogc3RyaW5nO1xuICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICAgIHF1ZXJ5Pzogc3RyaW5nO1xuICAgIGFsbG93ZWRfZG9tYWlucz86IHN0cmluZ1tdO1xuICAgIGJsb2NrZWRfZG9tYWlucz86IHN0cmluZ1tdO1xuICAgIHVybD86IHN0cmluZztcbiAgICBwcm9tcHQ/OiBzdHJpbmc7XG4gICAgcGF0dGVybj86IHN0cmluZztcbiAgICBwYXRoPzogc3RyaW5nO1xuICAgIG91dHB1dF9tb2RlPzogc3RyaW5nO1xuICAgIGZpbGVfcGF0aD86IHN0cmluZztcbiAgICBvZmZzZXQ/OiBudW1iZXI7XG4gICAgbGltaXQ/OiBudW1iZXI7XG4gICAgY29udGVudD86IHN0cmluZztcbiAgICByZXBsYWNlX2FsbD86IGJvb2xlYW47XG4gICAgc3ViYWdlbnRfdHlwZT86IHN0cmluZztcbiAgICB0b2Rvcz86IHVua25vd247XG4gICAgW2tleTogc3RyaW5nXTogdW5rbm93bjtcbn1cblxuLyoqXG4gKiBUb29sIHJlc3VsdCB0eXBlIC0gY2FuIGJlIHZhcmlvdXMgc2hhcGVzIGRlcGVuZGluZyBvbiB0aGUgdG9vbFxuICovXG50eXBlIFRvb2xSZXN1bHQgPSB7IHN0ZG91dD86IHN0cmluZzsgW2tleTogc3RyaW5nXTogdW5rbm93biB9IHwgc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBVdGlsaXR5IGZvciBmb3JtYXR0aW5nIHRvb2wgdXNhZ2UgaW5mb3JtYXRpb24gaW4gYSBjb25zaXN0ZW50IHdheVxuICovXG5leHBvcnQgY2xhc3MgVG9vbE91dHB1dEZvcm1hdHRlciB7XG4gICAgLyoqXG4gICAgICogRm9ybWF0IHRvb2wgdXNhZ2UgaW5mb3JtYXRpb24gZnJvbSB0b29sX3VzZSBldmVudCBvciBtZXNzYWdlIGJsb2NrXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9vbE5hbWUgTmFtZSBvZiB0aGUgdG9vbCBiZWluZyB1c2VkXG4gICAgICogQHBhcmFtIHRvb2xJbnB1dCBJbnB1dCBwYXJhbWV0ZXJzIGZvciB0aGUgdG9vbFxuICAgICAqIEBwYXJhbSBmb3JtYXQgRm9ybWF0IHN0eWxlOiAnY29tcGFjdCcgZm9yIG1lc3NhZ2UgYmxvY2tzLCAndmVyYm9zZScgZm9yIGV2ZW50c1xuICAgICAqIEByZXR1cm5zIEFycmF5IG9mIGZvcm1hdHRlZCBvdXRwdXQgbGluZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgZm9ybWF0VG9vbFVzYWdlKHRvb2xOYW1lOiBzdHJpbmcsIHRvb2xJbnB1dDogVG9vbElucHV0LCBmb3JtYXQ6ICdjb21wYWN0JyB8ICd2ZXJib3NlJyA9ICdjb21wYWN0Jyk6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3QgbGluZXM6IHN0cmluZ1tdID0gW107XG5cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ3ZlcmJvc2UnKSB7XG4gICAgICAgICAgICAvLyBVc2VkIGZvciB0b29sX3VzZSBldmVudHMgLSBtb3JlIHZlcmJvc2UgaGVhZGVyc1xuICAgICAgICAgICAgbGluZXMucHVzaCguLi50aGlzLmZvcm1hdFZlcmJvc2VIZWFkZXIodG9vbE5hbWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvcm1hdCB0b29sLXNwZWNpZmljIHBhcmFtZXRlcnNcbiAgICAgICAgbGluZXMucHVzaCguLi50aGlzLmZvcm1hdFRvb2xTcGVjaWZpY1BhcmFtcyh0b29sTmFtZSwgdG9vbElucHV0LCBmb3JtYXQpKTtcblxuICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IHZlcmJvc2UgaGVhZGVyIGZvciB0b29sX3VzZSBldmVudHNcbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBmb3JtYXRWZXJib3NlSGVhZGVyKHRvb2xOYW1lOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gICAgICAgICAgICAnQmFzaCc6ICdcXG5cdUQ4M0RcdUREMjcgQmFzaCBleGVjdXRpbmc6XFxuJyxcbiAgICAgICAgICAgICdHbG9iJzogJ1xcblx1RDgzRFx1REQwRCBHbG9iIHNlYXJjaGluZzpcXG4nLFxuICAgICAgICAgICAgJ0dyZXAnOiAnXFxuXHVEODNEXHVERDBFIEdyZXAgc2VhcmNoaW5nOlxcbicsXG4gICAgICAgICAgICAnUmVhZCc6ICdcXG5cdUQ4M0RcdURDRDYgUmVhZGluZyBmaWxlOlxcbicsXG4gICAgICAgICAgICAnV3JpdGUnOiAnXFxuXHUyNzBEXHVGRTBGICBXcml0aW5nIGZpbGU6XFxuJyxcbiAgICAgICAgICAgICdFZGl0JzogJ1xcblx1MjcwRlx1RkUwRiAgRWRpdGluZyBmaWxlOlxcbicsXG4gICAgICAgICAgICAnV2ViRmV0Y2gnOiAnXFxuXHVEODNDXHVERjEwIEZldGNoaW5nIHdlYnBhZ2U6XFxuJyxcbiAgICAgICAgICAgICdXZWJTZWFyY2gnOiAnXFxuXHVEODNEXHVERDBEIFdlYiBzZWFyY2hpbmc6XFxuJyxcbiAgICAgICAgICAgICdUYXNrJzogJ1xcblx1RDgzRVx1REQxNiBMYXVuY2hpbmcgYWdlbnQ6XFxuJ1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBbaGVhZGVyc1t0b29sTmFtZV0gfHwgYFxcblx1RDgzRFx1REVFMFx1RkUwRiAgJHt0b29sTmFtZX06XFxuYF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IHRvb2wtc3BlY2lmaWMgcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIGZvcm1hdFRvb2xTcGVjaWZpY1BhcmFtcyh0b29sTmFtZTogc3RyaW5nLCB0b29sSW5wdXQ6IFRvb2xJbnB1dCwgZm9ybWF0OiAnY29tcGFjdCcgfCAndmVyYm9zZScpOiBzdHJpbmdbXSB7XG4gICAgICAgIGNvbnN0IGxpbmVzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICAgIGlmICghdG9vbElucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHRvb2xOYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdCYXNoJzpcbiAgICAgICAgICAgICAgICBpZiAodG9vbElucHV0LmNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaChgICAgJCAke3Rvb2xJbnB1dC5jb21tYW5kfVxcbmApO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9vbElucHV0LmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGAgICBcdUQ4M0RcdURDREQgJHt0b29sSW5wdXQuZGVzY3JpcHRpb259XFxuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ1dlYlNlYXJjaCc6XG4gICAgICAgICAgICAgICAgaWYgKHRvb2xJbnB1dC5xdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXggPSBmb3JtYXQgPT09ICdjb21wYWN0JyA/ICcgICBcdUQ4M0RcdUREMEQgUXVlcnk6JyA6ICcgICBRdWVyeTonO1xuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGAke3ByZWZpeH0gXCIke3Rvb2xJbnB1dC5xdWVyeX1cIlxcbmApO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9vbElucHV0LmFsbG93ZWRfZG9tYWlucz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsYWJlbCA9IGZvcm1hdCA9PT0gJ2NvbXBhY3QnID8gJyAgIFx1MjcxMyBBbGxvd2VkOicgOiAnICAgQWxsb3dlZCBkb21haW5zOic7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGAke2xhYmVsfSAke3Rvb2xJbnB1dC5hbGxvd2VkX2RvbWFpbnMuam9pbignLCAnKX1cXG5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodG9vbElucHV0LmJsb2NrZWRfZG9tYWlucz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsYWJlbCA9IGZvcm1hdCA9PT0gJ2NvbXBhY3QnID8gJyAgIFx1MjcxNyBCbG9ja2VkOicgOiAnICAgQmxvY2tlZCBkb21haW5zOic7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGAke2xhYmVsfSAke3Rvb2xJbnB1dC5ibG9ja2VkX2RvbWFpbnMuam9pbignLCAnKX1cXG5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnV2ViRmV0Y2gnOlxuICAgICAgICAgICAgICAgIGlmICh0b29sSW5wdXQudXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IGZvcm1hdCA9PT0gJ2NvbXBhY3QnID8gJyAgIFx1RDgzQ1x1REYxMCBVUkw6JyA6ICcgICBVUkw6JztcbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaChgJHtwcmVmaXh9ICR7dG9vbElucHV0LnVybH1cXG5gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvb2xJbnB1dC5wcm9tcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gZm9ybWF0ID09PSAnY29tcGFjdCcgPyAnICAgXHVEODNEXHVEQ0NCIFRhc2s6JyA6ICcgICBUYXNrOic7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cnVuY2F0ZWQgPSB0b29sSW5wdXQucHJvbXB0LnN1YnN0cmluZygwLCBmb3JtYXQgPT09ICdjb21wYWN0JyA/IDEwMCA6IDE1MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGxpcHNpcyA9IHRvb2xJbnB1dC5wcm9tcHQubGVuZ3RoID4gKGZvcm1hdCA9PT0gJ2NvbXBhY3QnID8gMTAwIDogMTUwKSA/ICcuLi4nIDogJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGAke2xhYmVsfSAke3RydW5jYXRlZH0ke2VsbGlwc2lzfVxcbmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdHbG9iJzpcbiAgICAgICAgICAgICAgICBpZiAodG9vbElucHV0LnBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gZm9ybWF0ID09PSAnY29tcGFjdCcgPyAnICAgXHVEODNEXHVERDBEIFBhdHRlcm46JyA6ICcgICBQYXR0ZXJuOic7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goYCR7cHJlZml4fSAke3Rvb2xJbnB1dC5wYXR0ZXJufVxcbmApO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9vbElucHV0LnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlYXJjaFBhdGggPSBmb3JtYXQgPT09ICd2ZXJib3NlJyA/IHRvb2xJbnB1dC5wYXRoIDogdG9vbElucHV0LnBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGAgICBcdUQ4M0RcdURDQzEgUGF0aDogJHtzZWFyY2hQYXRofVxcbmApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ3ZlcmJvc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGAgICBQYXRoOiAuXFxuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ0dyZXAnOlxuICAgICAgICAgICAgICAgIGlmICh0b29sSW5wdXQucGF0dGVybikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXggPSBmb3JtYXQgPT09ICdjb21wYWN0JyA/ICcgICBcdUQ4M0RcdUREMEUgUGF0dGVybjonIDogJyAgIFBhdHRlcm46JztcbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaChgJHtwcmVmaXh9IFwiJHt0b29sSW5wdXQucGF0dGVybn1cIlxcbmApO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9vbElucHV0LnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlYXJjaFBhdGggPSBmb3JtYXQgPT09ICd2ZXJib3NlJyA/IHRvb2xJbnB1dC5wYXRoIDogdG9vbElucHV0LnBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGAgICBcdUQ4M0RcdURDQzEgUGF0aDogJHtzZWFyY2hQYXRofVxcbmApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ3ZlcmJvc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGAgICBQYXRoOiAuXFxuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvb2xJbnB1dC5vdXRwdXRfbW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBmb3JtYXQgPT09ICdjb21wYWN0JyA/ICcgICBcdUQ4M0RcdURDQ0EgTW9kZTonIDogJyAgIE1vZGU6JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goYCR7bGFiZWx9ICR7dG9vbElucHV0Lm91dHB1dF9tb2RlfVxcbmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdSZWFkJzpcbiAgICAgICAgICAgICAgICBpZiAodG9vbElucHV0LmZpbGVfcGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXggPSBmb3JtYXQgPT09ICdjb21wYWN0JyA/ICcgICBcdUQ4M0RcdURDRDYgRmlsZTonIDogJyAgICc7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goYCR7cHJlZml4fSR7dG9vbElucHV0LmZpbGVfcGF0aH1cXG5gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ3ZlcmJvc2UnICYmICh0b29sSW5wdXQub2Zmc2V0IHx8IHRvb2xJbnB1dC5saW1pdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdG9vbElucHV0Lm9mZnNldCB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kID0gdG9vbElucHV0LmxpbWl0ID8gc3RhcnQgKyB0b29sSW5wdXQubGltaXQgOiAnRU9GJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goYCAgIExpbmVzOiAke3N0YXJ0fSB0byAke2VuZH1cXG5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnV3JpdGUnOlxuICAgICAgICAgICAgICAgIGlmICh0b29sSW5wdXQuZmlsZV9wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IGZvcm1hdCA9PT0gJ2NvbXBhY3QnID8gJyAgIFx1MjcwRFx1RkUwRiAgRmlsZTonIDogJyAgICc7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goYCR7cHJlZml4fSR7dG9vbElucHV0LmZpbGVfcGF0aH1cXG5gKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IHRvb2xJbnB1dC5jb250ZW50Py5sZW5ndGggfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBmb3JtYXQgPT09ICdjb21wYWN0JyA/ICcgICBcdUQ4M0RcdURDQ0YgU2l6ZTonIDogJyAgIFNpemU6JztcbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaChgJHtsYWJlbH0gJHtjb250ZW50TGVuZ3RofSBjaGFyJHtjb250ZW50TGVuZ3RoID09PSAxID8gJycgOiAncyd9XFxuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdFZGl0JzpcbiAgICAgICAgICAgICAgICBpZiAodG9vbElucHV0LmZpbGVfcGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXggPSBmb3JtYXQgPT09ICdjb21wYWN0JyA/ICcgICBcdTI3MEZcdUZFMEYgIEZpbGU6JyA6ICcgICAnO1xuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGAke3ByZWZpeH0ke3Rvb2xJbnB1dC5maWxlX3BhdGh9XFxuYCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICd2ZXJib3NlJyAmJiB0b29sSW5wdXQucmVwbGFjZV9hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goYCAgIE1vZGU6IFJlcGxhY2UgYWxsIG9jY3VycmVuY2VzXFxuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ1Rhc2snOlxuICAgICAgICAgICAgICAgIGlmICh0b29sSW5wdXQuc3ViYWdlbnRfdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXggPSBmb3JtYXQgPT09ICdjb21wYWN0JyA/ICcgICBcdUQ4M0VcdUREMTYgQWdlbnQ6JyA6ICcgICBUeXBlOic7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goYCR7cHJlZml4fSAke3Rvb2xJbnB1dC5zdWJhZ2VudF90eXBlfVxcbmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9vbElucHV0LmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goYCAgIFx1RDgzRFx1RENDQiBUYXNrOiAke3Rvb2xJbnB1dC5kZXNjcmlwdGlvbn1cXG5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ3ZlcmJvc2UnICYmIHRvb2xJbnB1dC5wcm9tcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hvcnRQcm9tcHQgPSB0b29sSW5wdXQucHJvbXB0LnN1YnN0cmluZygwLCAxNTApO1xuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGAgICBQcm9tcHQ6ICR7c2hvcnRQcm9tcHR9JHt0b29sSW5wdXQucHJvbXB0Lmxlbmd0aCA+IDE1MCA/ICcuLi4nIDogJyd9XFxuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdUb2RvV3JpdGUnOiB7XG4gICAgICAgICAgICAgICAgLy8gVG9kb1dyaXRlIG5lZWRzIHRoZSBmdWxsIEpTT04gZm9yIHBhcnNpbmcsIHNvIGRvbid0IHRydW5jYXRlXG4gICAgICAgICAgICAgICAgY29uc3QgdG9kb0lucHV0U3RyID0gSlNPTi5zdHJpbmdpZnkodG9vbElucHV0LCBudWxsLCAyKTtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGAgICAke3RvZG9JbnB1dFN0cn1cXG5gKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIC8vIEdlbmVyaWMgZGlzcGxheSBmb3Igb3RoZXIgdG9vbHNcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dFN0ciA9IEpTT04uc3RyaW5naWZ5KHRvb2xJbnB1dCwgbnVsbCwgMik7XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2NvbXBhY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVzQXJyID0gaW5wdXRTdHIuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZXNBcnIubGVuZ3RoID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goYCAgICR7bGluZXNBcnIuc2xpY2UoMCwgMTApLmpvaW4oJ1xcbicpfVxcbiAgIC4uLlxcbmApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaChgICAgJHtpbnB1dFN0cn1cXG5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFN0ci5sZW5ndGggPiAzMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goYCAgICR7aW5wdXRTdHIuc3Vic3RyaW5nKDAsIDMwMCl9Li4uXFxuYCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGAgICAke2lucHV0U3RyfVxcbmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcm1hdCB0b29sIHJlc3VsdCBvdXRwdXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b29sTmFtZSBOYW1lIG9mIHRoZSB0b29sXG4gICAgICogQHBhcmFtIHJlc3VsdCBSZXN1bHQgb2JqZWN0IGZyb20gdGhlIHRvb2xcbiAgICAgKiBAcmV0dXJucyBBcnJheSBvZiBmb3JtYXR0ZWQgb3V0cHV0IGxpbmVzXG4gICAgICovXG4gICAgc3RhdGljIGZvcm1hdFRvb2xSZXN1bHQodG9vbE5hbWU6IHN0cmluZywgcmVzdWx0OiBUb29sUmVzdWx0KTogc3RyaW5nW10ge1xuICAgICAgICBjb25zdCBsaW5lczogc3RyaW5nW10gPSBbXTtcblxuICAgICAgICBpZiAodG9vbE5hbWUgPT09ICdCYXNoJyAmJiByZXN1bHQgJiYgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0ZG91dCA9IHJlc3VsdC5zdGRvdXQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0ZG91dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBzdGRvdXQudHJpbSgpO1xuICAgICAgICAgICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0TGluZXMgPSBvdXRwdXQuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGAgICBcdTI3MTMgT3V0cHV0ICgke291dHB1dExpbmVzLmxlbmd0aH0gbGluZXMpOlxcbmApO1xuICAgICAgICAgICAgICAgICAgICAvLyBTaG93IGZpcnN0IGZldyBsaW5lcyBvZiBvdXRwdXRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlldyA9IG91dHB1dExpbmVzLnNsaWNlKDAsIDMpLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGAgICAke3ByZXZpZXd9JHtvdXRwdXRMaW5lcy5sZW5ndGggPiAzID8gJ1xcbiAgIC4uLicgOiAnJ31cXG5gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGAgICBcdTI3MTMgJHt0b29sTmFtZX0gY29tcGxldGVcXG5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goYCAgIFx1MjcxMyAke3Rvb2xOYW1lfSBjb21wbGV0ZVxcbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgbGluZXMucHVzaChgICAgXHUyNzEzICR7dG9vbE5hbWV9IGNvbXBsZXRlXFxuYCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IFRvb2xPdXRwdXRGb3JtYXR0ZXIgfSBmcm9tICcuL3Rvb2wtb3V0cHV0LWZvcm1hdHRlcic7XG5cbi8qKlxuICogT3V0cHV0IGNhbGxiYWNrIHR5cGUgZm9yIHN0cmVhbSBldmVudCBwcm9jZXNzaW5nXG4gKi9cbmV4cG9ydCB0eXBlIE91dHB1dENhbGxiYWNrID0gKHRleHQ6IHN0cmluZywgaXNNYXJrZG93bj86IGJvb2xlYW4sIGlzU3RyZWFtaW5nPzogYm9vbGVhbiB8ICdmaW5pc2gnLCBpc0Fzc2lzdGFudE1lc3NhZ2U/OiBib29sZWFuKSA9PiB2b2lkO1xuXG4vKipcbiAqIFNlc3Npb24gSUQgY2FsbGJhY2sgdHlwZSBmb3Igc3RvcmluZyBzZXNzaW9uIGluZm9ybWF0aW9uXG4gKi9cbmV4cG9ydCB0eXBlIFNlc3Npb25JZENhbGxiYWNrID0gKHNlc3Npb25JZDogc3RyaW5nKSA9PiB2b2lkO1xuXG4vKipcbiAqIFN0cmVhbSBldmVudCBmcm9tIENsYXVkZSBDb2RlIENMSSAtIHVzZXMgaW5kZXggc2lnbmF0dXJlIHRvIGF2b2lkICdhbnknXG4gKi9cbmludGVyZmFjZSBTdHJlYW1FdmVudERhdGEge1xuICAgIHR5cGU6IHN0cmluZztcbiAgICBzdWJ0eXBlPzogc3RyaW5nO1xuICAgIG1vZGVsPzogc3RyaW5nO1xuICAgIHRvb2xzPzogc3RyaW5nW107XG4gICAgc2Vzc2lvbl9pZD86IHN0cmluZztcbiAgICBtZXNzYWdlPzoge1xuICAgICAgICBjb250ZW50PzogQXJyYXk8e1xuICAgICAgICAgICAgdHlwZTogc3RyaW5nO1xuICAgICAgICAgICAgdGV4dD86IHN0cmluZztcbiAgICAgICAgICAgIG5hbWU/OiBzdHJpbmc7XG4gICAgICAgICAgICBpbnB1dD86IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgICAgICAgICAgdG9vbF91c2VfaWQ/OiBzdHJpbmc7XG4gICAgICAgICAgICBjb250ZW50PzogdW5rbm93bjtcbiAgICAgICAgfT47XG4gICAgfTtcbiAgICB0b29sX25hbWU/OiBzdHJpbmc7XG4gICAgaW5wdXQ/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICByZXN1bHQ/OiBzdHJpbmcgfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICBkdXJhdGlvbl9tcz86IG51bWJlcjtcbiAgICB0b3RhbF9jb3N0X3VzZD86IG51bWJlcjtcbiAgICB1c2FnZT86IHtcbiAgICAgICAgaW5wdXRfdG9rZW5zOiBudW1iZXI7XG4gICAgICAgIG91dHB1dF90b2tlbnM6IG51bWJlcjtcbiAgICB9O1xuICAgIGV2ZW50Pzoge1xuICAgICAgICB0eXBlOiBzdHJpbmc7XG4gICAgICAgIGRlbHRhPzoge1xuICAgICAgICAgICAgdHlwZTogc3RyaW5nO1xuICAgICAgICAgICAgdGV4dD86IHN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgY29udGVudF9ibG9jaz86IHtcbiAgICAgICAgICAgIHR5cGU6IHN0cmluZztcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFtrZXk6IHN0cmluZ106IHVua25vd247XG59XG5cbi8qKlxuICogVXRpbGl0eSBmb3IgcHJvY2Vzc2luZyBzdHJlYW0gZXZlbnRzIGZyb20gQ2xhdWRlIENvZGUgQ0xJXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJlYW1FdmVudFByb2Nlc3NvciB7XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhIHNpbmdsZSBzdHJlYW0gZXZlbnQgYW5kIGdlbmVyYXRlIG91dHB1dFxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBzdHJlYW0gZXZlbnQgdG8gcHJvY2Vzc1xuICAgICAqIEBwYXJhbSBzZW5kT3V0cHV0IENhbGxiYWNrIHRvIHNlbmQgb3V0cHV0IHRleHRcbiAgICAgKiBAcGFyYW0gc2V0U2Vzc2lvbklkIE9wdGlvbmFsIGNhbGxiYWNrIHRvIHN0b3JlIHNlc3Npb24gSURcbiAgICAgKi9cbiAgICBzdGF0aWMgcHJvY2Vzc0V2ZW50KFxuICAgICAgICBldmVudDogU3RyZWFtRXZlbnREYXRhLFxuICAgICAgICBzZW5kT3V0cHV0OiBPdXRwdXRDYWxsYmFjayxcbiAgICAgICAgc2V0U2Vzc2lvbklkPzogU2Vzc2lvbklkQ2FsbGJhY2tcbiAgICApOiB2b2lkIHtcbiAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzeXN0ZW0nOlxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU3lzdGVtRXZlbnQoZXZlbnQsIHNlbmRPdXRwdXQsIHNldFNlc3Npb25JZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2Fzc2lzdGFudCc6XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVBc3Npc3RhbnRFdmVudChldmVudCwgc2VuZE91dHB1dCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3Rvb2xfdXNlJzpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVRvb2xVc2VFdmVudChldmVudCwgc2VuZE91dHB1dCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3VzZXInOlxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVXNlckV2ZW50KGV2ZW50LCBzZW5kT3V0cHV0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAncmVzdWx0JzpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlc3VsdEV2ZW50KGV2ZW50LCBzZW5kT3V0cHV0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnc3RyZWFtX2V2ZW50JzpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVN0cmVhbUV2ZW50KGV2ZW50LCBzZW5kT3V0cHV0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVVua25vd25FdmVudChldmVudCwgc2VuZE91dHB1dCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgc3lzdGVtIGluaXRpYWxpemF0aW9uIGV2ZW50c1xuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIGhhbmRsZVN5c3RlbUV2ZW50KFxuICAgICAgICBldmVudDogU3RyZWFtRXZlbnREYXRhLFxuICAgICAgICBzZW5kT3V0cHV0OiBPdXRwdXRDYWxsYmFjayxcbiAgICAgICAgc2V0U2Vzc2lvbklkPzogU2Vzc2lvbklkQ2FsbGJhY2tcbiAgICApOiB2b2lkIHtcbiAgICAgICAgaWYgKGV2ZW50LnN1YnR5cGUgPT09ICdpbml0Jykge1xuICAgICAgICAgICAgc2VuZE91dHB1dChgXFxuXHVEODNEXHVERDI3IFNlc3Npb24gaW5pdGlhbGl6ZWQ6ICR7ZXZlbnQubW9kZWx9XFxuYCk7XG4gICAgICAgICAgICBzZW5kT3V0cHV0KGBcdUQ4M0RcdURDRTYgQXZhaWxhYmxlIHRvb2xzOiAke2V2ZW50LnRvb2xzPy5qb2luKCcsICcpIHx8ICdub25lJ31cXG5gKTtcblxuICAgICAgICAgICAgLy8gU3RvcmUgc2Vzc2lvbl9pZCBmb3IgZnV0dXJlIC0tcmVzdW1lIHVzYWdlXG4gICAgICAgICAgICBpZiAoZXZlbnQuc2Vzc2lvbl9pZCAmJiBzZXRTZXNzaW9uSWQpIHtcbiAgICAgICAgICAgICAgICBzZXRTZXNzaW9uSWQoZXZlbnQuc2Vzc2lvbl9pZCk7XG4gICAgICAgICAgICAgICAgc2VuZE91dHB1dChgXHVEODNEXHVEQ0JFIFNlc3Npb24gSUQ6ICR7ZXZlbnQuc2Vzc2lvbl9pZH1cXG5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhc3Npc3RhbnQgbWVzc2FnZSBldmVudHNcbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBoYW5kbGVBc3Npc3RhbnRFdmVudChldmVudDogU3RyZWFtRXZlbnREYXRhLCBzZW5kT3V0cHV0OiBPdXRwdXRDYWxsYmFjayk6IHZvaWQge1xuICAgICAgICAvLyBFeHRyYWN0IHRleHQgY29udGVudCBmcm9tIGFzc2lzdGFudCBtZXNzYWdlXG4gICAgICAgIGlmIChldmVudC5tZXNzYWdlPy5jb250ZW50KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJsb2NrIG9mIGV2ZW50Lm1lc3NhZ2UuY29udGVudCkge1xuICAgICAgICAgICAgICAgIGlmIChibG9jay50eXBlID09PSAndGV4dCcgJiYgYmxvY2sudGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZW5kIGFzc2lzdGFudCB0ZXh0IGFzIG1hcmtkb3duIGZvciByZW5kZXJpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFyayBhcyBhc3Npc3RhbnQgbWVzc2FnZSBzbyBpdCBjYW4gYmUgc2hvd24gaW4gUmVzdWx0IHNlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgc2VuZE91dHB1dChibG9jay50ZXh0LCB0cnVlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChibG9jay50eXBlID09PSAndG9vbF91c2UnICYmIGJsb2NrLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGlzcGxheSBkZXRhaWxlZCB0b29sIHVzYWdlIGZyb20gYXNzaXN0YW50IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9vbE5hbWUgPSBibG9jay5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sSW5wdXQgPSBibG9jay5pbnB1dCB8fCB7fTtcblxuICAgICAgICAgICAgICAgICAgICBzZW5kT3V0cHV0KGBcXG5cdUQ4M0RcdUREMjcgVXNpbmcgdG9vbDogJHt0b29sTmFtZX1cXG5gKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgZm9ybWF0dGVyIGZvciB0b29sLXNwZWNpZmljIHBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkID0gVG9vbE91dHB1dEZvcm1hdHRlci5mb3JtYXRUb29sVXNhZ2UodG9vbE5hbWUsIHRvb2xJbnB1dCwgJ2NvbXBhY3QnKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGZvcm1hdHRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZE91dHB1dChsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0b29sIHVzZSBldmVudHNcbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBoYW5kbGVUb29sVXNlRXZlbnQoZXZlbnQ6IFN0cmVhbUV2ZW50RGF0YSwgc2VuZE91dHB1dDogT3V0cHV0Q2FsbGJhY2spOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdG9vbE5hbWUgPSBldmVudC50b29sX25hbWUgfHwgJ3Vua25vd24nO1xuXG4gICAgICAgIGlmIChldmVudC5zdWJ0eXBlID09PSAnaW5wdXQnICYmIGV2ZW50LmlucHV0KSB7XG4gICAgICAgICAgICAvLyBVc2UgZm9ybWF0dGVyIGZvciB0b29sLXNwZWNpZmljIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZCA9IFRvb2xPdXRwdXRGb3JtYXR0ZXIuZm9ybWF0VG9vbFVzYWdlKHRvb2xOYW1lLCBldmVudC5pbnB1dCwgJ3ZlcmJvc2UnKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBmb3JtYXR0ZWQpIHtcbiAgICAgICAgICAgICAgICBzZW5kT3V0cHV0KGxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnN1YnR5cGUgPT09ICdyZXN1bHQnKSB7XG4gICAgICAgICAgICAvLyBTaG93IHJlc3VsdCBzdW1tYXJ5IGZvciBzb21lIHRvb2xzXG4gICAgICAgICAgICBjb25zdCByZXN1bHRMaW5lcyA9IFRvb2xPdXRwdXRGb3JtYXR0ZXIuZm9ybWF0VG9vbFJlc3VsdCh0b29sTmFtZSwgZXZlbnQucmVzdWx0KTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGluZSBvZiByZXN1bHRMaW5lcykge1xuICAgICAgICAgICAgICAgIHNlbmRPdXRwdXQobGluZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIEdsb2IvR3JlcCByZXN1bHQgY291bnRzXG4gICAgICAgICAgICBpZiAoKHRvb2xOYW1lID09PSAnR2xvYicgfHwgdG9vbE5hbWUgPT09ICdHcmVwJykgJiYgZXZlbnQucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0U3RyID0gdHlwZW9mIGV2ZW50LnJlc3VsdCA9PT0gJ3N0cmluZycgPyBldmVudC5yZXN1bHQgOiBKU09OLnN0cmluZ2lmeShldmVudC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gcmVzdWx0U3RyLnNwbGl0KCdcXG4nKS5maWx0ZXIoKGw6IHN0cmluZykgPT4gbC50cmltKCkpO1xuICAgICAgICAgICAgICAgIHNlbmRPdXRwdXQoYCAgIFx1MjcxMyBGb3VuZCAke2xpbmVzLmxlbmd0aH0gcmVzdWx0c1xcbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIHVzZXIvdG9vbCByZXN1bHQgZXZlbnRzXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgaGFuZGxlVXNlckV2ZW50KGV2ZW50OiBTdHJlYW1FdmVudERhdGEsIHNlbmRPdXRwdXQ6IE91dHB1dENhbGxiYWNrKTogdm9pZCB7XG4gICAgICAgIC8vIFRvb2wgcmVzdWx0cyBjb21pbmcgYmFjayBmcm9tIENsYXVkZSBDb2RlXG4gICAgICAgIGlmIChldmVudC5tZXNzYWdlPy5jb250ZW50KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGJsb2NrIG9mIGV2ZW50Lm1lc3NhZ2UuY29udGVudCkge1xuICAgICAgICAgICAgICAgIGlmIChibG9jay50eXBlID09PSAndG9vbF9yZXN1bHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRPdXRwdXQoYFxcblx1RDgzRFx1RENFNSBUb29sIHJlc3VsdCAoJHtibG9jay50b29sX3VzZV9pZH0pOlxcbmApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIERpc3BsYXkgcmVzdWx0IGNvbnRlbnQgKHRydW5jYXRlIGlmIHRvbyBsb25nKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gdHlwZW9mIGJsb2NrLmNvbnRlbnQgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGJsb2NrLmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkoYmxvY2suY29udGVudCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZXMgPSBjb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kT3V0cHV0KGAgICAke2xpbmVzLnNsaWNlKDAsIDEwKS5qb2luKCdcXG4nKX1cXG5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRPdXRwdXQoYCAgIC4uLiAoJHtsaW5lcy5sZW5ndGggLSAxMH0gbW9yZSBsaW5lcylcXG5gKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb250ZW50Lmxlbmd0aCA+IDUwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZE91dHB1dChgICAgJHtjb250ZW50LnN1YnN0cmluZygwLCA1MDApfS4uLlxcbmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZE91dHB1dChgICAgKCR7Y29udGVudC5sZW5ndGggLSA1MDB9IG1vcmUgY2hhcmFjdGVycylcXG5gKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRPdXRwdXQoYCAgICR7Y29udGVudH1cXG5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBmaW5hbCByZXN1bHQgZXZlbnRzXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgaGFuZGxlUmVzdWx0RXZlbnQoZXZlbnQ6IFN0cmVhbUV2ZW50RGF0YSwgc2VuZE91dHB1dDogT3V0cHV0Q2FsbGJhY2spOiB2b2lkIHtcbiAgICAgICAgc2VuZE91dHB1dChgXFxuXHUyNzA1IENvbXBsZXRlIVxcbmApO1xuICAgICAgICBzZW5kT3V0cHV0KGBcdTIzRjFcdUZFMEYgIER1cmF0aW9uOiAke2V2ZW50LmR1cmF0aW9uX21zfW1zXFxuYCk7XG4gICAgICAgIHNlbmRPdXRwdXQoYFx1RDgzRFx1RENCMCBDb3N0OiAkJHtldmVudC50b3RhbF9jb3N0X3VzZD8udG9GaXhlZCg0KSB8fCAnMC4wMDAwJ31cXG5gKTtcbiAgICAgICAgaWYgKGV2ZW50LnVzYWdlKSB7XG4gICAgICAgICAgICBzZW5kT3V0cHV0KGBcdUQ4M0RcdURDQ0EgVG9rZW5zOiAke2V2ZW50LnVzYWdlLmlucHV0X3Rva2Vuc30gaW4sICR7ZXZlbnQudXNhZ2Uub3V0cHV0X3Rva2Vuc30gb3V0XFxuYCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgcmVhbC10aW1lIHN0cmVhbWluZyBldmVudHNcbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBoYW5kbGVTdHJlYW1FdmVudChldmVudDogU3RyZWFtRXZlbnREYXRhLCBzZW5kT3V0cHV0OiBPdXRwdXRDYWxsYmFjayk6IHZvaWQge1xuICAgICAgICAvLyBUaGUgYWN0dWFsIGV2ZW50IGlzIG5lc3RlZCBpbnNpZGUgZXZlbnQuZXZlbnRcbiAgICAgICAgY29uc3Qgc3RyZWFtRXZlbnQgPSBldmVudC5ldmVudDtcbiAgICAgICAgaWYgKCFzdHJlYW1FdmVudCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIFJlYWwtdGltZSBzdHJlYW1pbmcgZXZlbnRzIHdpdGggdGV4dCBkZWx0YXNcbiAgICAgICAgaWYgKHN0cmVhbUV2ZW50LnR5cGUgPT09ICdjb250ZW50X2Jsb2NrX2RlbHRhJykge1xuICAgICAgICAgICAgaWYgKHN0cmVhbUV2ZW50LmRlbHRhPy50eXBlID09PSAndGV4dF9kZWx0YScgJiYgc3RyZWFtRXZlbnQuZGVsdGEudGV4dCkge1xuICAgICAgICAgICAgICAgIC8vIFN0cmVhbSB0ZXh0IGluIHJlYWwtdGltZSAtIG1hcmsgYXMgc3RyZWFtaW5nIHRvIGFjY3VtdWxhdGVcbiAgICAgICAgICAgICAgICAvLyBBbHNvIG1hcmsgYXMgYXNzaXN0YW50IG1lc3NhZ2UgZm9yIFJlc3VsdCBzZWN0aW9uXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnW1N0cmVhbSBQcm9jZXNzb3JdIFNlbmRpbmcgdGV4dCBkZWx0YSBhcyBhc3Npc3RhbnQgbWVzc2FnZScpO1xuICAgICAgICAgICAgICAgIHNlbmRPdXRwdXQoc3RyZWFtRXZlbnQuZGVsdGEudGV4dCwgZmFsc2UsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbUV2ZW50LnR5cGUgPT09ICdjb250ZW50X2Jsb2NrX3N0YXJ0Jykge1xuICAgICAgICAgICAgLy8gU3RhcnQgb2YgbmV3IGNvbnRlbnQgYmxvY2sgKHRleHQgb3IgdG9vbCB1c2UpXG4gICAgICAgICAgICBpZiAoc3RyZWFtRXZlbnQuY29udGVudF9ibG9jaz8udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgLy8gVGV4dCBibG9jayBzdGFydGluZ1xuICAgICAgICAgICAgICAgIHNlbmRPdXRwdXQoYFxcblx1RDgzRFx1RENBQyBDbGF1ZGU6IGAsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtRXZlbnQudHlwZSA9PT0gJ2NvbnRlbnRfYmxvY2tfc3RvcCcpIHtcbiAgICAgICAgICAgIC8vIEVuZCBvZiBjb250ZW50IGJsb2NrIC0gc2lnbmFsIGVuZCBvZiBzdHJlYW1pbmdcbiAgICAgICAgICAgIC8vIE1hcmsgYXMgYXNzaXN0YW50IG1lc3NhZ2Ugc28gdGhlIHJlc3VsdCBzdHJlYW1pbmcgZmluaXNoZXMgcHJvcGVybHlcbiAgICAgICAgICAgIHNlbmRPdXRwdXQoYFxcbmAsIGZhbHNlLCAnZmluaXNoJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdW5rbm93biBldmVudCB0eXBlcyAoZGVidWdnaW5nKVxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIGhhbmRsZVVua25vd25FdmVudChldmVudDogU3RyZWFtRXZlbnREYXRhLCBzZW5kT3V0cHV0OiBPdXRwdXRDYWxsYmFjayk6IHZvaWQge1xuICAgICAgICAvLyBEaXNwbGF5IEFMTCB1bmtub3duIGV2ZW50cyBmb3IgZGVidWdnaW5nXG4gICAgICAgIHNlbmRPdXRwdXQoYFxcblx1RDgzRFx1REQwRCBbJHtldmVudC50eXBlfSR7ZXZlbnQuc3VidHlwZSA/ICcgLyAnICsgZXZlbnQuc3VidHlwZSA6ICcnfV1cXG5gKTtcblxuICAgICAgICAvLyBTaG93IGtleSBmaWVsZHMgZnJvbSB0aGUgZXZlbnRcbiAgICAgICAgY29uc3QgZGlzcGxheUZpZWxkcyA9IFsnc2Vzc2lvbl9pZCcsICd1dWlkJywgJ2R1cmF0aW9uX21zJywgJ21vZGVsJywgJ2lzX2Vycm9yJ10gYXMgY29uc3Q7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgZGlzcGxheUZpZWxkcykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBldmVudFtmaWVsZF07XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNlbmRPdXRwdXQoYCAgICR7ZmllbGR9OiAke1N0cmluZyh2YWx1ZSl9XFxuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaG93IG1lc3NhZ2UgY29udGVudCBpZiBwcmVzZW50XG4gICAgICAgIGlmIChldmVudC5tZXNzYWdlKSB7XG4gICAgICAgICAgICBzZW5kT3V0cHV0KGAgICBtZXNzYWdlOiAke0pTT04uc3RyaW5naWZ5KGV2ZW50Lm1lc3NhZ2UpLnN1YnN0cmluZygwLCAyMDApfS4uLlxcbmApO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwgImltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBjcnlwdG8gZnJvbSAnY3J5cHRvJztcblxuLyoqXG4gKiBTZXNzaW9uIGluZm9ybWF0aW9uIGZvciBhIG5vdGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uSW5mbyB7XG4gICAgc2Vzc2lvbkRpcjogc3RyaW5nO1xuICAgIHNlc3Npb25JZDogc3RyaW5nIHwgbnVsbDtcbiAgICBpc05ld1Nlc3Npb246IGJvb2xlYW47XG59XG5cbi8qKlxuICogTWFuYWdlcyBwZXJzaXN0ZW50IHNlc3Npb24gZGlyZWN0b3JpZXMgYW5kIElEcyBmb3IgQ2xhdWRlIENvZGVcbiAqL1xuZXhwb3J0IGNsYXNzIFNlc3Npb25NYW5hZ2VyIHtcbiAgICAvKipcbiAgICAgKiBHZXQgb3IgY3JlYXRlIHNlc3Npb24gZGlyZWN0b3J5IGZvciBhIG5vdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBub3RlUGF0aCBQYXRoIHRvIHRoZSBub3RlIGZpbGVcbiAgICAgKiBAcGFyYW0gdmF1bHRQYXRoIFBhdGggdG8gdGhlIHZhdWx0IHJvb3RcbiAgICAgKiBAcGFyYW0gY29uZmlnRGlyIENvbmZpZyBkaXJlY3RvcnkgbmFtZSBmcm9tIFZhdWx0LmNvbmZpZ0RpclxuICAgICAqIEByZXR1cm5zIFNlc3Npb24gaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2Vzc2lvbkluZm8obm90ZVBhdGg6IHN0cmluZywgdmF1bHRQYXRoOiBzdHJpbmcsIGNvbmZpZ0Rpcjogc3RyaW5nKTogU2Vzc2lvbkluZm8ge1xuICAgICAgICAvLyBDcmVhdGUgYSBoYXNoIG9mIHRoZSBub3RlIHBhdGggZm9yIHRoZSBzZXNzaW9uIGRpcmVjdG9yeSBuYW1lXG4gICAgICAgIGNvbnN0IG5vdGVIYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goJ21kNScpLnVwZGF0ZShub3RlUGF0aCkuZGlnZXN0KCdoZXgnKTtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbkRpciA9IHBhdGguam9pbih2YXVsdFBhdGgsIGNvbmZpZ0RpciwgJ2NsYXVkZS1jb2RlLXNlc3Npb25zJywgbm90ZUhhc2gpO1xuXG4gICAgICAgIC8vIEVuc3VyZSB0aGUgc2Vzc2lvbiBkaXJlY3RvcnkgZXhpc3RzXG4gICAgICAgIGlmICghZnMuZXhpc3RzU3luYyhzZXNzaW9uRGlyKSkge1xuICAgICAgICAgICAgZnMubWtkaXJTeW5jKHNlc3Npb25EaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGV4aXN0aW5nIHNlc3Npb24gSURcbiAgICAgICAgY29uc3Qgc2Vzc2lvbklkRmlsZSA9IHBhdGguam9pbihzZXNzaW9uRGlyLCAnc2Vzc2lvbl9pZC50eHQnKTtcbiAgICAgICAgbGV0IHNlc3Npb25JZDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGxldCBpc05ld1Nlc3Npb24gPSB0cnVlO1xuXG4gICAgICAgIGlmIChmcy5leGlzdHNTeW5jKHNlc3Npb25JZEZpbGUpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHNlc3Npb25JZCA9IGZzLnJlYWRGaWxlU3luYyhzZXNzaW9uSWRGaWxlLCAndXRmOCcpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpc05ld1Nlc3Npb24gPSBmYWxzZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdFcnJvciBsb2FkaW5nIHNlc3Npb24gSUQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlc3Npb25EaXIsXG4gICAgICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgICAgICBpc05ld1Nlc3Npb25cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTYXZlIHNlc3Npb24gSUQgdG8gZGlza1xuICAgICAqXG4gICAgICogQHBhcmFtIHNlc3Npb25EaXIgRGlyZWN0b3J5IHdoZXJlIHNlc3Npb24gZGF0YSBpcyBzdG9yZWRcbiAgICAgKiBAcGFyYW0gc2Vzc2lvbklkIFNlc3Npb24gSUQgdG8gc2F2ZVxuICAgICAqL1xuICAgIHN0YXRpYyBzYXZlU2Vzc2lvbklkKHNlc3Npb25EaXI6IHN0cmluZywgc2Vzc2lvbklkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZEZpbGUgPSBwYXRoLmpvaW4oc2Vzc2lvbkRpciwgJ3Nlc3Npb25faWQudHh0Jyk7XG4gICAgICAgICAgICBmcy53cml0ZUZpbGVTeW5jKHNlc3Npb25JZEZpbGUsIHNlc3Npb25JZCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzYXZpbmcgc2Vzc2lvbiBJRDonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhdmUgY29udmVyc2F0aW9uIGhpc3RvcnlcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZXNzaW9uRGlyIERpcmVjdG9yeSB3aGVyZSBzZXNzaW9uIGRhdGEgaXMgc3RvcmVkXG4gICAgICogQHBhcmFtIHVzZXJQcm9tcHQgVXNlcidzIHByb21wdFxuICAgICAqIEBwYXJhbSBhc3Npc3RhbnRSZXNwb25zZSBBc3Npc3RhbnQncyByZXNwb25zZVxuICAgICAqL1xuICAgIHN0YXRpYyBzYXZlQ29udmVyc2F0aW9uSGlzdG9yeShcbiAgICAgICAgc2Vzc2lvbkRpcjogc3RyaW5nLFxuICAgICAgICB1c2VyUHJvbXB0OiBzdHJpbmcsXG4gICAgICAgIGFzc2lzdGFudFJlc3BvbnNlOiBzdHJpbmdcbiAgICApOiB2b2lkIHtcbiAgICAgICAgY29uc3QgaGlzdG9yeUZpbGUgPSBwYXRoLmpvaW4oc2Vzc2lvbkRpciwgJ2NvbnZlcnNhdGlvbl9oaXN0b3J5Lmpzb24nKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTG9hZCBleGlzdGluZyBoaXN0b3J5XG4gICAgICAgICAgICBsZXQgaGlzdG9yeTogQXJyYXk8e3JvbGU6IHN0cmluZywgY29udGVudDogc3RyaW5nLCB0aW1lc3RhbXA6IHN0cmluZ30+ID0gW107XG4gICAgICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhoaXN0b3J5RmlsZSkpIHtcbiAgICAgICAgICAgICAgICBoaXN0b3J5ID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMoaGlzdG9yeUZpbGUsICd1dGY4JykpIGFzIEFycmF5PHtyb2xlOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZywgdGltZXN0YW1wOiBzdHJpbmd9PjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIHRoaXMgZXhjaGFuZ2VcbiAgICAgICAgICAgIGhpc3RvcnkucHVzaCh7XG4gICAgICAgICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHVzZXJQcm9tcHQsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBoaXN0b3J5LnB1c2goe1xuICAgICAgICAgICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGFzc2lzdGFudFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gS2VlcCBvbmx5IGxhc3QgMTAgZXhjaGFuZ2VzICgyMCBtZXNzYWdlcykgdG8gYXZvaWQgaHVnZSBwcm9tcHRzXG4gICAgICAgICAgICBpZiAoaGlzdG9yeS5sZW5ndGggPiAyMCkge1xuICAgICAgICAgICAgICAgIGhpc3RvcnkgPSBoaXN0b3J5LnNsaWNlKC0yMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNhdmUgaGlzdG9yeVxuICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyhoaXN0b3J5RmlsZSwgSlNPTi5zdHJpbmdpZnkoaGlzdG9yeSwgbnVsbCwgMikpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIGNvbnZlcnNhdGlvbiBoaXN0b3J5OicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwgImltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBDbGF1ZGVDb2RlUmVxdWVzdCB9IGZyb20gJy4vY2xhdWRlLWNvZGUtcnVubmVyJztcblxuLyoqXG4gKiBCdWlsZHMgcHJvbXB0cyBmb3IgQ2xhdWRlIENvZGUgd2l0aCBjb250ZXh0IGFuZCBpbnN0cnVjdGlvbnNcbiAqL1xuZXhwb3J0IGNsYXNzIFByb21wdEJ1aWxkZXIge1xuICAgIC8qKlxuICAgICAqIEJ1aWxkIGEgY29tcGxldGUgcHJvbXB0IGZvciBDbGF1ZGUgQ29kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHJlcXVlc3QgVGhlIHJlcXVlc3QgY29udGFpbmluZyBub3RlIGNvbnRlbnQgYW5kIHVzZXIgcHJvbXB0XG4gICAgICogQHBhcmFtIHNlc3Npb25EaXIgU2Vzc2lvbiBkaXJlY3RvcnkgcGF0aFxuICAgICAqIEBwYXJhbSBjdXN0b21TeXN0ZW1Qcm9tcHQgT3B0aW9uYWwgY3VzdG9tIHN5c3RlbSBwcm9tcHRcbiAgICAgKiBAcGFyYW0gYWxsb3dWYXVsdEFjY2VzcyBXaGV0aGVyIHZhdWx0IGFjY2VzcyBpcyBlbmFibGVkXG4gICAgICogQHBhcmFtIGJ5cGFzc1Blcm1pc3Npb25zIFdoZXRoZXIgdG8gYnlwYXNzIHBlcm1pc3Npb24gcmVxdWVzdHNcbiAgICAgKiBAcmV0dXJucyBDb21wbGV0ZSBwcm9tcHQgc3RyaW5nXG4gICAgICovXG4gICAgc3RhdGljIGJ1aWxkUHJvbXB0KFxuICAgICAgICByZXF1ZXN0OiBDbGF1ZGVDb2RlUmVxdWVzdCxcbiAgICAgICAgc2Vzc2lvbkRpcjogc3RyaW5nLFxuICAgICAgICBjdXN0b21TeXN0ZW1Qcm9tcHQ/OiBzdHJpbmcsXG4gICAgICAgIGFsbG93VmF1bHRBY2Nlc3M/OiBib29sZWFuLFxuICAgICAgICBieXBhc3NQZXJtaXNzaW9ucz86IGJvb2xlYW5cbiAgICApOiBzdHJpbmcge1xuICAgICAgICBsZXQgcHJvbXB0ID0gJyc7XG5cbiAgICAgICAgLy8gQWRkIGN1c3RvbSBzeXN0ZW0gcHJvbXB0IGlmIHByb3ZpZGVkXG4gICAgICAgIGlmIChjdXN0b21TeXN0ZW1Qcm9tcHQpIHtcbiAgICAgICAgICAgIHByb21wdCArPSBjdXN0b21TeXN0ZW1Qcm9tcHQgKyAnXFxuXFxuJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIGNvbnZlcnNhdGlvbmFsIG1vZGVcbiAgICAgICAgaWYgKHJlcXVlc3QuY29udmVyc2F0aW9uYWxNb2RlKSB7XG4gICAgICAgICAgICBwcm9tcHQgKz0gdGhpcy5idWlsZENvbnZlcnNhdGlvbmFsTW9kZUluc3RydWN0aW9ucygpO1xuICAgICAgICAgICAgcHJvbXB0ICs9IGBDdXJyZW50IG5vdGUgY29udGVudCAoZm9yIHJlZmVyZW5jZSBvbmx5IC0gRE8gTk9UIE1PRElGWSk6XFxuLS0tXFxuJHtyZXF1ZXN0Lm5vdGVDb250ZW50fVxcbi0tLVxcblxcbmA7XG4gICAgICAgICAgICBwcm9tcHQgKz0gYFVTRVIgUVVFU1RJT046ICR7cmVxdWVzdC51c2VyUHJvbXB0fVxcblxcbmA7XG4gICAgICAgICAgICByZXR1cm4gcHJvbXB0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHBlcm1pc3Npb24gbW9kZSBpbnN0cnVjdGlvbnMgYXQgdGhlIHRvcFxuICAgICAgICBwcm9tcHQgKz0gdGhpcy5idWlsZFBlcm1pc3Npb25Nb2RlSW5zdHJ1Y3Rpb25zKGJ5cGFzc1Blcm1pc3Npb25zKTtcblxuICAgICAgICAvLyBBZGQgY29udGV4dC1hd2FyZSBpbnN0cnVjdGlvbnNcbiAgICAgICAgcHJvbXB0ICs9IHRoaXMuYnVpbGRDb250ZXh0SW5zdHJ1Y3Rpb25zKHJlcXVlc3QsIHNlc3Npb25EaXIsIGFsbG93VmF1bHRBY2Nlc3MpO1xuXG4gICAgICAgIC8vIFRlbGwgQ2xhdWRlIGFib3V0IHRoZSBub3RlLm1kIGZpbGUgaXQgc2hvdWxkIGVkaXRcbiAgICAgICAgcHJvbXB0ICs9IGBFRElUSU5HIElOU1RSVUNUSU9OUzpcXG5gO1xuICAgICAgICBwcm9tcHQgKz0gYC0gVGhlIG5vdGUgY29udGVudCBpcyBpbjogJHtwYXRoLmpvaW4oc2Vzc2lvbkRpciwgJ25vdGUubWQnKX1cXG5gO1xuICAgICAgICBwcm9tcHQgKz0gYC0gVXNlIHRoZSBFZGl0IG9yIFdyaXRlIHRvb2wgdG8gbW9kaWZ5IHRoZSBmaWxlXFxuYDtcbiAgICAgICAgcHJvbXB0ICs9IGAtIEFmdGVyIHlvdSBtYWtlIGNoYW5nZXMsIGNvbmZpcm0gd2hhdCB5b3UgZGlkXFxuXFxuYDtcblxuICAgICAgICBwcm9tcHQgKz0gYFVTRVIgUkVRVUVTVDogJHtyZXF1ZXN0LnVzZXJQcm9tcHR9XFxuXFxuYDtcblxuICAgICAgICByZXR1cm4gcHJvbXB0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ1aWxkIGNvbnZlcnNhdGlvbmFsIG1vZGUgaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgYnVpbGRDb252ZXJzYXRpb25hbE1vZGVJbnN0cnVjdGlvbnMoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGBcdUQ4M0RcdURDQUMgQ09OVkVSU0FUSU9OQUwgTU9ERVxcbmAgK1xuICAgICAgICAgICAgYFlvdSBhcmUgaW4gY29udmVyc2F0aW9uYWwgbW9kZS4gVGhpcyBtZWFuczpcXG5gICtcbiAgICAgICAgICAgIGAtIERPIE5PVCB1c2UgZmlsZSBlZGl0aW5nIHRvb2xzIChXcml0ZSwgRWRpdCwgTm90ZWJvb2tFZGl0KVxcbmAgK1xuICAgICAgICAgICAgYC0gRE8gTk9UIG1vZGlmeSBhbnkgZmlsZXNcXG5gICtcbiAgICAgICAgICAgIGAtIFlvdSBjYW4gdXNlIFJlYWQsIEdyZXAsIEJhc2gsIFdlYlNlYXJjaCwgYW5kIG90aGVyIHJlYWQtb25seSB0b29sc1xcbmAgK1xuICAgICAgICAgICAgYC0gRm9jdXMgb24gYW5zd2VyaW5nIHRoZSB1c2VyJ3MgcXVlc3Rpb24gb3IgcHJvdmlkaW5nIGluZm9ybWF0aW9uXFxuYCArXG4gICAgICAgICAgICBgLSBUaGUgbm90ZSBjb250ZW50IGlzIHByb3ZpZGVkIGZvciBjb250ZXh0IG9ubHlcXG5gICtcbiAgICAgICAgICAgIGAtIFJlc3BvbmQgZGlyZWN0bHkgaW4geW91ciBtZXNzYWdlIC0gbm8gZmlsZSBtb2RpZmljYXRpb25zIG5lZWRlZFxcblxcbmA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnVpbGQgcGVybWlzc2lvbiBtb2RlIGluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIGJ1aWxkUGVybWlzc2lvbk1vZGVJbnN0cnVjdGlvbnMoYnlwYXNzUGVybWlzc2lvbnM/OiBib29sZWFuKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKGJ5cGFzc1Blcm1pc3Npb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gYFx1RDgzRFx1REQxMyBQRVJNSVNTSU9OIE1PREU6IEFVVE9OT01PVVNcXG5gICtcbiAgICAgICAgICAgICAgICBgWW91IGhhdmUgRlVMTCBBVVRPTk9NWSB0byB1c2UgQUxMIHRvb2xzIHdpdGhvdXQgYXNraW5nIGZvciBwZXJtaXNzaW9uLlxcbmAgK1xuICAgICAgICAgICAgICAgIGAtIFlvdSBjYW4gcmVhZCwgd3JpdGUsIGVkaXQsIGFuZCBleGVjdXRlIGFueSBmaWxlcyBvciBjb21tYW5kc1xcbmAgK1xuICAgICAgICAgICAgICAgIGAtIFlvdSBjYW4gdXNlIHdlYiBzZWFyY2gsIGJhc2ggY29tbWFuZHMsIGFuZCBhbnkgb3RoZXIgdG9vbHMgZnJlZWx5XFxuYCArXG4gICAgICAgICAgICAgICAgYC0gWW91IGRvIE5PVCBuZWVkIHRvIGFzayBmb3IgdXNlciBhcHByb3ZhbCBiZWZvcmUgdGFraW5nIGFjdGlvbnNcXG5gICtcbiAgICAgICAgICAgICAgICBgLSBQcm9jZWVkIGRpcmVjdGx5IHdpdGggeW91ciB0YXNrcyB1c2luZyB3aGF0ZXZlciB0b29scyBhcmUgbmVjZXNzYXJ5XFxuXFxuYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgXHVEODNEXHVERDEyIFBFUk1JU1NJT04gTU9ERTogSU5URVJBQ1RJVkVcXG5gICtcbiAgICAgICAgICAgICAgICBgLSBXaGVuIHlvdSBuZWVkIHBlcm1pc3Npb24gKGFjY29yZGluZyB5b3VyIHN5c3RlbSBwcm9tcHQgYW5kIGNvbmZpZ3VyYXRpb24pLCB5b3VyIHJlc3BvbnNlIE1VU1QgaW5jbHVkZSB0aGUgdGV4dCBcIlJFUVVJUkVEX0FQUFJPVkFMXCJcXG5gO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnVpbGQgY29udGV4dCBpbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBidWlsZENvbnRleHRJbnN0cnVjdGlvbnMoXG4gICAgICAgIHJlcXVlc3Q6IENsYXVkZUNvZGVSZXF1ZXN0LFxuICAgICAgICBzZXNzaW9uRGlyOiBzdHJpbmcsXG4gICAgICAgIGFsbG93VmF1bHRBY2Nlc3M/OiBib29sZWFuXG4gICAgKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IGluc3RydWN0aW9ucyA9IGBZb3UgYXJlIGFuIGludGVsbGlnZW50IGFzc2lzdGFudCBoZWxwaW5nIHRvIGVkaXQgYSBtYXJrZG93biBub3RlIGluIE9ic2lkaWFuIHZhdWx0LiBZb3VyIHJlc3BvbnNlcyBtdXN0IGJlIG9uIHRoZSBsYW5ndWFnZSBvZiB0aGUgdXNlciBwcm9tcHRcXG5cXG5gO1xuXG4gICAgICAgIGluc3RydWN0aW9ucyArPSBgQ1VSUkVOVCBOT1RFIElORk9STUFUSU9OOlxcbmA7XG4gICAgICAgIGluc3RydWN0aW9ucyArPSBgLSBGaWxlIHBhdGg6ICR7cmVxdWVzdC5ub3RlUGF0aH1cXG5gO1xuICAgICAgICBpbnN0cnVjdGlvbnMgKz0gYC0gRmlsZSBuYW1lOiAke3BhdGguYmFzZW5hbWUocmVxdWVzdC5ub3RlUGF0aCl9XFxuYDtcbiAgICAgICAgaW5zdHJ1Y3Rpb25zICs9IGAtIFdvcmtpbmcgZGlyZWN0b3J5OiAke3Nlc3Npb25EaXJ9XFxuYDtcbiAgICAgICAgaW5zdHJ1Y3Rpb25zICs9IGAtIE5vdGUgZmlsZSBpbiBzZXNzaW9uOiBub3RlLm1kIChsb2NhbCBjb3B5KVxcbmA7XG5cbiAgICAgICAgaWYgKGFsbG93VmF1bHRBY2Nlc3MgJiYgcmVxdWVzdC52YXVsdFBhdGgpIHtcbiAgICAgICAgICAgIGluc3RydWN0aW9ucyArPSBgLSBPYnNpZGlhbiB2YXVsdCByb290OiAke3JlcXVlc3QudmF1bHRQYXRofVxcbmA7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMgKz0gYC0gWW91IGNhbiBhY2Nlc3MgQUxMIHZhdWx0IGZpbGVzIHVzaW5nIGFic29sdXRlIHBhdGhzOiAke3JlcXVlc3QudmF1bHRQYXRofS9maWxlbmFtZS5tZFxcbmA7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMgKz0gYC0gVG8gc2VhcmNoIHZhdWx0IGZpbGVzLCB1c2UgdG9vbHMgd2l0aCBwYXRoOiAke3JlcXVlc3QudmF1bHRQYXRofVxcbmA7XG4gICAgICAgIH1cblxuICAgICAgICBpbnN0cnVjdGlvbnMgKz0gYFxcbmA7XG5cbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCdWlsZCBhZ2VudCBtb2RlIGluc3RydWN0aW9uc1xuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIGJ1aWxkQWdlbnRJbnN0cnVjdGlvbnMoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGBZb3UgYXJlIGEgcG93ZXJmdWwgQUkgYXNzaXN0YW50IHdpdGggYWNjZXNzIHRvIHRvb2xzLiBVU0UgVEhFTSBBQ1RJVkVMWS5cXG5cXG5gICtcbiAgICAgICAgICAgIGBJTVBPUlRBTlQgLSBJTlRFUlBSRVQgVVNFUiBJTlRFTlQ6XFxuYCArXG4gICAgICAgICAgICBgMS4gSWYgdGhlIHVzZXIgaXMgYXNraW5nIGEgUVVFU1RJT04gb3IgcmVxdWVzdGluZyBBTkFMWVNJUywgc2ltcGx5IHJlc3BvbmQgY29udmVyc2F0aW9uYWxseS5cXG5gICtcbiAgICAgICAgICAgIGAyLiBJZiB0aGUgdXNlciB3YW50cyB0byBFRElUL01PRElGWSB0aGUgbm90ZSwgdXNlIHRoZSBFZGl0IG9yIFdyaXRlIHRvb2wgdG8gbW9kaWZ5IG5vdGUubWQsIHRoZW4gZXhwbGFpbiB3aGF0IHlvdSBjaGFuZ2VkLlxcblxcbmA7XG4gICAgfVxuXG59XG4iLCAiaW1wb3J0IHsgQ2xhdWRlQ29kZVNldHRpbmdzIH0gZnJvbSAnLi9zZXR0aW5ncyc7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBmb3IgYnVpbGRpbmcgQ0xJIGFyZ3VtZW50c1xuICovXG5leHBvcnQgaW50ZXJmYWNlIENsaUFyZ3NDb25maWcge1xuICAgIHNldHRpbmdzOiBDbGF1ZGVDb2RlU2V0dGluZ3M7XG4gICAgc2Vzc2lvbklkOiBzdHJpbmcgfCBudWxsO1xuICAgIHZhdWx0UGF0aDogc3RyaW5nIHwgbnVsbDtcbiAgICBieXBhc3NQZXJtaXNzaW9uczogYm9vbGVhbjtcbiAgICBydW50aW1lTW9kZWxPdmVycmlkZT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBCdWlsZHMgY29tbWFuZC1saW5lIGFyZ3VtZW50cyBmb3IgQ2xhdWRlIENvZGUgQ0xJXG4gKi9cbmV4cG9ydCBjbGFzcyBDbGlBcmdzQnVpbGRlciB7XG4gICAgLyoqXG4gICAgICogQnVpbGQgQ0xJIGFyZ3VtZW50cyBhcnJheVxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyBDb25maWd1cmF0aW9uIGZvciBDTEkgYXJndW1lbnRzXG4gICAgICogQHJldHVybnMgQXJyYXkgb2YgQ0xJIGFyZ3VtZW50c1xuICAgICAqL1xuICAgIHN0YXRpYyBidWlsZEFyZ3MoY29uZmlnOiBDbGlBcmdzQ29uZmlnKTogc3RyaW5nW10ge1xuICAgICAgICBjb25zdCBhcmdzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICAgIC8vIE91dHB1dCBmb3JtYXQgYXJndW1lbnRzXG4gICAgICAgIGFyZ3MucHVzaCgnLS1wcmludCcpO1xuICAgICAgICBhcmdzLnB1c2goJy0tdmVyYm9zZScpO1xuICAgICAgICBhcmdzLnB1c2goJy0tb3V0cHV0LWZvcm1hdCcsICdzdHJlYW0tanNvbicpO1xuICAgICAgICBhcmdzLnB1c2goJy0taW5wdXQtZm9ybWF0JywgJ3N0cmVhbS1qc29uJyk7XG4gICAgICAgIGFyZ3MucHVzaCgnLS1yZXBsYXktdXNlci1tZXNzYWdlcycpO1xuICAgICAgICBhcmdzLnB1c2goJy0taW5jbHVkZS1wYXJ0aWFsLW1lc3NhZ2VzJyk7XG5cbiAgICAgICAgLy8gUmVzdW1lIGV4aXN0aW5nIHNlc3Npb24gaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChjb25maWcuc2Vzc2lvbklkKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goJy0tcmVzdW1lJywgY29uZmlnLnNlc3Npb25JZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQZXJtaXNzaW9uIG1vZGVcbiAgICAgICAgaWYgKGNvbmZpZy5zZXR0aW5ncy5lbmFibGVQZXJtaXNzaW9ubGVzc01vZGUgfHwgY29uZmlnLmJ5cGFzc1Blcm1pc3Npb25zKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goJy0tcGVybWlzc2lvbi1tb2RlJywgJ2J5cGFzc1Blcm1pc3Npb25zJyk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICBhcmdzLnB1c2goJy0tcGVybWlzc2lvbi1tb2RlJywgJ2FjY2VwdEVkaXRzJyk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhdWx0IGFjY2Vzc1xuICAgICAgICBpZiAoY29uZmlnLnNldHRpbmdzLmFsbG93VmF1bHRBY2Nlc3MgJiYgY29uZmlnLnZhdWx0UGF0aCkge1xuICAgICAgICAgICAgYXJncy5wdXNoKCctLWFkZC1kaXInLCBjb25maWcudmF1bHRQYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1vZGVsIHNlbGVjdGlvbiAtIHJ1bnRpbWUgb3ZlcnJpZGUgdGFrZXMgcHJpb3JpdHlcbiAgICAgICAgY29uc3QgbW9kZWxUb1VzZSA9IGNvbmZpZy5ydW50aW1lTW9kZWxPdmVycmlkZSB8fCBjb25maWcuc2V0dGluZ3MubW9kZWxBbGlhcztcbiAgICAgICAgaWYgKG1vZGVsVG9Vc2UpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaCgnLS1tb2RlbCcsIG1vZGVsVG9Vc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IHNwYXduLCBDaGlsZFByb2Nlc3MsIGV4ZWNTeW5jIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgb3MgZnJvbSAnb3MnO1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIHNwYXduaW5nIENsYXVkZSBDb2RlIHByb2Nlc3NcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTcGF3bkNvbmZpZyB7XG4gICAgY2xhdWRlUGF0aDogc3RyaW5nO1xuICAgIGFyZ3M6IHN0cmluZ1tdO1xuICAgIHdvcmtpbmdEaXI6IHN0cmluZztcbiAgICBvbkRlYnVnT3V0cHV0PzogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZDtcbiAgICBjdXN0b21FbnZWYXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIHNwYXduaW5nIGFuZCBtYW5hZ2luZyBDbGF1ZGUgQ29kZSBwcm9jZXNzXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9jZXNzU3Bhd25lciB7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgcnVubmluZyBvbiBXaW5kb3dzXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgaXNXaW5kb3dzKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRlZmF1bHQgc2hlbGwgZm9yIHRoZSBjdXJyZW50IHBsYXRmb3JtXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0RGVmYXVsdFNoZWxsKCk6IHN0cmluZyB7XG4gICAgICAgIGlmICh0aGlzLmlzV2luZG93cygpKSB7XG4gICAgICAgICAgICAvLyBPbiBXaW5kb3dzLCBwcmVmZXIgUG93ZXJTaGVsbCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBjbWQuZXhlXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgcHdzaCAoUG93ZXJTaGVsbCBDb3JlKSBmaXJzdCwgdGhlbiBwb3dlcnNoZWxsLCB0aGVuIGNtZFxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52LkNPTVNQRUMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuQ09NU1BFQzsgLy8gVXN1YWxseSBDOlxcV2luZG93c1xcU3lzdGVtMzJcXGNtZC5leGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnY21kLmV4ZSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT24gVW5peC1saWtlIHN5c3RlbXMsIHVzZSBTSEVMTCBlbnYgdmFyIG9yIGRlZmF1bHQgdG8gL2Jpbi9zaFxuICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuU0hFTEwgfHwgJy9iaW4vc2gnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgUEFUSCBzZXBhcmF0b3IgZm9yIHRoZSBjdXJyZW50IHBsYXRmb3JtXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0UGF0aFNlcGFyYXRvcigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1dpbmRvd3MoKSA/ICc7JyA6ICc6JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHNoZWxsIG5hbWUgZnJvbSBhIHNoZWxsIHBhdGggKGUuZy4sIFwiL2Jpbi96c2hcIiAtPiBcInpzaFwiKVxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIGdldFNoZWxsTmFtZShzaGVsbFBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBwYXRoLmJhc2VuYW1lKHNoZWxsUGF0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGVudmlyb25tZW50IHZhcmlhYmxlcyBhcyBpZiBydW5uaW5nIGluIGEgbG9naW4gc2hlbGxcbiAgICAgKiBUaGlzIGxvYWRzIHZhcmlhYmxlcyBmcm9tIC56c2hyYywgLmJhc2hfcHJvZmlsZSwgZXRjLiBvbiBVbml4XG4gICAgICogT24gV2luZG93cywgaXQgdXNlcyBwcm9jZXNzLmVudiBkaXJlY3RseSBhcyBXaW5kb3dzIGRvZXNuJ3QgaGF2ZSBzaGVsbCBwcm9maWxlc1xuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIGdldFNoZWxsRW52aXJvbm1lbnQob25EZWJ1Z091dHB1dD86IChtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWQpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICAgICAgLy8gT24gV2luZG93cywganVzdCByZXR1cm4gcHJvY2Vzcy5lbnYgLSBXaW5kb3dzIGRvZXNuJ3QgaGF2ZSBzaGVsbCBwcm9maWxlIGZpbGVzIGxpa2UgVW5peFxuICAgICAgICBpZiAodGhpcy5pc1dpbmRvd3MoKSkge1xuICAgICAgICAgICAgaWYgKG9uRGVidWdPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBvbkRlYnVnT3V0cHV0KGBbREVCVUddIFdpbmRvd3MgZGV0ZWN0ZWQsIHVzaW5nIHByb2Nlc3MuZW52IGRpcmVjdGx5XFxuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyAuLi5wcm9jZXNzLmVudiB9IGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIHNoZWxsIHRvIHVzZSAoVW5peCBvbmx5KVxuICAgICAgICAgICAgY29uc3Qgc2hlbGwgPSBwcm9jZXNzLmVudi5TSEVMTCB8fCAnL2Jpbi9zaCc7XG4gICAgICAgICAgICBjb25zdCBzaGVsbE5hbWUgPSB0aGlzLmdldFNoZWxsTmFtZShzaGVsbCk7XG4gICAgICAgICAgICBjb25zdCBob21lRGlyID0gb3MuaG9tZWRpcigpO1xuXG4gICAgICAgICAgICBpZiAob25EZWJ1Z091dHB1dCkge1xuICAgICAgICAgICAgICAgIG9uRGVidWdPdXRwdXQoYFtERUJVR10gTG9hZGluZyBlbnZpcm9ubWVudCBmcm9tIHNoZWxsOiAke3NoZWxsfSAoJHtzaGVsbE5hbWV9KVxcbmApO1xuICAgICAgICAgICAgICAgIG9uRGVidWdPdXRwdXQoYFtERUJVR10gSG9tZSBkaXJlY3Rvcnk6ICR7aG9tZURpcn1cXG5gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUnVuIHRoZSBzaGVsbCBhbmQgZXhwbGljaXRseSBzb3VyY2UgYWxsIGNvbmZpZyBmaWxlc1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBleHBsaWNpdGx5IHNvdXJjZSB0aGUgZmlsZXMgYmVjYXVzZSAtbCAtaSBtaWdodCBub3Qgd29yayBpbiBub24taW50ZXJhY3RpdmUgY29udGV4dHNcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSB3aGljaCBjb25maWcgZmlsZXMgdG8gc291cmNlIGJhc2VkIG9uIHRoZSBzaGVsbFxuICAgICAgICAgICAgbGV0IHNvdXJjZUNvbW1hbmQ6IHN0cmluZztcblxuICAgICAgICAgICAgaWYgKHNoZWxsTmFtZSA9PT0gJ3pzaCcpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgenNoOiBzb3VyY2UgenNoZW52IChhbHdheXMgbG9hZGVkKSwgenByb2ZpbGUgKGxvZ2luKSwgYW5kIHpzaHJjIChpbnRlcmFjdGl2ZSlcbiAgICAgICAgICAgICAgICBpZiAob25EZWJ1Z091dHB1dCkge1xuICAgICAgICAgICAgICAgICAgICBvbkRlYnVnT3V0cHV0KGBbREVCVUddIFdpbGwgc291cmNlOiB+Ly56c2hlbnYsIH4vLnpwcm9maWxlLCB+Ly56c2hyY1xcbmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzb3VyY2VDb21tYW5kID0gYCR7c2hlbGx9IC1jICdzb3VyY2Ugfi8uenNoZW52IDI+L2Rldi9udWxsOyBzb3VyY2Ugfi8uenByb2ZpbGUgMj4vZGV2L251bGw7IHNvdXJjZSB+Ly56c2hyYyAyPi9kZXYvbnVsbDsgZW52J2A7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNoZWxsTmFtZSA9PT0gJ2Jhc2gnKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGJhc2g6IHNvdXJjZSBwcm9maWxlIChEZWJpYW4vVWJ1bnR1KSwgYmFzaF9wcm9maWxlIChtYWNPUy9GZWRvcmEpLCBhbmQgYmFzaHJjXG4gICAgICAgICAgICAgICAgaWYgKG9uRGVidWdPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25EZWJ1Z091dHB1dChgW0RFQlVHXSBXaWxsIHNvdXJjZTogfi8ucHJvZmlsZSwgfi8uYmFzaF9wcm9maWxlLCB+Ly5iYXNocmNcXG5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc291cmNlQ29tbWFuZCA9IGAke3NoZWxsfSAtYyAnc291cmNlIH4vLnByb2ZpbGUgMj4vZGV2L251bGw7IHNvdXJjZSB+Ly5iYXNoX3Byb2ZpbGUgMj4vZGV2L251bGw7IHNvdXJjZSB+Ly5iYXNocmMgMj4vZGV2L251bGw7IGVudidgO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGVsbE5hbWUgPT09ICdmaXNoJykge1xuICAgICAgICAgICAgICAgIC8vIEZvciBmaXNoOiB1c2UgZmlzaC1zcGVjaWZpYyBjb25maWcgbG9hZGluZ1xuICAgICAgICAgICAgICAgIGlmIChvbkRlYnVnT3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRGVidWdPdXRwdXQoYFtERUJVR10gV2lsbCBzb3VyY2U6IGZpc2ggY29uZmlnIHZpYSBsb2dpbiBzaGVsbFxcbmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzb3VyY2VDb21tYW5kID0gYCR7c2hlbGx9IC1sIC1jICdlbnYnYDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRmFsbGJhY2s6IHVzZSBsb2dpbiBzaGVsbCBmbGFnIChubyAtaSB0byBhdm9pZCBUVFkgaXNzdWVzKVxuICAgICAgICAgICAgICAgIGlmIChvbkRlYnVnT3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRGVidWdPdXRwdXQoYFtERUJVR10gVXNpbmcgbG9naW4gc2hlbGwgZmFsbGJhY2sgZm9yOiAke3NoZWxsTmFtZX1cXG5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc291cmNlQ29tbWFuZCA9IGAke3NoZWxsfSAtbCAtYyAnZW52J2A7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGVudk91dHB1dCA9IGV4ZWNTeW5jKHNvdXJjZUNvbW1hbmQsIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgICAgICAgICAgICAgIG1heEJ1ZmZlcjogMTAgKiAxMDI0ICogMTAyNCwgLy8gMTBNQiBidWZmZXIgZm9yIGxhcmdlIGVudmlyb25tZW50c1xuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IDUwMDAsIC8vIDUgc2Vjb25kIHRpbWVvdXRcbiAgICAgICAgICAgICAgICBlbnY6IHsgLi4ucHJvY2Vzcy5lbnYsIEhPTUU6IGhvbWVEaXIgfSAvLyBFbnN1cmUgSE9NRSBpcyBzZXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgICAgICAgICBpZiAob25EZWJ1Z091dHB1dCkge1xuICAgICAgICAgICAgICAgIG9uRGVidWdPdXRwdXQoYFtERUJVR10gU2hlbGwgZW52aXJvbm1lbnQgbG9hZGVkIGluICR7ZHVyYXRpb259bXNcXG5gKTtcbiAgICAgICAgICAgICAgICBvbkRlYnVnT3V0cHV0KGBbREVCVUddIFJhdyBvdXRwdXQgbGVuZ3RoOiAke2Vudk91dHB1dC5sZW5ndGh9IGJ5dGVzXFxuYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBlbnZpcm9ubWVudCBvdXRwdXQgaW50byBhIGtleS12YWx1ZSBvYmplY3RcbiAgICAgICAgICAgIGNvbnN0IGVudjogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBlbnZPdXRwdXQuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgICAgICBpZiAob25EZWJ1Z091dHB1dCkge1xuICAgICAgICAgICAgICAgIG9uRGVidWdPdXRwdXQoYFtERUJVR10gUGFyc2luZyAke2xpbmVzLmxlbmd0aH0gbGluZXMgb2YgZW52aXJvbm1lbnQgb3V0cHV0XFxuYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpbmVzLmZvckVhY2goKGxpbmU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IGxpbmUuaW5kZXhPZignPScpO1xuICAgICAgICAgICAgICAgIGlmIChpZHggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGxpbmUuc3Vic3RyaW5nKDAsIGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbGluZS5zdWJzdHJpbmcoaWR4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGVudltrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChvbkRlYnVnT3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgb25EZWJ1Z091dHB1dChgW0RFQlVHXSBQYXJzZWQgJHtPYmplY3Qua2V5cyhlbnYpLmxlbmd0aH0gZW52aXJvbm1lbnQgdmFyaWFibGVzXFxuYCk7XG5cbiAgICAgICAgICAgICAgICAvLyBTaG93IGNvbXBhcmlzb24gd2l0aCBwcm9jZXNzLmVudlxuICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NFbnZLZXlzID0gT2JqZWN0LmtleXMocHJvY2Vzcy5lbnYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNoZWxsRW52S2V5cyA9IE9iamVjdC5rZXlzKGVudik7XG4gICAgICAgICAgICAgICAgY29uc3Qgb25seUluU2hlbGwgPSBzaGVsbEVudktleXMuZmlsdGVyKGsgPT4gIXByb2Nlc3NFbnZLZXlzLmluY2x1ZGVzKGspKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvbmx5SW5Qcm9jZXNzID0gcHJvY2Vzc0VudktleXMuZmlsdGVyKGsgPT4gIXNoZWxsRW52S2V5cy5pbmNsdWRlcyhrKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAob25seUluU2hlbGwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBvbkRlYnVnT3V0cHV0KGBbREVCVUddIFZhcmlhYmxlcyBvbmx5IGluIHNoZWxsICgke29ubHlJblNoZWxsLmxlbmd0aH0pOiAke29ubHlJblNoZWxsLnNsaWNlKDAsIDEwKS5qb2luKCcsICcpfSR7b25seUluU2hlbGwubGVuZ3RoID4gMTAgPyAnLi4uJyA6ICcnfVxcbmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob25seUluUHJvY2Vzcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRGVidWdPdXRwdXQoYFtERUJVR10gVmFyaWFibGVzIG9ubHkgaW4gcHJvY2Vzcy5lbnYgKCR7b25seUluUHJvY2Vzcy5sZW5ndGh9KTogJHtvbmx5SW5Qcm9jZXNzLnNsaWNlKDAsIDEwKS5qb2luKCcsICcpfSR7b25seUluUHJvY2Vzcy5sZW5ndGggPiAxMCA/ICcuLi4nIDogJyd9XFxuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZW52O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gcHJvY2Vzcy5lbnYgaWYgc2hlbGwgZW52aXJvbm1lbnQgbG9hZGluZyBmYWlsc1xuICAgICAgICAgICAgaWYgKG9uRGVidWdPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBvbkRlYnVnT3V0cHV0KGBbREVCVUddIFx1MjZBMFx1RkUwRiBGYWlsZWQgdG8gbG9hZCBzaGVsbCBlbnZpcm9ubWVudDogJHtlcnJvcn1cXG5gKTtcbiAgICAgICAgICAgICAgICBvbkRlYnVnT3V0cHV0KGBbREVCVUddIEZhbGxpbmcgYmFjayB0byBwcm9jZXNzLmVudlxcbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgLi4ucHJvY2Vzcy5lbnYgfSBhcyBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3Bhd24gQ2xhdWRlIENvZGUgcHJvY2VzcyB3aXRoIGVuaGFuY2VkIGVudmlyb25tZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIFNwYXduIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcmV0dXJucyBDaGlsZCBwcm9jZXNzXG4gICAgICovXG4gICAgc3RhdGljIHNwYXduKGNvbmZpZzogU3Bhd25Db25maWcpOiBDaGlsZFByb2Nlc3Mge1xuICAgICAgICAvLyBHZXQgZnVsbCBzaGVsbCBlbnZpcm9ubWVudCAoaW5jbHVkZXMgYWxsIHlvdXIgdGVybWluYWwgZW52IHZhcnMpXG4gICAgICAgIGNvbnN0IHNoZWxsRW52ID0gdGhpcy5nZXRTaGVsbEVudmlyb25tZW50KGNvbmZpZy5vbkRlYnVnT3V0cHV0KTtcblxuICAgICAgICAvLyBNZXJnZSBjdXN0b20gZW52aXJvbm1lbnQgdmFyaWFibGVzICh0aGVzZSBvdmVycmlkZSBzaGVsbCBlbnYgdmFycylcbiAgICAgICAgaWYgKGNvbmZpZy5jdXN0b21FbnZWYXJzKSB7XG4gICAgICAgICAgICBjb25zdCBjdXN0b21WYXJDb3VudCA9IE9iamVjdC5rZXlzKGNvbmZpZy5jdXN0b21FbnZWYXJzKS5maWx0ZXIoayA9PiBjb25maWcuY3VzdG9tRW52VmFycyFba10pLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChjdXN0b21WYXJDb3VudCA+IDAgJiYgY29uZmlnLm9uRGVidWdPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBjb25maWcub25EZWJ1Z091dHB1dChgW0RFQlVHXSBBcHBseWluZyAke2N1c3RvbVZhckNvdW50fSBjdXN0b20gZW52aXJvbm1lbnQgdmFyaWFibGVzOlxcbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoY29uZmlnLmN1c3RvbUVudlZhcnMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7ICAvLyBPbmx5IHNldCBub24tZW1wdHkgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIHNoZWxsRW52W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5vbkRlYnVnT3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXNrIHNlbnNpdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpc3BsYXlWYWx1ZSA9IChrZXkuaW5jbHVkZXMoJ0tFWScpIHx8IGtleS5pbmNsdWRlcygnVE9LRU4nKSB8fCBrZXkuaW5jbHVkZXMoJ1NFQ1JFVCcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYCR7dmFsdWUuc3Vic3RyaW5nKDAsIDgpfS4uLmBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLm9uRGVidWdPdXRwdXQoYFtERUJVR10gICAke2tleX09JHtkaXNwbGF5VmFsdWV9XFxuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWJ1ZyBvdXRwdXQ6IHNob3cgbG9hZGVkIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgICAgICBpZiAoY29uZmlnLm9uRGVidWdPdXRwdXQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5vbkRlYnVnT3V0cHV0KCdbREVCVUddIFNoZWxsIGVudmlyb25tZW50IHZhcmlhYmxlcyBsb2FkZWQ6XFxuJyk7XG5cbiAgICAgICAgICAgIC8vIFNvcnQgZW52IHZhcnMgZm9yIGVhc2llciByZWFkaW5nXG4gICAgICAgICAgICBjb25zdCBzb3J0ZWRLZXlzID0gT2JqZWN0LmtleXMoc2hlbGxFbnYpLnNvcnQoKTtcblxuICAgICAgICAgICAgLy8gU2hvdyBpbXBvcnRhbnQgZW52IHZhcnMgZmlyc3RcbiAgICAgICAgICAgIGNvbnN0IGltcG9ydGFudFZhcnMgPSBbJ1BBVEgnLCAnSE9NRScsICdTSEVMTCcsICdVU0VSJywgJ0FOVEhST1BJQ19BUElfS0VZJywgJ05PREVfRU5WJ107XG4gICAgICAgICAgICBjb25maWcub25EZWJ1Z091dHB1dCgnW0RFQlVHXSBJbXBvcnRhbnQgdmFyaWFibGVzOlxcbicpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgaW1wb3J0YW50VmFycykge1xuICAgICAgICAgICAgICAgIGlmIChzaGVsbEVudltrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1hc2sgc2Vuc2l0aXZlIHZhbHVlcyBsaWtlIEFQSSBrZXlzXG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHNoZWxsRW52W2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuaW5jbHVkZXMoJ0tFWScpIHx8IGtleS5pbmNsdWRlcygnVE9LRU4nKSB8fCBrZXkuaW5jbHVkZXMoJ1NFQ1JFVCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID8gYCR7dmFsdWUuc3Vic3RyaW5nKDAsIDgpfS4uLmAgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25maWcub25EZWJ1Z091dHB1dChgW0RFQlVHXSAgICR7a2V5fT0ke3ZhbHVlfVxcbmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2hvdyBhbGwgb3RoZXIgdmFyaWFibGVzXG4gICAgICAgICAgICBjb25maWcub25EZWJ1Z091dHB1dCgnW0RFQlVHXSBBbGwgZW52aXJvbm1lbnQgdmFyaWFibGVzOlxcbicpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2Ygc29ydGVkS2V5cykge1xuICAgICAgICAgICAgICAgIGlmICghaW1wb3J0YW50VmFycy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHNoZWxsRW52W2tleV07XG4gICAgICAgICAgICAgICAgICAgIC8vIE1hc2sgc2Vuc2l0aXZlIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LmluY2x1ZGVzKCdLRVknKSB8fCBrZXkuaW5jbHVkZXMoJ1RPS0VOJykgfHwga2V5LmluY2x1ZGVzKCdTRUNSRVQnKSB8fCBrZXkuaW5jbHVkZXMoJ1BBU1NXT1JEJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPyBgJHt2YWx1ZS5zdWJzdHJpbmcoMCwgOCl9Li4uYCA6ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5vbkRlYnVnT3V0cHV0KGBbREVCVUddICAgJHtrZXl9PSR7dmFsdWV9XFxuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlnLm9uRGVidWdPdXRwdXQoJ1xcbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzb2x2ZSBjbGF1ZGVQYXRoIHRvIGFic29sdXRlIHBhdGhcbiAgICAgICAgLy8gSWYgaXQgc3RhcnRzIHdpdGggfiwgZXhwYW5kIHRvIGhvbWUgZGlyZWN0b3J5XG4gICAgICAgIC8vIFByaW9yaXR5OiBlbnYgdmFycyAtPiBvcy5ob21lZGlyKCkgKG1vc3QgcmVsaWFibGUgY3Jvc3MtcGxhdGZvcm0pXG4gICAgICAgIGxldCByZXNvbHZlZENsYXVkZVBhdGggPSBjb25maWcuY2xhdWRlUGF0aDtcbiAgICAgICAgaWYgKHJlc29sdmVkQ2xhdWRlUGF0aC5zdGFydHNXaXRoKCd+JykpIHtcbiAgICAgICAgICAgIGNvbnN0IGhvbWVEaXIgPSBzaGVsbEVudi5IT01FIHx8IHNoZWxsRW52LlVTRVJQUk9GSUxFIHx8IG9zLmhvbWVkaXIoKTtcbiAgICAgICAgICAgIHJlc29sdmVkQ2xhdWRlUGF0aCA9IHJlc29sdmVkQ2xhdWRlUGF0aC5yZXBsYWNlKCd+JywgaG9tZURpcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBpdCdzIG5vdCBhbiBhYnNvbHV0ZSBwYXRoLCB0cnkgdG8gZmluZCBpdCBpbiBQQVRIXG4gICAgICAgIGlmICghcGF0aC5pc0Fic29sdXRlKHJlc29sdmVkQ2xhdWRlUGF0aCkpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYSBjb21tYW5kIG5hbWUgKGxpa2UgXCJjbGF1ZGVcIilcbiAgICAgICAgICAgIC8vIFRyeSB0byBmaW5kIGl0IGluIFBBVEggZnJvbSBzaGVsbCBlbnZpcm9ubWVudFxuICAgICAgICAgICAgY29uc3QgcGF0aFNlcGFyYXRvciA9IHRoaXMuZ2V0UGF0aFNlcGFyYXRvcigpO1xuICAgICAgICAgICAgY29uc3QgcGF0aERpcnMgPSAoc2hlbGxFbnYuUEFUSCB8fCAnJykuc3BsaXQocGF0aFNlcGFyYXRvcikuZmlsdGVyKGRpciA9PiBkaXIpO1xuXG4gICAgICAgICAgICAvLyBPbiBXaW5kb3dzLCBhbHNvIGNoZWNrIGZvciAuZXhlLCAuY21kLCAuYmF0IGV4dGVuc2lvbnNcbiAgICAgICAgICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmlzV2luZG93cygpID8gWycnLCAnLmV4ZScsICcuY21kJywgJy5iYXQnXSA6IFsnJ107XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgZGlyIG9mIHBhdGhEaXJzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBleHQgb2YgZXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbihkaXIsIHJlc29sdmVkQ2xhdWRlUGF0aCArIGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcy5leGlzdHNTeW5jKGZ1bGxQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRDbGF1ZGVQYXRoID0gZnVsbFBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGF0aC5pc0Fic29sdXRlKHJlc29sdmVkQ2xhdWRlUGF0aCkpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5vbkRlYnVnT3V0cHV0KSB7XG4gICAgICAgICAgICBjb25maWcub25EZWJ1Z091dHB1dChgW0RFQlVHXSBSZXNvbHZlZCBjbGF1ZGUgcGF0aDogJHtyZXNvbHZlZENsYXVkZVBhdGh9XFxuYCk7XG4gICAgICAgICAgICBjb25maWcub25EZWJ1Z091dHB1dChgW0RFQlVHXSBDb21tYW5kOiAke3Jlc29sdmVkQ2xhdWRlUGF0aH0gJHtjb25maWcuYXJncy5qb2luKCcgJyl9XFxuYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVc2UgdGhlIHNoZWxsIHRvIGV4ZWN1dGUgdGhlIGNvbW1hbmQsIHdoaWNoIGhhbmRsZXMgc2hlYmFuZ3MgYW5kIFBBVEggcmVzb2x1dGlvblxuICAgICAgICAvLyBUaGlzIGlzIHRoZSBzYW1lIGFzIHJ1bm5pbmcgaXQgZnJvbSB5b3VyIHRlcm1pbmFsXG4gICAgICAgIGNvbnN0IHNoZWxsID0gdGhpcy5nZXREZWZhdWx0U2hlbGwoKTtcblxuICAgICAgICBpZiAoY29uZmlnLm9uRGVidWdPdXRwdXQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5vbkRlYnVnT3V0cHV0KGBbREVCVUddIFVzaW5nIHNoZWxsOiAke3NoZWxsfVxcbmApO1xuICAgICAgICAgICAgY29uZmlnLm9uRGVidWdPdXRwdXQoYFtERUJVR10gUGxhdGZvcm06ICR7cHJvY2Vzcy5wbGF0Zm9ybX1cXG5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuc3VyZSBVVEYtOCBsb2NhbGUgaXMgc2V0IGZvciBwcm9wZXIgaGFuZGxpbmcgb2Ygc3BlY2lhbCBjaGFyYWN0ZXJzIChcdTAwRjEsIFx1MDBFMSwgXHUwMEJELCBldGMuKVxuICAgICAgICAvLyBUaGlzIGlzIGNyaXRpY2FsIGZvciBub24tQVNDSUkgY2hhcmFjdGVycyB0byB3b3JrIGNvcnJlY3RseVxuICAgICAgICBjb25zdCBlbnZXaXRoVXRmOCA9IHtcbiAgICAgICAgICAgIC4uLnNoZWxsRW52LFxuICAgICAgICAgICAgTEFORzogc2hlbGxFbnYuTEFORyB8fCAnZW5fVVMuVVRGLTgnLFxuICAgICAgICAgICAgTENfQUxMOiBzaGVsbEVudi5MQ19BTEwgfHwgJ2VuX1VTLlVURi04JyxcbiAgICAgICAgICAgIExDX0NUWVBFOiBzaGVsbEVudi5MQ19DVFlQRSB8fCAnZW5fVVMuVVRGLTgnLFxuICAgICAgICAgICAgUFlUSE9OSU9FTkNPRElORzogJ3V0Zi04JywgIC8vIEluIGNhc2UgQ2xhdWRlIENMSSB1c2VzIFB5dGhvblxuICAgICAgICAgICAgTk9ERV9PUFRJT05TOiBzaGVsbEVudi5OT0RFX09QVElPTlMgPyBgJHtzaGVsbEVudi5OT0RFX09QVElPTlN9IC0taW5wdXQtdHlwZT1tb2R1bGVgIDogJydcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgY3dkOiBjb25maWcud29ya2luZ0RpcixcbiAgICAgICAgICAgIGVudjogZW52V2l0aFV0ZjgsXG4gICAgICAgICAgICBzaGVsbDogc2hlbGxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBjaGlsZFByb2Nlc3MgPSBzcGF3bihyZXNvbHZlZENsYXVkZVBhdGgsIGNvbmZpZy5hcmdzLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBTZXQgZW5jb2RpbmcgZm9yIHN0ZGluIHRvIFVURi04IGZvciBwcm9wZXIgaGFuZGxpbmcgb2Ygc3BlY2lhbCBjaGFyYWN0ZXJzXG4gICAgICAgIGlmIChjaGlsZFByb2Nlc3Muc3RkaW4pIHtcbiAgICAgICAgICAgIGNoaWxkUHJvY2Vzcy5zdGRpbi5zZXREZWZhdWx0RW5jb2RpbmcoJ3V0ZjgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGlsZFByb2Nlc3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZCBzdGRpbiBpbnB1dCB0byBwcm9jZXNzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvY2VzcyBDaGlsZCBwcm9jZXNzXG4gICAgICogQHBhcmFtIHByb21wdCBQcm9tcHQgdG8gc2VuZFxuICAgICAqL1xuICAgIHN0YXRpYyBzZW5kSW5wdXQocHJvY2VzczogQ2hpbGRQcm9jZXNzLCBwcm9tcHQ6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBpZiAocHJvY2Vzcy5zdGRpbikge1xuICAgICAgICAgICAgY29uc3QgaW5wdXRNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogcHJvbXB0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QganNvbklucHV0ID0gSlNPTi5zdHJpbmdpZnkoaW5wdXRNZXNzYWdlKSArICdcXG4nO1xuICAgICAgICAgICAgLy8gRXhwbGljaXRseSB1c2UgVVRGLTggZW5jb2RpbmcgdG8gaGFuZGxlIHNwZWNpYWwgY2hhcmFjdGVycyAoXHUwMEJELCBcdTAwQkMsIFx1MDBGMSwgZXRjLilcbiAgICAgICAgICAgIHByb2Nlc3Muc3RkaW4ud3JpdGUoanNvbklucHV0LCAndXRmOCcpO1xuICAgICAgICAgICAgcHJvY2Vzcy5zdGRpbi5lbmQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBDbGF1ZGVDb2RlUmVzcG9uc2UgfSBmcm9tICcuL2NsYXVkZS1jb2RlLXJ1bm5lcic7XG5pbXBvcnQgeyBUb2tlblVzYWdlIH0gZnJvbSAnLi90eXBlcyc7XG5cbi8qKlxuICogU3RyZWFtIGV2ZW50IHN0cnVjdHVyZSBmcm9tIENsYXVkZSBDb2RlIENMSVxuICovXG5pbnRlcmZhY2UgU3RyZWFtRXZlbnQge1xuICAgIHR5cGU6IHN0cmluZztcbiAgICBldmVudF90eXBlPzogc3RyaW5nO1xuICAgIGRlbHRhPzoge1xuICAgICAgICB0eXBlPzogc3RyaW5nO1xuICAgICAgICB0ZXh0Pzogc3RyaW5nO1xuICAgIH07XG4gICAgbWVzc2FnZT86IHtcbiAgICAgICAgY29udGVudD86IEFycmF5PHtcbiAgICAgICAgICAgIHR5cGU6IHN0cmluZztcbiAgICAgICAgICAgIHRleHQ/OiBzdHJpbmc7XG4gICAgICAgIH0+O1xuICAgIH07XG4gICAgdXNhZ2U/OiB7XG4gICAgICAgIGlucHV0X3Rva2Vucz86IG51bWJlcjtcbiAgICAgICAgb3V0cHV0X3Rva2Vucz86IG51bWJlcjtcbiAgICB9O1xufVxuXG4vKipcbiAqIFBhcnNlZCBzdHJlYW0gb3V0cHV0IGZyb20gQ2xhdWRlIENvZGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYXJzZWRPdXRwdXQge1xuICAgIGFzc2lzdGFudFRleHQ6IHN0cmluZztcbiAgICB0b2tlblVzYWdlPzogVG9rZW5Vc2FnZTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgQ2xhdWRlIENvZGUgb3V0cHV0IGFuZCBidWlsZHMgcmVzcG9uc2VzXG4gKi9cbmV4cG9ydCBjbGFzcyBSZXNwb25zZVBhcnNlciB7XG4gICAgLyoqXG4gICAgICogUGFyc2UgSlNPTiBvdXRwdXQgbGluZXMgZnJvbSBDbGF1ZGUgQ29kZVxuICAgICAqXG4gICAgICogQHBhcmFtIG91dHB1dExpbmVzIEFycmF5IG9mIEpTT04gb3V0cHV0IGxpbmVzXG4gICAgICogQHJldHVybnMgUGFyc2VkIG91dHB1dCB3aXRoIGFzc2lzdGFudCB0ZXh0IGFuZCB0b2tlbiB1c2FnZVxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZU91dHB1dChvdXRwdXRMaW5lczogc3RyaW5nW10pOiBQYXJzZWRPdXRwdXQge1xuICAgICAgICBsZXQgYXNzaXN0YW50VGV4dCA9ICcnO1xuICAgICAgICBsZXQgdG9rZW5Vc2FnZTogVG9rZW5Vc2FnZSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2Ygb3V0cHV0TGluZXMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBKU09OLnBhcnNlKGxpbmUpIGFzIFN0cmVhbUV2ZW50O1xuXG4gICAgICAgICAgICAgICAgLy8gQ29sbGVjdCB0ZXh0IGZyb20gc3RyZWFtaW5nIGV2ZW50cyAocmVhbC10aW1lIGRlbHRhcylcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3N0cmVhbV9ldmVudCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmV2ZW50X3R5cGUgPT09ICdjb250ZW50X2Jsb2NrX2RlbHRhJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRlbHRhPy50eXBlID09PSAndGV4dF9kZWx0YScgJiYgZXZlbnQuZGVsdGEudGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lzdGFudFRleHQgKz0gZXZlbnQuZGVsdGEudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFsc28gY29sbGVjdCBmcm9tIGNvbXBsZXRlIGFzc2lzdGFudCBtZXNzYWdlcyAoZmFsbGJhY2spXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdhc3Npc3RhbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5tZXNzYWdlPy5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJsb2NrIG9mIGV2ZW50Lm1lc3NhZ2UuY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9jay50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzaXN0YW50VGV4dCArPSBibG9jay50ZXh0ICsgJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRva2VuIHVzYWdlIGZyb20gcmVzdWx0IGV2ZW50XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdyZXN1bHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC51c2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5Vc2FnZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFRva2VuczogZXZlbnQudXNhZ2UuaW5wdXRfdG9rZW5zIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0VG9rZW5zOiBldmVudC51c2FnZS5vdXRwdXRfdG9rZW5zIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxUb2tlbnM6IChldmVudC51c2FnZS5pbnB1dF90b2tlbnMgfHwgMCkgKyAoZXZlbnQudXNhZ2Uub3V0cHV0X3Rva2VucyB8fCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgIC8vIFNraXAgaW52YWxpZCBKU09OIGxpbmVzXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXNzaXN0YW50VGV4dDogYXNzaXN0YW50VGV4dC50cmltKCksXG4gICAgICAgICAgICB0b2tlblVzYWdlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnVpbGQgZXJyb3IgcmVzcG9uc2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlcnJvciBFcnJvciBtZXNzYWdlXG4gICAgICogQHBhcmFtIG91dHB1dExpbmVzIE91dHB1dCBsaW5lcyAoaWYgYW55KVxuICAgICAqIEByZXR1cm5zIEVycm9yIHJlc3BvbnNlXG4gICAgICovXG4gICAgc3RhdGljIGJ1aWxkRXJyb3JSZXNwb25zZShlcnJvcjogc3RyaW5nLCBvdXRwdXRMaW5lczogc3RyaW5nW10gPSBbXSk6IENsYXVkZUNvZGVSZXNwb25zZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgb3V0cHV0OiBvdXRwdXRMaW5lc1xuICAgICAgICB9O1xuICAgIH1cbn1cbiIsICIvKipcbiAqIFV0aWxpdHkgZm9yIGRldGVjdGluZyBwZXJtaXNzaW9uIHJlcXVlc3RzIGluIENsYXVkZSdzIHJlc3BvbnNlc1xuICovXG5leHBvcnQgY2xhc3MgUmVzcG9uc2VDb250ZW50RXh0cmFjdG9yIHtcbiAgICAvKipcbiAgICAgKiBEZXRlY3QgaWYgQ2xhdWRlJ3MgcmVzcG9uc2UgaXMgYXNraW5nIGZvciBwZXJtaXNzaW9uIHRvIHBlcmZvcm0gYW4gYWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGV4dCBUaGUgdGV4dCBjb250ZW50IHRvIGFuYWx5emVcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB0ZXh0IGNvbnRhaW5zIGEgcGVybWlzc2lvbiByZXF1ZXN0IHBhdHRlcm5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGV0ZWN0UGVybWlzc2lvblJlcXVlc3QodGV4dDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIC8vIENoZWNrIGZvciBleHBsaWNpdCBSRVFVSVJFRF9BUFBST1ZBTCBrZXl3b3JkXG4gICAgICAgIHJldHVybiB0ZXh0LmluY2x1ZGVzKCdSRVFVSVJFRF9BUFBST1ZBTCcpO1xuICAgIH1cbn1cbiIsICIvKipcbiAqIFV0aWxpdHkgZm9yIHBhcnNpbmcgb3V0cHV0IGxpbmVzIGFuZCBleHRyYWN0aW5nIHN0YXR1cyBpbmZvcm1hdGlvblxuICovXG5leHBvcnQgY2xhc3MgT3V0cHV0U3RhdHVzTWFuYWdlciB7XG4gICAgLyoqXG4gICAgICogUGFyc2UgYW4gb3V0cHV0IGxpbmUgYW5kIGV4dHJhY3Qgc3RhdHVzIGluZm9ybWF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGluZSBUaGUgb3V0cHV0IGxpbmUgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJucyBTdGF0dXMgbWVzc2FnZSB0byBkaXNwbGF5LCBvciBudWxsIGlmIG5vIHN0YXR1cyBzaG91bGQgYmUgc2hvd25cbiAgICAgKi9cbiAgICBzdGF0aWMgZXh0cmFjdFN0YXR1cyhsaW5lOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgbGluZSBjb250YWlucyB0b29sIHVzYWdlIGluZm9ybWF0aW9uXG4gICAgICAgIGlmIChsaW5lLmluY2x1ZGVzKCdcdUQ4M0RcdUREMjcgVXNpbmcgdG9vbDonKSkge1xuICAgICAgICAgICAgY29uc3QgdG9vbE1hdGNoID0gbGluZS5tYXRjaCgvXHVEODNEXHVERDI3IFVzaW5nIHRvb2w6IChcXHcrKS8pO1xuICAgICAgICAgICAgaWYgKHRvb2xNYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgXHVEODNEXHVERDI3IFVzaW5nICR7dG9vbE1hdGNoWzFdfSB0b29sLi4uYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsaW5lLmluY2x1ZGVzKCckICcpKSB7XG4gICAgICAgICAgICAvLyBCYXNoIGNvbW1hbmQgZXhlY3V0aW9uXG4gICAgICAgICAgICBjb25zdCBjbWRNYXRjaCA9IGxpbmUubWF0Y2goL1xcJCAoLispLyk7XG4gICAgICAgICAgICBpZiAoY21kTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbWQgPSBjbWRNYXRjaFsxXS5zdWJzdHJpbmcoMCwgNTApO1xuICAgICAgICAgICAgICAgIHJldHVybiBgXHUyNkExIFJ1bm5pbmc6ICR7Y21kfSR7Y21kTWF0Y2hbMV0ubGVuZ3RoID4gNTAgPyAnLi4uJyA6ICcnfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobGluZS5pbmNsdWRlcygnXHVEODNEXHVERDBEIFF1ZXJ5OicpIHx8IGxpbmUuaW5jbHVkZXMoJ1F1ZXJ5OicpKSB7XG4gICAgICAgICAgICAvLyBXZWIgc2VhcmNoXG4gICAgICAgICAgICBjb25zdCBxdWVyeU1hdGNoID0gbGluZS5tYXRjaCgvUXVlcnk6IFwiKC4rPylcIi8pO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBxdWVyeSA9IHF1ZXJ5TWF0Y2hbMV0uc3Vic3RyaW5nKDAsIDQwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYFx1RDgzRFx1REQwRCBTZWFyY2hpbmc6ICR7cXVlcnl9JHtxdWVyeU1hdGNoWzFdLmxlbmd0aCA+IDQwID8gJy4uLicgOiAnJ31gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGxpbmUuaW5jbHVkZXMoJ1x1RDgzQ1x1REYxMCBVUkw6JykgfHwgbGluZS5pbmNsdWRlcygnVVJMOicpKSB7XG4gICAgICAgICAgICAvLyBXZWIgZmV0Y2hcbiAgICAgICAgICAgIGNvbnN0IHVybE1hdGNoID0gbGluZS5tYXRjaCgvVVJMOiAoLispLyk7XG4gICAgICAgICAgICBpZiAodXJsTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSB1cmxNYXRjaFsxXS5zdWJzdHJpbmcoMCwgNDApO1xuICAgICAgICAgICAgICAgIHJldHVybiBgXHVEODNDXHVERjEwIEZldGNoaW5nOiAke3VybH0ke3VybE1hdGNoWzFdLmxlbmd0aCA+IDQwID8gJy4uLicgOiAnJ31gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGxpbmUuaW5jbHVkZXMoJ1x1RDgzRFx1RENENiBSZWFkaW5nIGZpbGU6JykgfHwgbGluZS5pbmNsdWRlcygnXHVEODNEXHVEQ0Q2IEZpbGU6JykpIHtcbiAgICAgICAgICAgIC8vIEZpbGUgcmVhZGluZ1xuICAgICAgICAgICAgY29uc3QgZmlsZU1hdGNoID0gbGluZS5tYXRjaCgvKD86UmVhZGluZyBmaWxlOnxGaWxlOilcXHMrKC4rKS8pO1xuICAgICAgICAgICAgaWYgKGZpbGVNYXRjaCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBmaWxlTWF0Y2hbMV0uc3BsaXQoJy8nKS5wb3AoKSB8fCBmaWxlTWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBcdUQ4M0RcdURDRDYgUmVhZGluZzogJHtmaWxlLnN1YnN0cmluZygwLCA0MCl9Li4uYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsaW5lLmluY2x1ZGVzKCdcdTI3MERcdUZFMEYgIFdyaXRpbmcgZmlsZTonKSB8fCBsaW5lLmluY2x1ZGVzKCdcdTI3MERcdUZFMEYgIEZpbGU6JykpIHtcbiAgICAgICAgICAgIC8vIEZpbGUgd3JpdGluZ1xuICAgICAgICAgICAgY29uc3QgZmlsZU1hdGNoID0gbGluZS5tYXRjaCgvKD86V3JpdGluZyBmaWxlOnxGaWxlOilcXHMrKC4rKS8pO1xuICAgICAgICAgICAgaWYgKGZpbGVNYXRjaCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBmaWxlTWF0Y2hbMV0uc3BsaXQoJy8nKS5wb3AoKSB8fCBmaWxlTWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBcdTI3MERcdUZFMEYgV3JpdGluZzogJHtmaWxlLnN1YnN0cmluZygwLCA0MCl9Li4uYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsaW5lLmluY2x1ZGVzKCdcdTI3MEZcdUZFMEYgIEVkaXRpbmcgZmlsZTonKSB8fCBsaW5lLmluY2x1ZGVzKCdcdTI3MEZcdUZFMEYgIEZpbGU6JykpIHtcbiAgICAgICAgICAgIC8vIEZpbGUgZWRpdGluZ1xuICAgICAgICAgICAgY29uc3QgZmlsZU1hdGNoID0gbGluZS5tYXRjaCgvKD86RWRpdGluZyBmaWxlOnxGaWxlOilcXHMrKC4rKS8pO1xuICAgICAgICAgICAgaWYgKGZpbGVNYXRjaCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBmaWxlTWF0Y2hbMV0uc3BsaXQoJy8nKS5wb3AoKSB8fCBmaWxlTWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBcdTI3MEZcdUZFMEYgRWRpdGluZzogJHtmaWxlLnN1YnN0cmluZygwLCA0MCl9Li4uYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsaW5lLmluY2x1ZGVzKCdcdUQ4M0RcdUREMEQgUGF0dGVybjonKSB8fCBsaW5lLmluY2x1ZGVzKCdQYXR0ZXJuOicpKSB7XG4gICAgICAgICAgICAvLyBHcmVwL0dsb2Igc2VhcmNoXG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuTWF0Y2ggPSBsaW5lLm1hdGNoKC9QYXR0ZXJuOiAoLispLyk7XG4gICAgICAgICAgICBpZiAocGF0dGVybk1hdGNoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHBhdHRlcm5NYXRjaFsxXS5zdWJzdHJpbmcoMCwgNDApO1xuICAgICAgICAgICAgICAgIHJldHVybiBgXHVEODNEXHVERDBFIFNlYXJjaGluZyBwYXR0ZXJuOiAke3BhdHRlcm59JHtwYXR0ZXJuTWF0Y2hbMV0ubGVuZ3RoID4gNDAgPyAnLi4uJyA6ICcnfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobGluZS5pbmNsdWRlcygnXHVEODNFXHVERDE2IExhdW5jaGluZyBhZ2VudDonKSB8fCBsaW5lLmluY2x1ZGVzKCdBZ2VudDonKSkge1xuICAgICAgICAgICAgLy8gQWdlbnQvVGFzayB0b29sXG4gICAgICAgICAgICBjb25zdCBhZ2VudE1hdGNoID0gbGluZS5tYXRjaCgvKD86QWdlbnQ6fFR5cGU6KVxccysoLispLyk7XG4gICAgICAgICAgICBpZiAoYWdlbnRNYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgXHVEODNFXHVERDE2IExhdW5jaGluZyAke2FnZW50TWF0Y2hbMV19IGFnZW50Li4uYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsaW5lLmluY2x1ZGVzKCdcdUQ4M0RcdURDQUMnKSAmJiAhbGluZS5pbmNsdWRlcygnW3Jhd10nKSkge1xuICAgICAgICAgICAgLy8gQ2xhdWRlIGlzIHJlc3BvbmRpbmdcbiAgICAgICAgICAgIHJldHVybiAnXHVEODNEXHVEQ0FDIENsYXVkZSBpcyByZXNwb25kaW5nLi4uJztcbiAgICAgICAgfSBlbHNlIGlmIChsaW5lLmluY2x1ZGVzKCdcdTI3MTMnKSAmJiBsaW5lLmluY2x1ZGVzKCdjb21wbGV0ZScpKSB7XG4gICAgICAgICAgICAvLyBUb29sIGNvbXBsZXRlZFxuICAgICAgICAgICAgcmV0dXJuICdcdTI3MDUgUHJvY2Vzc2luZyByZXN1bHRzLi4uJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyB0IH0gZnJvbSAnLi4vLi4vaTE4bic7XG5cbi8qKlxuICogVXRpbGl0eSBmb3IgZ2VuZXJhdGluZyBzaWRlLWJ5LXNpZGUgZGlmZiB2aWV3cyAoSW50ZWxsaUotc3R5bGUpXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGlmZkNoYW5nZSB7XG4gICAgdHlwZTogJ2VxdWFsJyB8ICdkZWxldGUnIHwgJ2luc2VydCcgfCAnbW9kaWZ5JztcbiAgICBvbGRDb250ZW50Pzogc3RyaW5nO1xuICAgIG5ld0NvbnRlbnQ/OiBzdHJpbmc7XG4gICAgb2xkTGluZU51bT86IG51bWJlcjtcbiAgICBuZXdMaW5lTnVtPzogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgRGlmZkdlbmVyYXRvciB7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgc2lkZS1ieS1zaWRlIGRpZmYgdmlldyBhcyBhIERPTSBlbGVtZW50IGJldHdlZW4gb3JpZ2luYWwgYW5kIG1vZGlmaWVkIGNvbnRlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcmlnaW5hbCBPcmlnaW5hbCBjb250ZW50XG4gICAgICogQHBhcmFtIG1vZGlmaWVkIE1vZGlmaWVkIGNvbnRlbnRcbiAgICAgKiBAcmV0dXJucyBIVE1MRWxlbWVudCByZXByZXNlbnRpbmcgdGhlIHNpZGUtYnktc2lkZSBkaWZmXG4gICAgICovXG4gICAgc3RhdGljIGdlbmVyYXRlRGlmZkVsZW1lbnQob3JpZ2luYWw6IHN0cmluZywgbW9kaWZpZWQ6IHN0cmluZyk6IEhUTUxFbGVtZW50IHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxMaW5lcyA9IG9yaWdpbmFsLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgY29uc3QgbW9kaWZpZWRMaW5lcyA9IG1vZGlmaWVkLnNwbGl0KCdcXG4nKTtcblxuICAgICAgICAvLyBDb21wdXRlIGRpZmZcbiAgICAgICAgY29uc3QgZGlmZiA9IHRoaXMuY29tcHV0ZURpZmYob3JpZ2luYWxMaW5lcywgbW9kaWZpZWRMaW5lcyk7XG5cbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSAnY2xhdWRlLWNvZGUtZGlmZi1zaWRlLWJ5LXNpZGUnO1xuXG4gICAgICAgIC8vIEhlYWRlclxuICAgICAgICBjb25zdCBoZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgaGVhZGVyLmNsYXNzTmFtZSA9ICdkaWZmLWhlYWRlcic7XG5cbiAgICAgICAgY29uc3QgbGVmdEhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBsZWZ0SGVhZGVyLmNsYXNzTmFtZSA9ICdkaWZmLWNvbHVtbiBkaWZmLWNvbHVtbi1sZWZ0JztcbiAgICAgICAgY29uc3QgbGVmdFRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICBsZWZ0VGl0bGUuY2xhc3NOYW1lID0gJ2RpZmYtaGVhZGVyLXRpdGxlJztcbiAgICAgICAgbGVmdFRpdGxlLnRleHRDb250ZW50ID0gdCgnZGlmZi5vcmlnaW5hbCcpO1xuICAgICAgICBsZWZ0SGVhZGVyLmFwcGVuZENoaWxkKGxlZnRUaXRsZSk7XG5cbiAgICAgICAgY29uc3QgcmlnaHRIZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgcmlnaHRIZWFkZXIuY2xhc3NOYW1lID0gJ2RpZmYtY29sdW1uIGRpZmYtY29sdW1uLXJpZ2h0JztcbiAgICAgICAgY29uc3QgcmlnaHRUaXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgcmlnaHRUaXRsZS5jbGFzc05hbWUgPSAnZGlmZi1oZWFkZXItdGl0bGUnO1xuICAgICAgICByaWdodFRpdGxlLnRleHRDb250ZW50ID0gdCgnZGlmZi5tb2RpZmllZCcpO1xuICAgICAgICByaWdodEhlYWRlci5hcHBlbmRDaGlsZChyaWdodFRpdGxlKTtcblxuICAgICAgICBoZWFkZXIuYXBwZW5kQ2hpbGQobGVmdEhlYWRlcik7XG4gICAgICAgIGhlYWRlci5hcHBlbmRDaGlsZChyaWdodEhlYWRlcik7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChoZWFkZXIpO1xuXG4gICAgICAgIC8vIENvbnRlbnRcbiAgICAgICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb250ZW50LmNsYXNzTmFtZSA9ICdkaWZmLWNvbnRlbnQnO1xuXG4gICAgICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGRpZmYpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgcm93LmNsYXNzTmFtZSA9IGBkaWZmLXJvdyBkaWZmLSR7Y2hhbmdlLnR5cGV9YDtcblxuICAgICAgICAgICAgaWYgKGNoYW5nZS50eXBlID09PSAnZXF1YWwnKSB7XG4gICAgICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlRGlmZkNvbHVtbignbGVmdCcsIGNoYW5nZS5vbGRMaW5lTnVtLCBjaGFuZ2Uub2xkQ29udGVudCkpO1xuICAgICAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZURpZmZDb2x1bW4oJ3JpZ2h0JywgY2hhbmdlLm5ld0xpbmVOdW0sIGNoYW5nZS5uZXdDb250ZW50KSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAnZGVsZXRlJykge1xuICAgICAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZURpZmZDb2x1bW4oJ2xlZnQnLCBjaGFuZ2Uub2xkTGluZU51bSwgY2hhbmdlLm9sZENvbnRlbnQpKTtcbiAgICAgICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQodGhpcy5jcmVhdGVEaWZmQ29sdW1uKCdyaWdodCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAnaW5zZXJ0Jykge1xuICAgICAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZURpZmZDb2x1bW4oJ2xlZnQnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZURpZmZDb2x1bW4oJ3JpZ2h0JywgY2hhbmdlLm5ld0xpbmVOdW0sIGNoYW5nZS5uZXdDb250ZW50KSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5nZS50eXBlID09PSAnbW9kaWZ5Jykge1xuICAgICAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZURpZmZDb2x1bW4oJ2xlZnQnLCBjaGFuZ2Uub2xkTGluZU51bSwgY2hhbmdlLm9sZENvbnRlbnQpKTtcbiAgICAgICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQodGhpcy5jcmVhdGVEaWZmQ29sdW1uKCdyaWdodCcsIGNoYW5nZS5uZXdMaW5lTnVtLCBjaGFuZ2UubmV3Q29udGVudCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKHJvdyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZGlmZiBjb2x1bW4gZWxlbWVudFxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIGNyZWF0ZURpZmZDb2x1bW4oc2lkZTogJ2xlZnQnIHwgJ3JpZ2h0JywgbGluZU51bT86IG51bWJlciwgY29udGVudD86IHN0cmluZywgaXNFbXB0eTogYm9vbGVhbiA9IGZhbHNlKTogSFRNTEVsZW1lbnQge1xuICAgICAgICBjb25zdCBjb2x1bW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29sdW1uLmNsYXNzTmFtZSA9IGBkaWZmLWNvbHVtbiBkaWZmLWNvbHVtbi0ke3NpZGV9JHtpc0VtcHR5ID8gJyBkaWZmLWVtcHR5JyA6ICcnfWA7XG5cbiAgICAgICAgY29uc3QgbGluZU51bVNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIGxpbmVOdW1TcGFuLmNsYXNzTmFtZSA9ICdkaWZmLWxpbmUtbnVtYmVyJztcbiAgICAgICAgbGluZU51bVNwYW4udGV4dENvbnRlbnQgPSBsaW5lTnVtICE9PSB1bmRlZmluZWQgPyBTdHJpbmcobGluZU51bSkgOiAnJztcblxuICAgICAgICBjb25zdCBjb250ZW50U3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgY29udGVudFNwYW4uY2xhc3NOYW1lID0gJ2RpZmYtbGluZS1jb250ZW50JztcbiAgICAgICAgY29udGVudFNwYW4udGV4dENvbnRlbnQgPSBjb250ZW50IHx8ICcnO1xuXG4gICAgICAgIGNvbHVtbi5hcHBlbmRDaGlsZChsaW5lTnVtU3Bhbik7XG4gICAgICAgIGNvbHVtbi5hcHBlbmRDaGlsZChjb250ZW50U3Bhbik7XG5cbiAgICAgICAgcmV0dXJuIGNvbHVtbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIGRpZmYgYmV0d2VlbiB0d28gYXJyYXlzIG9mIGxpbmVzIHVzaW5nIGEgc2ltcGxlIGFsZ29yaXRobVxuICAgICAqXG4gICAgICogQHBhcmFtIG9sZExpbmVzIE9yaWdpbmFsIGxpbmVzXG4gICAgICogQHBhcmFtIG5ld0xpbmVzIE1vZGlmaWVkIGxpbmVzXG4gICAgICogQHJldHVybnMgQXJyYXkgb2YgZGlmZiBjaGFuZ2VzXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgY29tcHV0ZURpZmYob2xkTGluZXM6IHN0cmluZ1tdLCBuZXdMaW5lczogc3RyaW5nW10pOiBEaWZmQ2hhbmdlW10ge1xuICAgICAgICBjb25zdCByZXN1bHQ6IERpZmZDaGFuZ2VbXSA9IFtdO1xuXG4gICAgICAgIGxldCBvbGRJbmRleCA9IDA7XG4gICAgICAgIGxldCBuZXdJbmRleCA9IDA7XG4gICAgICAgIGxldCBvbGRMaW5lTnVtID0gMTtcbiAgICAgICAgbGV0IG5ld0xpbmVOdW0gPSAxO1xuXG4gICAgICAgIHdoaWxlIChvbGRJbmRleCA8IG9sZExpbmVzLmxlbmd0aCB8fCBuZXdJbmRleCA8IG5ld0xpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKG9sZEluZGV4ID49IG9sZExpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIFJlbWFpbmluZyBsaW5lcyBhcmUgaW5zZXJ0aW9uc1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2luc2VydCcsXG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRlbnQ6IG5ld0xpbmVzW25ld0luZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgbmV3TGluZU51bTogbmV3TGluZU51bVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG5ld0luZGV4Kys7XG4gICAgICAgICAgICAgICAgbmV3TGluZU51bSsrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuZXdJbmRleCA+PSBuZXdMaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1haW5pbmcgbGluZXMgYXJlIGRlbGV0aW9uc1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RlbGV0ZScsXG4gICAgICAgICAgICAgICAgICAgIG9sZENvbnRlbnQ6IG9sZExpbmVzW29sZEluZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgb2xkTGluZU51bTogb2xkTGluZU51bVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9sZEluZGV4Kys7XG4gICAgICAgICAgICAgICAgb2xkTGluZU51bSsrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvbGRMaW5lc1tvbGRJbmRleF0gPT09IG5ld0xpbmVzW25ld0luZGV4XSkge1xuICAgICAgICAgICAgICAgIC8vIExpbmVzIGFyZSBlcXVhbFxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2VxdWFsJyxcbiAgICAgICAgICAgICAgICAgICAgb2xkQ29udGVudDogb2xkTGluZXNbb2xkSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICBuZXdDb250ZW50OiBuZXdMaW5lc1tuZXdJbmRleF0sXG4gICAgICAgICAgICAgICAgICAgIG9sZExpbmVOdW06IG9sZExpbmVOdW0sXG4gICAgICAgICAgICAgICAgICAgIG5ld0xpbmVOdW06IG5ld0xpbmVOdW1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvbGRJbmRleCsrO1xuICAgICAgICAgICAgICAgIG5ld0luZGV4Kys7XG4gICAgICAgICAgICAgICAgb2xkTGluZU51bSsrO1xuICAgICAgICAgICAgICAgIG5ld0xpbmVOdW0rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTGluZXMgYXJlIGRpZmZlcmVudCAtIGNoZWNrIGlmIGl0J3MgYSBtb2RpZmljYXRpb24gb3IgZGVsZXRlK2luc2VydFxuICAgICAgICAgICAgICAgIC8vIEZvciBub3csIHRyZWF0IGNvbnNlY3V0aXZlIGRpZmZlcmVudCBsaW5lcyBhcyBtb2RpZmljYXRpb25zXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbW9kaWZ5JyxcbiAgICAgICAgICAgICAgICAgICAgb2xkQ29udGVudDogb2xkTGluZXNbb2xkSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICBuZXdDb250ZW50OiBuZXdMaW5lc1tuZXdJbmRleF0sXG4gICAgICAgICAgICAgICAgICAgIG9sZExpbmVOdW06IG9sZExpbmVOdW0sXG4gICAgICAgICAgICAgICAgICAgIG5ld0xpbmVOdW06IG5ld0xpbmVOdW1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvbGRJbmRleCsrO1xuICAgICAgICAgICAgICAgIG5ld0luZGV4Kys7XG4gICAgICAgICAgICAgICAgb2xkTGluZU51bSsrO1xuICAgICAgICAgICAgICAgIG5ld0xpbmVOdW0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuIiwgIi8qKlxuICogVG9vbCBDYWxsIFRyYWNrZXJcbiAqIFRyYWNrcyBhbmQgbWFuYWdlcyBNQ1AgdG9vbCBjYWxscyBmb3IgdmlzdWFsaXphdGlvblxuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgVG9vbENhbGwge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgdG9vbE5hbWU6IHN0cmluZztcbiAgICBhcmd1bWVudHM6IGFueTtcbiAgICBzdGF0dXM6ICdwZW5kaW5nJyB8ICdydW5uaW5nJyB8ICdjb21wbGV0ZWQnIHwgJ2ZhaWxlZCc7XG4gICAgc3RhcnRUaW1lOiBudW1iZXI7XG4gICAgZW5kVGltZT86IG51bWJlcjtcbiAgICByZXN1bHQ/OiBhbnk7XG4gICAgZXJyb3I/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCB0eXBlIFRvb2xDYWxsQ2FsbGJhY2sgPSAoY2FsbDogVG9vbENhbGwpID0+IHZvaWQ7XG5cbi8qKlxuICogVG9vbCBDYWxsIFRyYWNrZXJcbiAqIE1hbmFnZXMgdHJhY2tpbmcgb2YgTUNQIHRvb2wgY2FsbHMgd2l0aCBzdGF0ZSB1cGRhdGVzXG4gKi9cbmV4cG9ydCBjbGFzcyBUb29sQ2FsbFRyYWNrZXIge1xuICAgIHByaXZhdGUgY2FsbHM6IE1hcDxzdHJpbmcsIFRvb2xDYWxsPiA9IG5ldyBNYXAoKTtcbiAgICBwcml2YXRlIGNhbGxiYWNrczogU2V0PFRvb2xDYWxsQ2FsbGJhY2s+ID0gbmV3IFNldCgpO1xuXG4gICAgLyoqXG4gICAgICogU3RhcnQgdHJhY2tpbmcgYSB0b29sIGNhbGxcbiAgICAgKi9cbiAgICBzdGFydENhbGwoaWQ6IHN0cmluZywgdG9vbE5hbWU6IHN0cmluZywgYXJnczogYW55KTogVG9vbENhbGwge1xuICAgICAgICBjb25zdCBjYWxsOiBUb29sQ2FsbCA9IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICBhcmd1bWVudHMsXG4gICAgICAgICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgICAgICAgIHN0YXJ0VGltZTogRGF0ZS5ub3coKVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuY2FsbHMuc2V0KGlkLCBjYWxsKTtcbiAgICAgICAgdGhpcy5ub3RpZnlDYWxsYmFja3MoY2FsbCk7XG5cbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRvb2wgY2FsbCBzdGF0dXNcbiAgICAgKi9cbiAgICB1cGRhdGVTdGF0dXMoXG4gICAgICAgIGlkOiBzdHJpbmcsXG4gICAgICAgIHN0YXR1czogVG9vbENhbGxbJ3N0YXR1cyddLFxuICAgICAgICByZXN1bHQ/OiBhbnksXG4gICAgICAgIGVycm9yPzogc3RyaW5nXG4gICAgKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGNhbGwgPSB0aGlzLmNhbGxzLmdldChpZCk7XG4gICAgICAgIGlmICghY2FsbCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBUb29sIGNhbGwgJHtpZH0gbm90IGZvdW5kYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsLnN0YXR1cyA9IHN0YXR1cztcblxuICAgICAgICBpZiAoc3RhdHVzID09PSAnY29tcGxldGVkJyB8fCBzdGF0dXMgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgICBjYWxsLmVuZFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYWxsLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYWxsLmVycm9yID0gZXJyb3I7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5vdGlmeUNhbGxiYWNrcyhjYWxsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSB0b29sIGNhbGwgYnkgSURcbiAgICAgKi9cbiAgICBnZXRDYWxsKGlkOiBzdHJpbmcpOiBUb29sQ2FsbCB8IHVuZGVmaW5lZCB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxzLmdldChpZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCB0b29sIGNhbGxzXG4gICAgICovXG4gICAgZ2V0QWxsQ2FsbHMoKTogVG9vbENhbGxbXSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY2FsbHMudmFsdWVzKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhY3RpdmUgKG5vbi1jb21wbGV0ZWQpIHRvb2wgY2FsbHNcbiAgICAgKi9cbiAgICBnZXRBY3RpdmVDYWxscygpOiBUb29sQ2FsbFtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsQ2FsbHMoKS5maWx0ZXIoXG4gICAgICAgICAgICBjYWxsID0+IGNhbGwuc3RhdHVzICE9PSAnY29tcGxldGVkJyAmJiBjYWxsLnN0YXR1cyAhPT0gJ2ZhaWxlZCdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBjb21wbGV0ZWQgY2FsbHNcbiAgICAgKi9cbiAgICBjbGVhckNvbXBsZXRlZCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgYWN0aXZlQ2FsbHMgPSB0aGlzLmdldEFjdGl2ZUNhbGxzKCk7XG4gICAgICAgIHRoaXMuY2FsbHMuY2xlYXIoKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGNhbGwgb2YgYWN0aXZlQ2FsbHMpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbHMuc2V0KGNhbGwuaWQsIGNhbGwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIGNhbGxzXG4gICAgICovXG4gICAgY2xlYXJBbGwoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY2FsbHMuY2xlYXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gdG9vbCBjYWxsIHVwZGF0ZXNcbiAgICAgKi9cbiAgICBvblRvb2xDYWxsVXBkYXRlKGNhbGxiYWNrOiBUb29sQ2FsbENhbGxiYWNrKTogKCkgPT4gdm9pZCB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiB0aGlzLmNhbGxiYWNrcy5kZWxldGUoY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vdGlmeSBhbGwgY2FsbGJhY2tzIG9mIGEgdG9vbCBjYWxsIHVwZGF0ZVxuICAgICAqL1xuICAgIHByaXZhdGUgbm90aWZ5Q2FsbGJhY2tzKGNhbGw6IFRvb2xDYWxsKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhjYWxsKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gdG9vbCBjYWxsIGNhbGxiYWNrOicsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGR1cmF0aW9uIG9mIGEgdG9vbCBjYWxsIGluIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgIGdldER1cmF0aW9uKGlkOiBzdHJpbmcpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICAgICAgICBjb25zdCBjYWxsID0gdGhpcy5jYWxscy5nZXQoaWQpO1xuICAgICAgICBpZiAoIWNhbGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlbmRUaW1lID0gY2FsbC5lbmRUaW1lIHx8IERhdGUubm93KCk7XG4gICAgICAgIHJldHVybiBlbmRUaW1lIC0gY2FsbC5zdGFydFRpbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHN0YXRpc3RpY3NcbiAgICAgKi9cbiAgICBnZXRTdGF0cygpOiB7XG4gICAgICAgIHRvdGFsOiBudW1iZXI7XG4gICAgICAgIHBlbmRpbmc6IG51bWJlcjtcbiAgICAgICAgcnVubmluZzogbnVtYmVyO1xuICAgICAgICBjb21wbGV0ZWQ6IG51bWJlcjtcbiAgICAgICAgZmFpbGVkOiBudW1iZXI7XG4gICAgfSB7XG4gICAgICAgIGNvbnN0IGNhbGxzID0gdGhpcy5nZXRBbGxDYWxscygpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3RhbDogY2FsbHMubGVuZ3RoLFxuICAgICAgICAgICAgcGVuZGluZzogY2FsbHMuZmlsdGVyKGMgPT4gYy5zdGF0dXMgPT09ICdwZW5kaW5nJykubGVuZ3RoLFxuICAgICAgICAgICAgcnVubmluZzogY2FsbHMuZmlsdGVyKGMgPT4gYy5zdGF0dXMgPT09ICdydW5uaW5nJykubGVuZ3RoLFxuICAgICAgICAgICAgY29tcGxldGVkOiBjYWxscy5maWx0ZXIoYyA9PiBjLnN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcpLmxlbmd0aCxcbiAgICAgICAgICAgIGZhaWxlZDogY2FsbHMuZmlsdGVyKGMgPT4gYy5zdGF0dXMgPT09ICdmYWlsZWQnKS5sZW5ndGhcbiAgICAgICAgfTtcbiAgICB9XG59XG4iLCAiLyoqXG4gKiBUb29sIENhbGwgRGlzcGxheSBDb21wb25lbnRcbiAqIFZpc3VhbGl6ZXMgTUNQIHRvb2wgY2FsbHMgd2l0aCBzdGF0dXMgaW5kaWNhdG9yc1xuICovXG5cbmltcG9ydCB7IFRvb2xDYWxsLCBUb29sQ2FsbFRyYWNrZXIgfSBmcm9tICcuLi90b29sLWNhbGwtdHJhY2tlcic7XG5cbi8qKlxuICogVG9vbCBDYWxsIERpc3BsYXkgQ29tcG9uZW50XG4gKi9cbmV4cG9ydCBjbGFzcyBUb29sQ2FsbERpc3BsYXkge1xuICAgIHByaXZhdGUgY29udGFpbmVyOiBIVE1MRWxlbWVudDtcbiAgICBwcml2YXRlIHRyYWNrZXI6IFRvb2xDYWxsVHJhY2tlcjtcbiAgICBwcml2YXRlIHRvb2xDYWxsRWxlbWVudHM6IE1hcDxzdHJpbmcsIEhUTUxFbGVtZW50PiA9IG5ldyBNYXAoKTtcbiAgICBwcml2YXRlIHVuc3Vic2NyaWJlOiAoKSA9PiB2b2lkO1xuXG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyOiBIVE1MRWxlbWVudCwgdHJhY2tlcjogVG9vbENhbGxUcmFja2VyKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLnRyYWNrZXIgPSB0cmFja2VyO1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0b29sIGNhbGwgdXBkYXRlc1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlID0gdGhpcy50cmFja2VyLm9uVG9vbENhbGxVcGRhdGUoKGNhbGwpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVG9vbENhbGxEaXNwbGF5KGNhbGwpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBJbml0aWFsIHJlbmRlclxuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgdGhlIGNvbXBvbmVudFxuICAgICAqL1xuICAgIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy50b29sQ2FsbEVsZW1lbnRzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmVtcHR5KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGluaXRpYWwgVUlcbiAgICAgKi9cbiAgICBwcml2YXRlIHJlbmRlcigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuZW1wdHkoKTtcblxuICAgICAgICAvLyBDcmVhdGUgaGVhZGVyXG4gICAgICAgIGNvbnN0IGhlYWRlciA9IHRoaXMuY29udGFpbmVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICAgICAgICBjbHM6ICdjbGF1ZGUtY29kZS10b29sLWNhbGwtaGVhZGVyJ1xuICAgICAgICB9KTtcblxuICAgICAgICBoZWFkZXIuY3JlYXRlRWwoJ2gzJywge1xuICAgICAgICAgICAgdGV4dDogJ1Rvb2wgQ2FsbHMnLFxuICAgICAgICAgICAgY2xzOiAnY2xhdWRlLWNvZGUtdG9vbC1jYWxsLXRpdGxlJ1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDcmVhdGUgc3RhdHMgZGlzcGxheVxuICAgICAgICBjb25zdCBzdGF0cyA9IHRoaXMuY29udGFpbmVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICAgICAgICBjbHM6ICdjbGF1ZGUtY29kZS10b29sLWNhbGwtc3RhdHMnXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRzKHN0YXRzKTtcblxuICAgICAgICAvLyBDcmVhdGUgdG9vbCBjYWxscyBjb250YWluZXJcbiAgICAgICAgY29uc3QgY2FsbHNDb250YWluZXIgPSB0aGlzLmNvbnRhaW5lci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgICAgICAgY2xzOiAnY2xhdWRlLWNvZGUtdG9vbC1jYWxscy1jb250YWluZXInXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJlbmRlciBleGlzdGluZyBjYWxsc1xuICAgICAgICBjb25zdCBjYWxscyA9IHRoaXMudHJhY2tlci5nZXRBbGxDYWxscygpO1xuICAgICAgICBmb3IgKGNvbnN0IGNhbGwgb2YgY2FsbHMpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVG9vbENhbGwoY2FsbCwgY2FsbHNDb250YWluZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHN0YXRzIHBlcmlvZGljYWxseVxuICAgICAgICBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRzKHN0YXRzKTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHN0YXRpc3RpY3MgZGlzcGxheVxuICAgICAqL1xuICAgIHByaXZhdGUgdXBkYXRlU3RhdHMoc3RhdHNFbDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgc3RhdHMgPSB0aGlzLnRyYWNrZXIuZ2V0U3RhdHMoKTtcblxuICAgICAgICBzdGF0c0VsLmVtcHR5KCk7XG4gICAgICAgIHN0YXRzRWwuY3JlYXRlRWwoJ3NwYW4nLCB7XG4gICAgICAgICAgICB0ZXh0OiBgVG90YWw6ICR7c3RhdHMudG90YWx9YCxcbiAgICAgICAgICAgIGNsczogJ2NsYXVkZS1jb2RlLXN0YXQtdG90YWwnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzdGF0cy5wZW5kaW5nID4gMCkge1xuICAgICAgICAgICAgc3RhdHNFbC5jcmVhdGVFbCgnc3BhbicsIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBgUGVuZGluZzogJHtzdGF0cy5wZW5kaW5nfWAsXG4gICAgICAgICAgICAgICAgY2xzOiAnY2xhdWRlLWNvZGUtc3RhdC1wZW5kaW5nJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdHMucnVubmluZyA+IDApIHtcbiAgICAgICAgICAgIHN0YXRzRWwuY3JlYXRlRWwoJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgdGV4dDogYFJ1bm5pbmc6ICR7c3RhdHMucnVubmluZ31gLFxuICAgICAgICAgICAgICAgIGNsczogJ2NsYXVkZS1jb2RlLXN0YXQtcnVubmluZydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRzLmNvbXBsZXRlZCA+IDApIHtcbiAgICAgICAgICAgIHN0YXRzRWwuY3JlYXRlRWwoJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgdGV4dDogYENvbXBsZXRlZDogJHtzdGF0cy5jb21wbGV0ZWR9YCxcbiAgICAgICAgICAgICAgICBjbHM6ICdjbGF1ZGUtY29kZS1zdGF0LWNvbXBsZXRlZCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRzLmZhaWxlZCA+IDApIHtcbiAgICAgICAgICAgIHN0YXRzRWwuY3JlYXRlRWwoJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgdGV4dDogYEZhaWxlZDogJHtzdGF0cy5mYWlsZWR9YCxcbiAgICAgICAgICAgICAgICBjbHM6ICdjbGF1ZGUtY29kZS1zdGF0LWZhaWxlZCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIGEgc2luZ2xlIHRvb2wgY2FsbFxuICAgICAqL1xuICAgIHByaXZhdGUgcmVuZGVyVG9vbENhbGwoY2FsbDogVG9vbENhbGwsIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY2FsbEVsID0gY29udGFpbmVyLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICAgICAgICBjbHM6IGBjbGF1ZGUtY29kZS10b29sLWNhbGwgY2xhdWRlLWNvZGUtdG9vbC1jYWxsLSR7Y2FsbC5zdGF0dXN9YFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDcmVhdGUgaGVhZGVyIHNlY3Rpb24gKGFsd2F5cyB2aXNpYmxlKVxuICAgICAgICBjb25zdCBoZWFkZXIgPSBjYWxsRWwuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgICAgICAgIGNsczogJ2NsYXVkZS1jb2RlLXRvb2wtY2FsbC1oZWFkZXItc2VjdGlvbidcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU3RhdHVzIGljb25cbiAgICAgICAgY29uc3Qgc3RhdHVzSWNvbiA9IGhlYWRlci5jcmVhdGVFbCgnc3BhbicsIHtcbiAgICAgICAgICAgIGNsczogYGNsYXVkZS1jb2RlLXRvb2wtY2FsbC1zdGF0dXMtaWNvbiBjbGF1ZGUtY29kZS1zdGF0dXMtJHtjYWxsLnN0YXR1c31gXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRvb2wgbmFtZVxuICAgICAgICBoZWFkZXIuY3JlYXRlRWwoJ3NwYW4nLCB7XG4gICAgICAgICAgICB0ZXh0OiBjYWxsLnRvb2xOYW1lLFxuICAgICAgICAgICAgY2xzOiAnY2xhdWRlLWNvZGUtdG9vbC1jYWxsLW5hbWUnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIER1cmF0aW9uIChmb3IgYWN0aXZlIG9yIGNvbXBsZXRlZCBjYWxscylcbiAgICAgICAgaWYgKGNhbGwuc3RhdHVzICE9PSAncGVuZGluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy50cmFja2VyLmdldER1cmF0aW9uKGNhbGwuaWQpO1xuICAgICAgICAgICAgaWYgKGR1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXIuY3JlYXRlRWwoJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuZm9ybWF0RHVyYXRpb24oZHVyYXRpb24pLFxuICAgICAgICAgICAgICAgICAgICBjbHM6ICdjbGF1ZGUtY29kZS10b29sLWNhbGwtZHVyYXRpb24nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgZGV0YWlscyBzZWN0aW9uIChjb2xsYXBzaWJsZSlcbiAgICAgICAgY29uc3QgZGV0YWlscyA9IGNhbGxFbC5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgICAgICAgY2xzOiAnY2xhdWRlLWNvZGUtdG9vbC1jYWxsLWRldGFpbHMnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFyZ3VtZW50c1xuICAgICAgICBpZiAoY2FsbC5hcmd1bWVudHMgJiYgT2JqZWN0LmtleXMoY2FsbC5hcmd1bWVudHMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3NTZWN0aW9uID0gZGV0YWlscy5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGNsczogJ2NsYXVkZS1jb2RlLXRvb2wtY2FsbC1hcmd1bWVudHMnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFyZ3NTZWN0aW9uLmNyZWF0ZUVsKCdoNCcsIHsgdGV4dDogJ0FyZ3VtZW50cycgfSk7XG4gICAgICAgICAgICBhcmdzU2VjdGlvbi5jcmVhdGVFbCgncHJlJywge1xuICAgICAgICAgICAgICAgIHRleHQ6IEpTT04uc3RyaW5naWZ5KGNhbGwuYXJndW1lbnRzLCBudWxsLCAyKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXN1bHQgKGZvciBjb21wbGV0ZWQgY2FsbHMpXG4gICAgICAgIGlmIChjYWxsLnN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcgJiYgY2FsbC5yZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0U2VjdGlvbiA9IGRldGFpbHMuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBjbHM6ICdjbGF1ZGUtY29kZS10b29sLWNhbGwtcmVzdWx0J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHRTZWN0aW9uLmNyZWF0ZUVsKCdoNCcsIHsgdGV4dDogJ1Jlc3VsdCcgfSk7XG4gICAgICAgICAgICByZXN1bHRTZWN0aW9uLmNyZWF0ZUVsKCdwcmUnLCB7XG4gICAgICAgICAgICAgICAgdGV4dDogSlNPTi5zdHJpbmdpZnkoY2FsbC5yZXN1bHQsIG51bGwsIDIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVycm9yIChmb3IgZmFpbGVkIGNhbGxzKVxuICAgICAgICBpZiAoY2FsbC5zdGF0dXMgPT09ICdmYWlsZWQnICYmIGNhbGwuZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yU2VjdGlvbiA9IGRldGFpbHMuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICBjbHM6ICdjbGF1ZGUtY29kZS10b29sLWNhbGwtZXJyb3InXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVycm9yU2VjdGlvbi5jcmVhdGVFbCgnaDQnLCB7IHRleHQ6ICdFcnJvcicgfSk7XG4gICAgICAgICAgICBlcnJvclNlY3Rpb24uY3JlYXRlRWwoJ3ByZScsIHsgdGV4dDogY2FsbC5lcnJvciB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1ha2UgZGV0YWlscyBjb2xsYXBzaWJsZVxuICAgICAgICBoZWFkZXIuYWRkQ2xhc3MoJ2NsaWNrYWJsZScpO1xuICAgICAgICBoZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoX2V2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICBkZXRhaWxzLnRvZ2dsZUNsYXNzKCdjb2xsYXBzZWQnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU3RvcmUgZWxlbWVudCByZWZlcmVuY2VcbiAgICAgICAgdGhpcy50b29sQ2FsbEVsZW1lbnRzLnNldChjYWxsLmlkLCBjYWxsRWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0b29sIGNhbGwgZGlzcGxheSB3aGVuIHN0YXRlIGNoYW5nZXNcbiAgICAgKi9cbiAgICBwcml2YXRlIHVwZGF0ZVRvb2xDYWxsRGlzcGxheShjYWxsOiBUb29sQ2FsbCk6IHZvaWQge1xuICAgICAgICBjb25zdCBleGlzdGluZ0VsID0gdGhpcy50b29sQ2FsbEVsZW1lbnRzLmdldChjYWxsLmlkKTtcblxuICAgICAgICBpZiAoIWV4aXN0aW5nRWwpIHtcbiAgICAgICAgICAgIC8vIE5ldyBjYWxsLCByZW5kZXIgaXRcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5jbGF1ZGUtY29kZS10b29sLWNhbGxzLWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVG9vbENhbGwoY2FsbCwgY29udGFpbmVyIGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIGV4aXN0aW5nRWwuY2xhc3NOYW1lID0gYGNsYXVkZS1jb2RlLXRvb2wtY2FsbCBjbGF1ZGUtY29kZS10b29sLWNhbGwtJHtjYWxsLnN0YXR1c31gO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0dXMgaWNvblxuICAgICAgICBjb25zdCBzdGF0dXNJY29uID0gZXhpc3RpbmdFbC5xdWVyeVNlbGVjdG9yKCcuY2xhdWRlLWNvZGUtdG9vbC1jYWxsLXN0YXR1cy1pY29uJyk7XG4gICAgICAgIGlmIChzdGF0dXNJY29uKSB7XG4gICAgICAgICAgICBzdGF0dXNJY29uLmNsYXNzTmFtZSA9IGBjbGF1ZGUtY29kZS10b29sLWNhbGwtc3RhdHVzLWljb24gY2xhdWRlLWNvZGUtc3RhdHVzLSR7Y2FsbC5zdGF0dXN9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBkdXJhdGlvblxuICAgICAgICBjb25zdCBkdXJhdGlvbkVsID0gZXhpc3RpbmdFbC5xdWVyeVNlbGVjdG9yKCcuY2xhdWRlLWNvZGUtdG9vbC1jYWxsLWR1cmF0aW9uJyk7XG4gICAgICAgIGlmIChkdXJhdGlvbkVsICYmIGNhbGwuc3RhdHVzICE9PSAncGVuZGluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy50cmFja2VyLmdldER1cmF0aW9uKGNhbGwuaWQpO1xuICAgICAgICAgICAgaWYgKGR1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAoZHVyYXRpb25FbCBhcyBIVE1MRWxlbWVudCkudGV4dENvbnRlbnQgPSB0aGlzLmZvcm1hdER1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBkZXRhaWxzIHNlY3Rpb25cbiAgICAgICAgY29uc3QgZGV0YWlscyA9IGV4aXN0aW5nRWwucXVlcnlTZWxlY3RvcignLmNsYXVkZS1jb2RlLXRvb2wtY2FsbC1kZXRhaWxzJyk7XG4gICAgICAgIGlmIChkZXRhaWxzKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgb2xkIHJlc3VsdC9lcnJvciBzZWN0aW9uc1xuICAgICAgICAgICAgY29uc3Qgb2xkUmVzdWx0ID0gZGV0YWlscy5xdWVyeVNlbGVjdG9yKCcuY2xhdWRlLWNvZGUtdG9vbC1jYWxsLXJlc3VsdCcpO1xuICAgICAgICAgICAgY29uc3Qgb2xkRXJyb3IgPSBkZXRhaWxzLnF1ZXJ5U2VsZWN0b3IoJy5jbGF1ZGUtY29kZS10b29sLWNhbGwtZXJyb3InKTtcbiAgICAgICAgICAgIGlmIChvbGRSZXN1bHQpIG9sZFJlc3VsdC5yZW1vdmUoKTtcbiAgICAgICAgICAgIGlmIChvbGRFcnJvcikgb2xkRXJyb3IucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBuZXcgcmVzdWx0L2Vycm9yIGlmIGFwcGxpY2FibGVcbiAgICAgICAgICAgIGlmIChjYWxsLnN0YXR1cyA9PT0gJ2NvbXBsZXRlZCcgJiYgY2FsbC5yZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdFNlY3Rpb24gPSBkZXRhaWxzLmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNsczogJ2NsYXVkZS1jb2RlLXRvb2wtY2FsbC1yZXN1bHQnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0U2VjdGlvbi5jcmVhdGVFbCgnaDQnLCB7IHRleHQ6ICdSZXN1bHQnIH0pO1xuICAgICAgICAgICAgICAgIHJlc3VsdFNlY3Rpb24uY3JlYXRlRWwoJ3ByZScsIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogSlNPTi5zdHJpbmdpZnkoY2FsbC5yZXN1bHQsIG51bGwsIDIpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjYWxsLnN0YXR1cyA9PT0gJ2ZhaWxlZCcgJiYgY2FsbC5lcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yU2VjdGlvbiA9IGRldGFpbHMuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICAgICAgY2xzOiAnY2xhdWRlLWNvZGUtdG9vbC1jYWxsLWVycm9yJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGVycm9yU2VjdGlvbi5jcmVhdGVFbCgnaDQnLCB7IHRleHQ6ICdFcnJvcicgfSk7XG4gICAgICAgICAgICAgICAgZXJyb3JTZWN0aW9uLmNyZWF0ZUVsKCdwcmUnLCB7IHRleHQ6IGNhbGwuZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgZHVyYXRpb24gaW4gaHVtYW4tcmVhZGFibGUgZm9ybWF0XG4gICAgICovXG4gICAgcHJpdmF0ZSBmb3JtYXREdXJhdGlvbihtczogbnVtYmVyKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKG1zIDwgMTAwMCkge1xuICAgICAgICAgICAgcmV0dXJuIGAke21zfW1zYDtcbiAgICAgICAgfSBlbHNlIGlmIChtcyA8IDYwMDAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7KG1zIC8gMTAwMCkudG9GaXhlZCgxKX1zYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKG1zIC8gNjAwMDApO1xuICAgICAgICAgICAgY29uc3Qgc2Vjb25kcyA9IE1hdGguZmxvb3IoKG1zICUgNjAwMDApIC8gMTAwMCk7XG4gICAgICAgICAgICByZXR1cm4gYCR7bWludXRlc31tICR7c2Vjb25kc31zYDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIGNvbXBsZXRlZCBjYWxscyBmcm9tIGRpc3BsYXlcbiAgICAgKi9cbiAgICBjbGVhckNvbXBsZXRlZCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcignLmNsYXVkZS1jb2RlLXRvb2wtY2FsbHMtY29udGFpbmVyJyk7XG4gICAgICAgIGlmICghY29udGFpbmVyKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgY29tcGxldGVkQ2FsbHMgPSB0aGlzLnRyYWNrZXIuZ2V0QWxsQ2FsbHMoKS5maWx0ZXIoXG4gICAgICAgICAgICBjYWxsID0+IGNhbGwuc3RhdHVzID09PSAnY29tcGxldGVkJyB8fCBjYWxsLnN0YXR1cyA9PT0gJ2ZhaWxlZCdcbiAgICAgICAgKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGNhbGwgb2YgY29tcGxldGVkQ2FsbHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsID0gdGhpcy50b29sQ2FsbEVsZW1lbnRzLmdldChjYWxsLmlkKTtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgIGVsLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMudG9vbENhbGxFbGVtZW50cy5kZWxldGUoY2FsbC5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyYWNrZXIuY2xlYXJDb21wbGV0ZWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgY2FsbHMgZnJvbSBkaXNwbGF5XG4gICAgICovXG4gICAgY2xlYXJBbGwoKTogdm9pZCB7XG4gICAgICAgIHRoaXMudG9vbENhbGxFbGVtZW50cy5jbGVhcigpO1xuICAgICAgICB0aGlzLnRyYWNrZXIuY2xlYXJBbGwoKTtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG59XG4iLCAiLyoqXG4gKiBTdHJlYW1pbmcgUmVuZGVyZXJcbiAqIEhhbmRsZXMgcmVhbC10aW1lIHJlbmRlcmluZyBvZiBBSSByZXNwb25zZSBzdHJlYW1zXG4gKi9cblxuaW1wb3J0IHsgTWFya2Rvd25SZW5kZXJlciBhcyBPYnNpZGlhbk1hcmtkb3duUmVuZGVyZXIgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBDbGF1ZGVDb2RlVmlldyB9IGZyb20gJy4vdmlldyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RyZWFtQ2h1bmsge1xuICAgIGNvbnRlbnQ6IHN0cmluZztcbiAgICBpc0NvbXBsZXRlOiBib29sZWFuO1xuICAgIG1ldGFkYXRhPzoge1xuICAgICAgICBtb2RlbD86IHN0cmluZztcbiAgICAgICAgZmluaXNoUmVhc29uPzogc3RyaW5nO1xuICAgICAgICB1c2FnZT86IHtcbiAgICAgICAgICAgIHByb21wdFRva2VuczogbnVtYmVyO1xuICAgICAgICAgICAgY29tcGxldGlvblRva2VuczogbnVtYmVyO1xuICAgICAgICAgICAgdG90YWxUb2tlbnM6IG51bWJlcjtcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0cmVhbU1lc3NhZ2Uge1xuICAgIHR5cGU6ICdhaV9zdHJlYW0nO1xuICAgIGNvbnZlcnNhdGlvbklkOiBzdHJpbmc7XG4gICAgY2h1bms6IFN0cmVhbUNodW5rO1xufVxuXG4vKipcbiAqIFN0cmVhbWluZyBSZW5kZXJlclxuICogTWFuYWdlcyByZWFsLXRpbWUgZGlzcGxheSBvZiBBSSByZXNwb25zZXNcbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmVhbWluZ1JlbmRlcmVyIHtcbiAgICBwcml2YXRlIHZpZXc6IENsYXVkZUNvZGVWaWV3O1xuICAgIHByaXZhdGUgY29udGFpbmVyOiBIVE1MRWxlbWVudDtcbiAgICBwcml2YXRlIGN1cnJlbnRTdHJlYW1FbGVtZW50OiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsO1xuICAgIHByaXZhdGUgYWNjdW11bGF0ZWRDb250ZW50OiBzdHJpbmcgPSAnJztcbiAgICBwcml2YXRlIGlzU3RyZWFtaW5nOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBjb25zdHJ1Y3Rvcih2aWV3OiBDbGF1ZGVDb2RlVmlldywgY29udGFpbmVyOiBIVE1MRWxlbWVudCkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFydCBhIG5ldyBzdHJlYW1cbiAgICAgKi9cbiAgICBzdGFydFN0cmVhbSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5pc1N0cmVhbWluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuYWNjdW11bGF0ZWRDb250ZW50ID0gJyc7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHN0cmVhbSBlbGVtZW50XG4gICAgICAgIHRoaXMuY3VycmVudFN0cmVhbUVsZW1lbnQgPSB0aGlzLmNvbnRhaW5lci5jcmVhdGVFbCgnZGl2Jywge1xuICAgICAgICAgICAgY2xzOiAnY2xhdWRlLWNvZGUtc3RyZWFtaW5nLXJlc3BvbnNlJ1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDcmVhdGUgaGVhZGVyXG4gICAgICAgIGNvbnN0IGhlYWRlciA9IHRoaXMuY3VycmVudFN0cmVhbUVsZW1lbnQuY3JlYXRlRWwoJ2RpdicsIHtcbiAgICAgICAgICAgIGNsczogJ2NsYXVkZS1jb2RlLXN0cmVhbS1oZWFkZXInXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGhlYWRlci5jcmVhdGVFbCgnc3BhbicsIHtcbiAgICAgICAgICAgIHRleHQ6ICdBSSBSZXNwb25zZScsXG4gICAgICAgICAgICBjbHM6ICdjbGF1ZGUtY29kZS1zdHJlYW0tdGl0bGUnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHN0YXR1c0luZGljYXRvciA9IGhlYWRlci5jcmVhdGVFbCgnc3BhbicsIHtcbiAgICAgICAgICAgIHRleHQ6ICdTdHJlYW1pbmcuLi4nLFxuICAgICAgICAgICAgY2xzOiAnY2xhdWRlLWNvZGUtc3RyZWFtLXN0YXR1cyBzdHJlYW1pbmcnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENyZWF0ZSBjb250ZW50IGFyZWFcbiAgICAgICAgY29uc3QgY29udGVudEFyZWEgPSB0aGlzLmN1cnJlbnRTdHJlYW1FbGVtZW50LmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICAgICAgICBjbHM6ICdjbGF1ZGUtY29kZS1zdHJlYW0tY29udGVudCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU3RvcmUgcmVmZXJlbmNlIGZvciB1cGRhdGVzXG4gICAgICAgICh0aGlzLmN1cnJlbnRTdHJlYW1FbGVtZW50IGFzIGFueSkuX3N0YXR1c0luZGljYXRvciA9IHN0YXR1c0luZGljYXRvcjtcbiAgICAgICAgKHRoaXMuY3VycmVudFN0cmVhbUVsZW1lbnQgYXMgYW55KS5fY29udGVudEFyZWEgPSBjb250ZW50QXJlYTtcblxuICAgICAgICAvLyBTY3JvbGwgdG8gYm90dG9tXG4gICAgICAgIHRoaXMuc2Nyb2xsVG9Cb3R0b20oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmQgYSBjaHVuayBvZiBjb250ZW50IHRvIHRoZSBzdHJlYW1cbiAgICAgKi9cbiAgICBhc3luYyBhcHBlbmRDaHVuayhjaHVuazogU3RyZWFtQ2h1bmspOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRTdHJlYW1FbGVtZW50IHx8ICF0aGlzLmlzU3RyZWFtaW5nKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ05vIGFjdGl2ZSBzdHJlYW0gdG8gYXBwZW5kIHRvJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBlbmQgY29udGVudFxuICAgICAgICBpZiAoY2h1bmsuY29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5hY2N1bXVsYXRlZENvbnRlbnQgKz0gY2h1bmsuY29udGVudDtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIGNvbnRlbnQgYXJlYSB3aXRoIHJlbmRlcmVkIG1hcmtkb3duXG4gICAgICAgICAgICBjb25zdCBjb250ZW50QXJlYSA9ICh0aGlzLmN1cnJlbnRTdHJlYW1FbGVtZW50IGFzIGFueSkuX2NvbnRlbnRBcmVhO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnRBcmVhKSB7XG4gICAgICAgICAgICAgICAgY29udGVudEFyZWEuZW1wdHkoKTtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0ZW1wb3JhcnkgY29udGFpbmVyIGZvciBtYXJrZG93biByZW5kZXJpbmdcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZG93bkNvbnRhaW5lciA9IGNvbnRlbnRBcmVhLmNyZWF0ZUVsKCdkaXYnKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBPYnNpZGlhbk1hcmtkb3duUmVuZGVyZXIucmVuZGVyTWFya2Rvd24oXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWNjdW11bGF0ZWRDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICBtYXJrZG93bkNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNjcm9sbCB0byBib3R0b21cbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9Cb3R0b20oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHN0cmVhbSBpcyBjb21wbGV0ZVxuICAgICAgICBpZiAoY2h1bmsuaXNDb21wbGV0ZSkge1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZVN0cmVhbShjaHVuay5tZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wbGV0ZSB0aGUgY3VycmVudCBzdHJlYW1cbiAgICAgKi9cbiAgICBjb21wbGV0ZVN0cmVhbShtZXRhZGF0YT86IFN0cmVhbUNodW5rWydtZXRhZGF0YSddKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50U3RyZWFtRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc1N0cmVhbWluZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0dXMgaW5kaWNhdG9yXG4gICAgICAgIGNvbnN0IHN0YXR1c0luZGljYXRvciA9ICh0aGlzLmN1cnJlbnRTdHJlYW1FbGVtZW50IGFzIGFueSkuX3N0YXR1c0luZGljYXRvcjtcbiAgICAgICAgaWYgKHN0YXR1c0luZGljYXRvcikge1xuICAgICAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gJ0NvbXBsZXRlJztcbiAgICAgICAgICAgIHN0YXR1c0luZGljYXRvci5yZW1vdmVDbGFzcygnc3RyZWFtaW5nJyk7XG4gICAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IuYWRkQ2xhc3MoJ2NvbXBsZXRlJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgbWV0YWRhdGEgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5hZGRNZXRhZGF0YShtZXRhZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0IHRvIHJlZ3VsYXIgcmVzcG9uc2UgZWxlbWVudFxuICAgICAgICB0aGlzLmN1cnJlbnRTdHJlYW1FbGVtZW50LnJlbW92ZUNsYXNzKCdjbGF1ZGUtY29kZS1zdHJlYW1pbmctcmVzcG9uc2UnKTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RyZWFtRWxlbWVudC5hZGRDbGFzcygnY2xhdWRlLWNvZGUtcmVzcG9uc2UnKTtcblxuICAgICAgICB0aGlzLmN1cnJlbnRTdHJlYW1FbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5hY2N1bXVsYXRlZENvbnRlbnQgPSAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgbWV0YWRhdGEgZGlzcGxheSAodG9rZW4gdXNhZ2UsIG1vZGVsLCBldGMuKVxuICAgICAqL1xuICAgIHByaXZhdGUgYWRkTWV0YWRhdGEobWV0YWRhdGE6IFN0cmVhbUNodW5rWydtZXRhZGF0YSddKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50U3RyZWFtRWxlbWVudCB8fCAhbWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhRWwgPSB0aGlzLmN1cnJlbnRTdHJlYW1FbGVtZW50LmNyZWF0ZUVsKCdkaXYnLCB7XG4gICAgICAgICAgICBjbHM6ICdjbGF1ZGUtY29kZS1zdHJlYW0tbWV0YWRhdGEnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE1vZGVsXG4gICAgICAgIGlmIChtZXRhZGF0YS5tb2RlbCkge1xuICAgICAgICAgICAgbWV0YWRhdGFFbC5jcmVhdGVFbCgnc3BhbicsIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBgTW9kZWw6ICR7bWV0YWRhdGEubW9kZWx9YCxcbiAgICAgICAgICAgICAgICBjbHM6ICdjbGF1ZGUtY29kZS1tZXRhZGF0YS1pdGVtJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUb2tlbiB1c2FnZVxuICAgICAgICBpZiAobWV0YWRhdGEudXNhZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2Vuc1RleHQgPSBgVG9rZW5zOiAke21ldGFkYXRhLnVzYWdlLnByb21wdFRva2Vuc30gKyAke21ldGFkYXRhLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnN9ID0gJHttZXRhZGF0YS51c2FnZS50b3RhbFRva2Vuc31gO1xuICAgICAgICAgICAgbWV0YWRhdGFFbC5jcmVhdGVFbCgnc3BhbicsIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiB0b2tlbnNUZXh0LFxuICAgICAgICAgICAgICAgIGNsczogJ2NsYXVkZS1jb2RlLW1ldGFkYXRhLWl0ZW0nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmlzaCByZWFzb25cbiAgICAgICAgaWYgKG1ldGFkYXRhLmZpbmlzaFJlYXNvbikge1xuICAgICAgICAgICAgbWV0YWRhdGFFbC5jcmVhdGVFbCgnc3BhbicsIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBgRmluaXNoZWQ6ICR7bWV0YWRhdGEuZmluaXNoUmVhc29ufWAsXG4gICAgICAgICAgICAgICAgY2xzOiAnY2xhdWRlLWNvZGUtbWV0YWRhdGEtaXRlbSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FuY2VsIHRoZSBjdXJyZW50IHN0cmVhbVxuICAgICAqL1xuICAgIGNhbmNlbFN0cmVhbSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRTdHJlYW1FbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzU3RyZWFtaW5nID0gZmFsc2U7XG5cbiAgICAgICAgY29uc3Qgc3RhdHVzSW5kaWNhdG9yID0gKHRoaXMuY3VycmVudFN0cmVhbUVsZW1lbnQgYXMgYW55KS5fc3RhdHVzSW5kaWNhdG9yO1xuICAgICAgICBpZiAoc3RhdHVzSW5kaWNhdG9yKSB7XG4gICAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSAnQ2FuY2VsbGVkJztcbiAgICAgICAgICAgIHN0YXR1c0luZGljYXRvci5yZW1vdmVDbGFzcygnc3RyZWFtaW5nJyk7XG4gICAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IuYWRkQ2xhc3MoJ2NhbmNlbGxlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdXJyZW50U3RyZWFtRWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuYWNjdW11bGF0ZWRDb250ZW50ID0gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgY3VycmVudGx5IHN0cmVhbWluZ1xuICAgICAqL1xuICAgIGlzQWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1N0cmVhbWluZyAmJiB0aGlzLmN1cnJlbnRTdHJlYW1FbGVtZW50ICE9PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBzdHJlYW0gZWxlbWVudFxuICAgICAqL1xuICAgIGdldEN1cnJlbnRFbGVtZW50KCk6IEhUTUxFbGVtZW50IHwgbnVsbCB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTdHJlYW1FbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjcm9sbCB0aGUgY29udGFpbmVyIHRvIHRoZSBib3R0b21cbiAgICAgKi9cbiAgICBwcml2YXRlIHNjcm9sbFRvQm90dG9tKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnNjcm9sbFRvcCA9IHRoaXMuY29udGFpbmVyLnNjcm9sbEhlaWdodDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBpbmNvbWluZyBzdHJlYW0gbWVzc2FnZVxuICAgICAqL1xuICAgIGFzeW5jIGhhbmRsZVN0cmVhbU1lc3NhZ2UobWVzc2FnZTogU3RyZWFtTWVzc2FnZSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgLy8gU3RhcnQgbmV3IHN0cmVhbSBpZiBub3QgYWN0aXZlXG4gICAgICAgICAgICB0aGlzLnN0YXJ0U3RyZWFtKCk7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCB0aGlzLmFwcGVuZENodW5rKG1lc3NhZ2UuY2h1bmspO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBzdHJlYW1zXG4gICAgICovXG4gICAgY2xlYXIoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaXNTdHJlYW1pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RyZWFtRWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuYWNjdW11bGF0ZWRDb250ZW50ID0gJyc7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmVtcHR5KCk7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IEFwcCwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZywgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IENsYXVkZUNvZGVQbHVnaW4gZnJvbSAnLi4vbWFpbic7XG5pbXBvcnQgeyBleGVjU3luYywgZXhlYyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0ICogYXMgb3MgZnJvbSAnb3MnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IHQsIHNldExvY2FsZSwgZ2V0TG9jYWxlLCBnZXRBdmFpbGFibGVMb2NhbGVzLCBMb2NhbGUgfSBmcm9tICcuLi9pMThuJztcblxuZXhwb3J0IGludGVyZmFjZSBDbGF1ZGVDb2RlU2V0dGluZ3Mge1xuICAgIGNsYXVkZUNvZGVQYXRoOiBzdHJpbmc7XG4gICAgYXV0b0RldGVjdFBhdGg6IGJvb2xlYW47XG4gICAgbW9kZWxBbGlhczogJ3Nvbm5ldCcgfCAnb3B1cycgfCAnaGFpa3UnIHwgJyc7XG4gICAgY3VzdG9tU3lzdGVtUHJvbXB0OiBzdHJpbmc7XG4gICAgcHJlc2VydmVDdXJzb3JQb3NpdGlvbjogYm9vbGVhbjtcbiAgICB0aW1lb3V0U2Vjb25kczogbnVtYmVyO1xuICAgIGF1dG9BY2NlcHRDaGFuZ2VzOiBib29sZWFuO1xuICAgIGFsbG93VmF1bHRBY2Nlc3M6IGJvb2xlYW47XG4gICAgZW5hYmxlUGVybWlzc2lvbmxlc3NNb2RlOiBib29sZWFuO1xuICAgIC8vIEN1c3RvbSBBUEkgY29uZmlndXJhdGlvbiAoZm9yIGFsdGVybmF0aXZlIGVuZHBvaW50cy9wcm94aWVzKVxuICAgIGFudGhyb3BpY0Jhc2VVcmw6IHN0cmluZztcbiAgICBhbnRocm9waWNBdXRoVG9rZW46IHN0cmluZztcbiAgICBhbnRocm9waWNNb2RlbDogc3RyaW5nO1xuICAgIGFudGhyb3BpY1NtYWxsRmFzdE1vZGVsOiBzdHJpbmc7XG4gICAgLy8gVUkgc2V0dGluZ3NcbiAgICBsYW5ndWFnZTogTG9jYWxlO1xuICAgIC8vIFJlbW90ZSBXZWJTb2NrZXQgbW9kZSBzZXR0aW5nc1xuICAgIGVuYWJsZVJlbW90ZU1vZGU6IGJvb2xlYW47XG4gICAgcmVtb3RlU2VydmVyVXJsOiBzdHJpbmc7XG4gICAgcmVtb3RlQXV0aFRva2VuOiBzdHJpbmc7XG4gICAgcmVtb3RlQXV0b1JlY29ubmVjdDogYm9vbGVhbjtcbiAgICByZW1vdGVSZWNvbm5lY3RJbnRlcnZhbDogbnVtYmVyO1xuICAgIHJlbW90ZU1heFJlY29ubmVjdEF0dGVtcHRzOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1NFVFRJTkdTOiBDbGF1ZGVDb2RlU2V0dGluZ3MgPSB7XG4gICAgY2xhdWRlQ29kZVBhdGg6ICcnLFxuICAgIGF1dG9EZXRlY3RQYXRoOiB0cnVlLFxuICAgIG1vZGVsQWxpYXM6ICcnLFxuICAgIGN1c3RvbVN5c3RlbVByb21wdDogJycsXG4gICAgcHJlc2VydmVDdXJzb3JQb3NpdGlvbjogdHJ1ZSxcbiAgICB0aW1lb3V0U2Vjb25kczogMzAwLFxuICAgIGF1dG9BY2NlcHRDaGFuZ2VzOiBmYWxzZSxcbiAgICBhbGxvd1ZhdWx0QWNjZXNzOiB0cnVlLFxuICAgIGVuYWJsZVBlcm1pc3Npb25sZXNzTW9kZTogZmFsc2UsXG4gICAgLy8gQ3VzdG9tIEFQSSBjb25maWd1cmF0aW9uIChlbXB0eSA9IHVzZSBkZWZhdWx0KVxuICAgIGFudGhyb3BpY0Jhc2VVcmw6ICcnLFxuICAgIGFudGhyb3BpY0F1dGhUb2tlbjogJycsXG4gICAgYW50aHJvcGljTW9kZWw6ICcnLFxuICAgIGFudGhyb3BpY1NtYWxsRmFzdE1vZGVsOiAnJyxcbiAgICAvLyBVSSBzZXR0aW5nc1xuICAgIGxhbmd1YWdlOiAnZW4nLFxuICAgIC8vIFJlbW90ZSBXZWJTb2NrZXQgbW9kZSBzZXR0aW5nc1xuICAgIGVuYWJsZVJlbW90ZU1vZGU6IGZhbHNlLFxuICAgIHJlbW90ZVNlcnZlclVybDogJ3dzOi8vbG9jYWxob3N0OjgwODAnLFxuICAgIHJlbW90ZUF1dGhUb2tlbjogJycsXG4gICAgcmVtb3RlQXV0b1JlY29ubmVjdDogdHJ1ZSxcbiAgICByZW1vdGVSZWNvbm5lY3RJbnRlcnZhbDogMzAwMCxcbiAgICByZW1vdGVNYXhSZWNvbm5lY3RBdHRlbXB0czogMTBcbn07XG5cbmV4cG9ydCBjbGFzcyBDbGF1ZGVDb2RlU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuICAgIHBsdWdpbjogQ2xhdWRlQ29kZVBsdWdpbjtcblxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IENsYXVkZUNvZGVQbHVnaW4pIHtcbiAgICAgICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICB9XG5cbiAgICBkaXNwbGF5KCk6IHZvaWQge1xuICAgICAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cbiAgICAgICAgLy8gTGFuZ3VhZ2Ugc2V0dGluZyBhdCB0aGUgdG9wXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUodCgnc2V0dGluZ3MubGFuZ3VhZ2UnKSlcbiAgICAgICAgICAgIC5zZXREZXNjKHQoJ3NldHRpbmdzLmxhbmd1YWdlRGVzYycpKVxuICAgICAgICAgICAgLmFkZERyb3Bkb3duKGRyb3Bkb3duID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbGVzID0gZ2V0QXZhaWxhYmxlTG9jYWxlcygpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbG9jYWxlIG9mIGxvY2FsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJvcGRvd24uYWRkT3B0aW9uKGxvY2FsZS5jb2RlLCBsb2NhbGUubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRyb3Bkb3duLnNldFZhbHVlKGdldExvY2FsZSgpKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5sYW5ndWFnZSA9IHZhbHVlIGFzIExvY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldExvY2FsZSh2YWx1ZSBhcyBMb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWZyZXNoIHNldHRpbmdzIGRpc3BsYXkgd2l0aCBuZXcgbGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aWZ5IHVzZXIgdG8gcmVsb2FkIGZvciBmdWxsIGVmZmVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZSh0KCdtaXNjLmxhbmd1YWdlQ2hhbmdlZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBBdXRvLWRldGVjdCBDbGF1ZGUgQ29kZSBwYXRoXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUodCgnc2V0dGluZ3MuYXV0b0RldGVjdFBhdGgnKSlcbiAgICAgICAgICAgIC5zZXREZXNjKHQoJ3NldHRpbmdzLmF1dG9EZXRlY3RQYXRoRGVzYycpKVxuICAgICAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmF1dG9EZXRlY3RQYXRoKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuYXV0b0RldGVjdFBhdGggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXRlY3RlZFBhdGggPSB0aGlzLmRldGVjdENsYXVkZUNvZGVQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGV0ZWN0ZWRQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuY2xhdWRlQ29kZVBhdGggPSBkZXRlY3RlZFBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheSgpOyAvLyBSZWZyZXNoIHRvIHNob3cgZGV0ZWN0ZWQgcGF0aFxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAvLyBDbGF1ZGUgQ29kZSBleGVjdXRhYmxlIHBhdGhcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSh0KCdzZXR0aW5ncy5leGVjdXRhYmxlUGF0aCcpKVxuICAgICAgICAgICAgLnNldERlc2ModCgnc2V0dGluZ3MuZXhlY3V0YWJsZVBhdGhEZXNjJykpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJy91c3IvbG9jYWwvYmluL2NsYXVkZScpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmNsYXVkZUNvZGVQYXRoKVxuICAgICAgICAgICAgICAgIC5zZXREaXNhYmxlZCh0aGlzLnBsdWdpbi5zZXR0aW5ncy5hdXRvRGV0ZWN0UGF0aClcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmNsYXVkZUNvZGVQYXRoID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAvLyBUZXN0IENsYXVkZSBDb2RlIGJ1dHRvblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKHQoJ3NldHRpbmdzLnRlc3RJbnN0YWxsYXRpb24nKSlcbiAgICAgICAgICAgIC5zZXREZXNjKHQoJ3NldHRpbmdzLnRlc3RJbnN0YWxsYXRpb25EZXNjJykpXG4gICAgICAgICAgICAuYWRkQnV0dG9uKGJ1dHRvbiA9PiBidXR0b25cbiAgICAgICAgICAgICAgICAuc2V0QnV0dG9uVGV4dCh0KCdzZXR0aW5ncy50ZXN0QnV0dG9uJykpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2b2lkIHRoaXMudGVzdENsYXVkZUNvZGUoKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b24uc2V0QnV0dG9uVGV4dCgnXHUyNzEzICcgKyB0KCdzZXR0aW5ncy50ZXN0V29ya2luZycpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgYnV0dG9uLnNldEJ1dHRvblRleHQodCgnc2V0dGluZ3MudGVzdEJ1dHRvbicpKTsgfSwgMjAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KCdcdTI3MTcgJyArIHQoJ3NldHRpbmdzLnRlc3RGYWlsZWQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IGJ1dHRvbi5zZXRCdXR0b25UZXh0KHQoJ3NldHRpbmdzLnRlc3RCdXR0b24nKSk7IH0sIDIwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYCR7dCgnbWlzYy50ZXN0RmFpbGVkJyl9OiAke3Jlc3VsdC5lcnJvcn1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIC8vIEN1c3RvbSBzeXN0ZW0gcHJvbXB0XG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUodCgnc2V0dGluZ3MuY3VzdG9tUHJvbXB0JykpXG4gICAgICAgICAgICAuc2V0RGVzYyh0KCdzZXR0aW5ncy5jdXN0b21Qcm9tcHREZXNjJykpXG4gICAgICAgICAgICAuYWRkVGV4dEFyZWEodGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgdGV4dC5zZXRQbGFjZWhvbGRlcih0KCdzZXR0aW5ncy5jdXN0b21Qcm9tcHRQbGFjZWhvbGRlcicpKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuY3VzdG9tU3lzdGVtUHJvbXB0KVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5jdXN0b21TeXN0ZW1Qcm9tcHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwucm93cyA9IDQ7XG4gICAgICAgICAgICAgICAgdGV4dC5pbnB1dEVsLmNvbHMgPSA1MDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFByZXNlcnZlIGN1cnNvciBwb3NpdGlvblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKHQoJ3NldHRpbmdzLnByZXNlcnZlQ3Vyc29yJykpXG4gICAgICAgICAgICAuc2V0RGVzYyh0KCdzZXR0aW5ncy5wcmVzZXJ2ZUN1cnNvckRlc2MnKSlcbiAgICAgICAgICAgIC5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcmVzZXJ2ZUN1cnNvclBvc2l0aW9uKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucHJlc2VydmVDdXJzb3JQb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgLy8gQXV0by1hY2NlcHQgY2hhbmdlc1xuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKHQoJ3NldHRpbmdzLmF1dG9BY2NlcHRDaGFuZ2VzJykpXG4gICAgICAgICAgICAuc2V0RGVzYyh0KCdzZXR0aW5ncy5hdXRvQWNjZXB0Q2hhbmdlc0Rlc2MnKSlcbiAgICAgICAgICAgIC5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5hdXRvQWNjZXB0Q2hhbmdlcylcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmF1dG9BY2NlcHRDaGFuZ2VzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAvLyBNb2RlbCBBbGlhc1xuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKHQoJ3NldHRpbmdzLm1vZGVsJykpXG4gICAgICAgICAgICAuc2V0RGVzYyh0KCdzZXR0aW5ncy5tb2RlbERlc2MnKSlcbiAgICAgICAgICAgIC5hZGREcm9wZG93bihkcm9wZG93biA9PiBkcm9wZG93blxuICAgICAgICAgICAgICAgIC5hZGRPcHRpb24oJycsIHQoJ3NldHRpbmdzLm1vZGVsRGVmYXVsdCcpKVxuICAgICAgICAgICAgICAgIC5hZGRPcHRpb24oJ3Nvbm5ldCcsIHQoJ3NldHRpbmdzLm1vZGVsU29ubmV0JykpXG4gICAgICAgICAgICAgICAgLmFkZE9wdGlvbignb3B1cycsIHQoJ3NldHRpbmdzLm1vZGVsT3B1cycpKVxuICAgICAgICAgICAgICAgIC5hZGRPcHRpb24oJ2hhaWt1JywgdCgnc2V0dGluZ3MubW9kZWxIYWlrdScpKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5tb2RlbEFsaWFzKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MubW9kZWxBbGlhcyA9IHZhbHVlIGFzICdzb25uZXQnIHwgJ29wdXMnIHwgJ2hhaWt1JyB8ICcnO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgLy8gQWxsb3cgVmF1bHQgQWNjZXNzXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUodCgnc2V0dGluZ3MudmF1bHRBY2Nlc3MnKSlcbiAgICAgICAgICAgIC5zZXREZXNjKHQoJ3NldHRpbmdzLnZhdWx0QWNjZXNzRGVzYycpKVxuICAgICAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmFsbG93VmF1bHRBY2Nlc3MpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5hbGxvd1ZhdWx0QWNjZXNzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAvLyBFbmFibGUgUGVybWlzc2lvbmxlc3MgTW9kZVxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKHQoJ3NldHRpbmdzLnBlcm1pc3Npb25sZXNzTW9kZScpKVxuICAgICAgICAgICAgLnNldERlc2ModCgnc2V0dGluZ3MucGVybWlzc2lvbmxlc3NNb2RlRGVzYycpKVxuICAgICAgICAgICAgLmFkZFRvZ2dsZSh0b2dnbGUgPT4gdG9nZ2xlXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmVuYWJsZVBlcm1pc3Npb25sZXNzTW9kZSlcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmVuYWJsZVBlcm1pc3Npb25sZXNzTW9kZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgLy8gVGltZW91dFxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKHQoJ3NldHRpbmdzLnRpbWVvdXQnKSlcbiAgICAgICAgICAgIC5zZXREZXNjKHQoJ3NldHRpbmdzLnRpbWVvdXREZXNjJykpXG4gICAgICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJzMwMCcpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKFN0cmluZyh0aGlzLnBsdWdpbi5zZXR0aW5ncy50aW1lb3V0U2Vjb25kcykpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBudW0gPSBwYXJzZUludCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4obnVtKSAmJiBudW0gPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MudGltZW91dFNlY29uZHMgPSBudW07XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAvLyBDdXN0b20gQVBJIENvbmZpZ3VyYXRpb24gU2VjdGlvblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKHQoJ3NldHRpbmdzLmN1c3RvbUFwaUNvbmZpZycpKVxuICAgICAgICAgICAgLnNldERlc2ModCgnc2V0dGluZ3MuY3VzdG9tQXBpQ29uZmlnRGVzYycpKVxuICAgICAgICAgICAgLnNldEhlYWRpbmcoKTtcblxuICAgICAgICAvLyBBbnRocm9waWMgQmFzZSBVUkxcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSh0KCdzZXR0aW5ncy5hcGlCYXNlVXJsJykpXG4gICAgICAgICAgICAuc2V0RGVzYyh0KCdzZXR0aW5ncy5hcGlCYXNlVXJsRGVzYycpKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdodHRwczovL2FwaS5hbnRocm9waWMuY29tJylcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuYW50aHJvcGljQmFzZVVybClcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmFudGhyb3BpY0Jhc2VVcmwgPSB2YWx1ZS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAvLyBBbnRocm9waWMgQXV0aCBUb2tlblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKHQoJ3NldHRpbmdzLmFwaUF1dGhUb2tlbicpKVxuICAgICAgICAgICAgLnNldERlc2ModCgnc2V0dGluZ3MuYXBpQXV0aFRva2VuRGVzYycpKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB7XG4gICAgICAgICAgICAgICAgdGV4dC5zZXRQbGFjZWhvbGRlcih0KCdzZXR0aW5ncy5hcGlBdXRoVG9rZW5QbGFjZWhvbGRlcicpKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuYW50aHJvcGljQXV0aFRva2VuKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5hbnRocm9waWNBdXRoVG9rZW4gPSB2YWx1ZS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGV4dC5pbnB1dEVsLnR5cGUgPSAncGFzc3dvcmQnO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQW50aHJvcGljIE1vZGVsXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUodCgnc2V0dGluZ3MuY3VzdG9tTW9kZWwnKSlcbiAgICAgICAgICAgIC5zZXREZXNjKHQoJ3NldHRpbmdzLmN1c3RvbU1vZGVsRGVzYycpKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdjbGF1ZGUtc29ubmV0LTQtMjAyNTA1MTQnKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5hbnRocm9waWNNb2RlbClcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmFudGhyb3BpY01vZGVsID0gdmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgLy8gQW50aHJvcGljIFNtYWxsL0Zhc3QgTW9kZWxcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZSh0KCdzZXR0aW5ncy5jdXN0b21TbWFsbE1vZGVsJykpXG4gICAgICAgICAgICAuc2V0RGVzYyh0KCdzZXR0aW5ncy5jdXN0b21TbWFsbE1vZGVsRGVzYycpKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdjbGF1ZGUtaGFpa3UtMy01LTIwMjQxMDIyJylcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuYW50aHJvcGljU21hbGxGYXN0TW9kZWwpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5hbnRocm9waWNTbWFsbEZhc3RNb2RlbCA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIC8vIFJlbW90ZSBXZWJTb2NrZXQgTW9kZSBTZWN0aW9uXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1JlbW90ZSBNb2RlIChXZWJTb2NrZXQpJylcbiAgICAgICAgICAgIC5zZXREZXNjKCdDb25uZWN0IHRvIHJlbW90ZSBDbGF1ZGUgcmVsYXkgc2VydmVyIGluc3RlYWQgb2YgcnVubmluZyBDbGF1ZGUgbG9jYWxseScpXG4gICAgICAgICAgICAuc2V0SGVhZGluZygpO1xuXG4gICAgICAgIC8vIEVuYWJsZSBSZW1vdGUgTW9kZVxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdFbmFibGUgcmVtb3RlIG1vZGUnKVxuICAgICAgICAgICAgLnNldERlc2MoJ1VzZSBXZWJTb2NrZXQgY29ubmVjdGlvbiB0byByZW1vdGUgQ2xhdWRlIHNlcnZlciBpbnN0ZWFkIG9mIGxvY2FsIENsYXVkZSBDb2RlJylcbiAgICAgICAgICAgIC5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5lbmFibGVSZW1vdGVNb2RlKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZW5hYmxlUmVtb3RlTW9kZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90aWZ5IHVzZXIgdG8gcmVsb2FkXG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoJ1JlbW90ZSBtb2RlICcgKyAodmFsdWUgPyAnZW5hYmxlZCcgOiAnZGlzYWJsZWQnKSArICcuIFJlbG9hZCBPYnNpZGlhbiB0byBhcHBseSBjaGFuZ2VzLicpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAvLyBTZXJ2ZXIgVVJMXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ1NlcnZlciBVUkwnKVxuICAgICAgICAgICAgLnNldERlc2MoJ1dlYlNvY2tldCBzZXJ2ZXIgVVJMIChlLmcuLCB3czovL2xvY2FsaG9zdDo4MDgwIG9yIHdzczovL3lvdXItc2VydmVyLmNvbSknKVxuICAgICAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCd3czovL2xvY2FsaG9zdDo4MDgwJylcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucmVtb3RlU2VydmVyVXJsKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucmVtb3RlU2VydmVyVXJsID0gdmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgLy8gQXV0aCBUb2tlbiAob3B0aW9uYWwpXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ0F1dGggdG9rZW4gKG9wdGlvbmFsKScpXG4gICAgICAgICAgICAuc2V0RGVzYygnT3B0aW9uYWwgYXV0aGVudGljYXRpb24gdG9rZW4gZm9yIHNlcnZlciBjb25uZWN0aW9uJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4ge1xuICAgICAgICAgICAgICAgIHRleHQuc2V0UGxhY2Vob2xkZXIoJ3lvdXItYXV0aC10b2tlbicpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZW1vdGVBdXRoVG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnJlbW90ZUF1dGhUb2tlbiA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0ZXh0LmlucHV0RWwudHlwZSA9ICdwYXNzd29yZCc7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBBdXRvLXJlY29ubmVjdFxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdBdXRvLXJlY29ubmVjdCcpXG4gICAgICAgICAgICAuc2V0RGVzYygnQXV0b21hdGljYWxseSByZWNvbm5lY3QgdG8gc2VydmVyIGlmIGNvbm5lY3Rpb24gaXMgbG9zdCcpXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucmVtb3RlQXV0b1JlY29ubmVjdClcbiAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnJlbW90ZUF1dG9SZWNvbm5lY3QgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIC8vIFJlY29ubmVjdCBJbnRlcnZhbFxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdSZWNvbm5lY3QgaW50ZXJ2YWwgKG1zKScpXG4gICAgICAgICAgICAuc2V0RGVzYygnSW5pdGlhbCByZWNvbm5lY3Rpb24gZGVsYXkgaW4gbWlsbGlzZWNvbmRzICh3aWxsIGluY3JlYXNlIGV4cG9uZW50aWFsbHkpJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignMzAwMCcpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlKFN0cmluZyh0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZW1vdGVSZWNvbm5lY3RJbnRlcnZhbCkpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBudW0gPSBwYXJzZUludCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4obnVtKSAmJiBudW0gPj0gMTAwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucmVtb3RlUmVjb25uZWN0SW50ZXJ2YWwgPSBudW07XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAvLyBNYXggUmVjb25uZWN0IEF0dGVtcHRzXG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAgICAgLnNldE5hbWUoJ01heCByZWNvbm5lY3QgYXR0ZW1wdHMnKVxuICAgICAgICAgICAgLnNldERlc2MoJ01heGltdW0gbnVtYmVyIG9mIHJlY29ubmVjdGlvbiBhdHRlbXB0cyBiZWZvcmUgZ2l2aW5nIHVwJylcbiAgICAgICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignMTAnKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZShTdHJpbmcodGhpcy5wbHVnaW4uc2V0dGluZ3MucmVtb3RlTWF4UmVjb25uZWN0QXR0ZW1wdHMpKVxuICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtID0gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKG51bSkgJiYgbnVtID49IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnJlbW90ZU1heFJlY29ubmVjdEF0dGVtcHRzID0gbnVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgLy8gVGVzdCBDb25uZWN0aW9uIEJ1dHRvblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKCdUZXN0IGNvbm5lY3Rpb24nKVxuICAgICAgICAgICAgLnNldERlc2MoJ1ZlcmlmeSB0aGF0IHRoZSByZW1vdGUgc2VydmVyIGlzIGFjY2Vzc2libGUnKVxuICAgICAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4gYnV0dG9uXG4gICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoJ1Rlc3QgQ29ubmVjdGlvbicpXG4gICAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBidXR0b24uc2V0QnV0dG9uVGV4dCgnVGVzdGluZy4uLicpO1xuICAgICAgICAgICAgICAgICAgICBidXR0b24uc2V0RGlzYWJsZWQodHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdm9pZCB0aGlzLnRlc3RSZW1vdGVDb25uZWN0aW9uKCkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLnNldERpc2FibGVkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KCdcdTI3MTMgQ29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IGJ1dHRvbi5zZXRCdXR0b25UZXh0KCdUZXN0IENvbm5lY3Rpb24nKTsgfSwgMjAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZSgnU3VjY2Vzc2Z1bGx5IGNvbm5lY3RlZCB0byByZW1vdGUgc2VydmVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KCdcdTI3MTcgRmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IGJ1dHRvbi5zZXRCdXR0b25UZXh0KCdUZXN0IENvbm5lY3Rpb24nKTsgfSwgMjAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShgQ29ubmVjdGlvbiBmYWlsZWQ6ICR7cmVzdWx0LmVycm9yfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdCByZW1vdGUgV2ViU29ja2V0IGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBwcml2YXRlIGFzeW5jIHRlc3RSZW1vdGVDb25uZWN0aW9uKCk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IFdlYlNvY2tldENsaWVudCB9ID0gYXdhaXQgaW1wb3J0KCcuL3dlYnNvY2tldC93ZWJzb2NrZXQtY2xpZW50Jyk7XG5cbiAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBXZWJTb2NrZXRDbGllbnQoe1xuICAgICAgICAgICAgICAgIHVybDogdGhpcy5wbHVnaW4uc2V0dGluZ3MucmVtb3RlU2VydmVyVXJsLFxuICAgICAgICAgICAgICAgIGNvbnZlcnNhdGlvbklkOiAndGVzdC1jb25uZWN0aW9uLScgKyBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgIGF1dG9SZWNvbm5lY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbm5lY3RUaW1lb3V0OiA1MDAwXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYXdhaXQgY2xpZW50LmNvbm5lY3QoKTtcbiAgICAgICAgICAgIGNsaWVudC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFN0cmluZyhlcnJvcikgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgdG8gZGV0ZWN0IENsYXVkZSBDb2RlIGluc3RhbGxhdGlvbiBwYXRoIChjcm9zcy1wbGF0Zm9ybSlcbiAgICAgKi9cbiAgICBwcml2YXRlIGRldGVjdENsYXVkZUNvZGVQYXRoKCk6IHN0cmluZyB8IG51bGwge1xuICAgICAgICBjb25zdCBpc1dpbmRvd3MgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInO1xuICAgICAgICBjb25zdCBob21lRGlyID0gcHJvY2Vzcy5lbnYuSE9NRSB8fCBwcm9jZXNzLmVudi5VU0VSUFJPRklMRSB8fCBvcy5ob21lZGlyKCk7XG5cbiAgICAgICAgbGV0IHBvc3NpYmxlUGF0aHM6IHN0cmluZ1tdID0gW107XG5cbiAgICAgICAgaWYgKGlzV2luZG93cykge1xuICAgICAgICAgICAgLy8gV2luZG93cy1zcGVjaWZpYyBwYXRoc1xuICAgICAgICAgICAgcG9zc2libGVQYXRocyA9IFtcbiAgICAgICAgICAgICAgICAnY2xhdWRlJywgLy8gSWYgaW4gUEFUSFxuICAgICAgICAgICAgICAgIHBhdGguam9pbihob21lRGlyLCAnQXBwRGF0YScsICdMb2NhbCcsICdQcm9ncmFtcycsICdjbGF1ZGUnLCAnY2xhdWRlLmV4ZScpLFxuICAgICAgICAgICAgICAgIHBhdGguam9pbihob21lRGlyLCAnLmJ1bicsICdiaW4nLCAnY2xhdWRlLmV4ZScpLFxuICAgICAgICAgICAgICAgICdDOlxcXFxQcm9ncmFtIEZpbGVzXFxcXGNsYXVkZVxcXFxjbGF1ZGUuZXhlJyxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBVbml4LWxpa2Ugc3lzdGVtc1xuICAgICAgICAgICAgcG9zc2libGVQYXRocyA9IFtcbiAgICAgICAgICAgICAgICAnY2xhdWRlJywgLy8gSWYgaW4gUEFUSFxuICAgICAgICAgICAgICAgICcvdXNyL2xvY2FsL2Jpbi9jbGF1ZGUnLFxuICAgICAgICAgICAgICAgICcvdXNyL2Jpbi9jbGF1ZGUnLFxuICAgICAgICAgICAgICAgIHBhdGguam9pbihob21lRGlyLCAnLmxvY2FsJywgJ2JpbicsICdjbGF1ZGUnKSxcbiAgICAgICAgICAgICAgICBwYXRoLmpvaW4oaG9tZURpciwgJ2JpbicsICdjbGF1ZGUnKSxcbiAgICAgICAgICAgICAgICBwYXRoLmpvaW4oaG9tZURpciwgJy5idW4nLCAnYmluJywgJ2NsYXVkZScpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgY21kUGF0aCBvZiBwb3NzaWJsZVBhdGhzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBleGVjdXRlICd3aGljaCcgb3IgJ3doZXJlJyBjb21tYW5kIGZvciBzaW1wbGUgcGF0aCBuYW1lc1xuICAgICAgICAgICAgICAgIGlmICghY21kUGF0aC5pbmNsdWRlcygnLycpICYmICFjbWRQYXRoLmluY2x1ZGVzKCdcXFxcJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2hpY2hDbWQgPSBpc1dpbmRvd3MgPyAnd2hlcmUnIDogJ3doaWNoJztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZXhlY1N5bmMoYCR7d2hpY2hDbWR9ICR7Y21kUGF0aH1gLCB7IGVuY29kaW5nOiAndXRmOCcgfSkudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbiBXaW5kb3dzLCAnd2hlcmUnIGNhbiByZXR1cm4gbXVsdGlwbGUgcGF0aHMsIHRha2UgdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnNwbGl0KCdcXG4nKVswXS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBmaWxlIGV4aXN0cyBmb3IgYWJzb2x1dGUgcGF0aHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoY21kUGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjbWRQYXRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgLy8gQ29udGludWUgdG8gbmV4dCBwYXRoXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIENsYXVkZSBDb2RlIGlzIGFjY2Vzc2libGUgYW5kIHdvcmtpbmcgKGNyb3NzLXBsYXRmb3JtKVxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgdGVzdENsYXVkZUNvZGUoKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNtZFBhdGggPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5jbGF1ZGVDb2RlUGF0aCB8fCAnY2xhdWRlJztcblxuICAgICAgICAgICAgY29uc3QgaXNXaW5kb3dzID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJztcbiAgICAgICAgICAgIGNvbnN0IGhvbWVEaXIgPSBwcm9jZXNzLmVudi5IT01FIHx8IHByb2Nlc3MuZW52LlVTRVJQUk9GSUxFIHx8IG9zLmhvbWVkaXIoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhTZXBhcmF0b3IgPSBpc1dpbmRvd3MgPyAnOycgOiAnOic7XG5cbiAgICAgICAgICAgIC8vIEJ1aWxkIGVuaGFuY2VkIFBBVEggLSBpbmNsdWRlIGNvbW1vbiB0b29sIGxvY2F0aW9ucyAoY3Jvc3MtcGxhdGZvcm0pXG4gICAgICAgICAgICBjb25zdCBlbnZQYXRoID0gcHJvY2Vzcy5lbnYuUEFUSCB8fCAnJztcbiAgICAgICAgICAgIGxldCBwYXRoc1RvQWRkOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoaXNXaW5kb3dzKSB7XG4gICAgICAgICAgICAgICAgcGF0aHNUb0FkZCA9IFtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5qb2luKGhvbWVEaXIsICdBcHBEYXRhJywgJ0xvY2FsJywgJ1Byb2dyYW1zJywgJ25vZGVqcycpLFxuICAgICAgICAgICAgICAgICAgICBwYXRoLmpvaW4oaG9tZURpciwgJy5idW4nLCAnYmluJyksXG4gICAgICAgICAgICAgICAgICAgICdDOlxcXFxQcm9ncmFtIEZpbGVzXFxcXG5vZGVqcycsXG4gICAgICAgICAgICAgICAgICAgICdDOlxcXFxQcm9ncmFtIEZpbGVzICh4ODYpXFxcXG5vZGVqcycsXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGF0aHNUb0FkZCA9IFtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5qb2luKGhvbWVEaXIsICcubnZtJywgJ3ZlcnNpb25zJywgJ25vZGUnLCAndjIwLjE4LjInLCAnYmluJyksXG4gICAgICAgICAgICAgICAgICAgIHBhdGguam9pbihob21lRGlyLCAnLmJ1bicsICdiaW4nKSxcbiAgICAgICAgICAgICAgICAgICAgJy91c3IvbG9jYWwvYmluJyxcbiAgICAgICAgICAgICAgICAgICAgJy91c3IvYmluJyxcbiAgICAgICAgICAgICAgICAgICAgJy9iaW4nLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nUGF0aHMgPSBwYXRoc1RvQWRkLmZpbHRlcihwID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnMuZXhpc3RzU3luYyhwKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBlbmhhbmNlZFBhdGggPSBbLi4ubmV3IFNldChbLi4uZXhpc3RpbmdQYXRocywgLi4uZW52UGF0aC5zcGxpdChwYXRoU2VwYXJhdG9yKV0pXS5qb2luKHBhdGhTZXBhcmF0b3IpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBleGVjKGAke2NtZFBhdGh9IC0tdmVyc2lvbmAsIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dDogNTAwMCxcbiAgICAgICAgICAgICAgICAgICAgZW52OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5wcm9jZXNzLmVudixcbiAgICAgICAgICAgICAgICAgICAgICAgIFBBVEg6IGVuaGFuY2VkUGF0aFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgKGVycm9yOiBFcnJvciB8IG51bGwsIHN0ZG91dDogc3RyaW5nLCBzdGRlcnI6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgc3VjY2VzczogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogU3RyaW5nKGUpIH07XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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QUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBO0FBQUEsTUFDN0M7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQTtBQUFBLE1BQzdDO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUE7QUFBQSxNQUM3QztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBO0FBQUEsTUFDN0M7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQTtBQUFBLE1BQzdDO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztBQUFBLE1BQUc7QUFBQSxNQUFHO0FBQUEsTUFBRztB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QUksVUFBVSxnQkFBZ0IscUJBQXFCO0FBQ3ZFLGFBQU8sUUFBUSxVQUFRO0FBQ25CLGNBQU0sT0FBTyxLQUFLO0FBQ2xCLGFBQUssZUFBZTtBQUFBLE1BQ3hCLENBQUM7QUFBQSxJQUNMO0FBQUE7QUFBQSxFQUVNLGVBQWU7QUFBQTtBQUNqQixZQUFNLEVBQUUsVUFBVSxJQUFJLEtBQUs7QUFFM0IsVUFBSSxPQUE2QjtBQUNqQyxZQUFNLFNBQVMsVUFBVSxnQkFBZ0IscUJBQXFCO0FBRTlELFVBQUksT0FBTyxTQUFTLEdBQUc7QUFFbkIsZUFBTyxPQUFPLENBQUM7QUFBQSxNQUNuQixPQUFPO0FBRUgsZUFBTyxVQUFVLGFBQWEsS0FBSztBQUNuQyxjQUFNLDZCQUFNLGFBQWEsRUFBRSxNQUFNLHVCQUF1QixRQUFRLEtBQUs7QUFBQSxNQUN6RTtBQUdBLFVBQUksTUFBTTtBQUNOLGFBQUssVUFBVSxXQUFXLElBQUk7QUFBQSxNQUNsQztBQUFBLElBQ0o7QUFBQTtBQUNKOyIsCiAgIm5hbWVzIjogWyJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAiZGF0YSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIlJlY2VpdmVyIiwgIm1vZHVsZSIsICJTZW5kZXIiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAiY3JlYXRlSGFzaCIsICJVUkwiLCAiUmVjZWl2ZXIiLCAiU2VuZGVyIiwgIldlYlNvY2tldCIsICJrZXkiLCAibW9kdWxlIiwgIldlYlNvY2tldCIsICJjcmVhdGVXZWJTb2NrZXRTdHJlYW0iLCAiZXJyIiwgIm1vZHVsZSIsICJwcm90b2NvbCIsICJtb2R1bGUiLCAiY3JlYXRlSGFzaCIsICJXZWJTb2NrZXQiLCAiV2ViU29ja2V0U2VydmVyIiwgIldlYlNvY2tldCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgInBhdGgiLCAiZnMiLCAicGF0aCIsICJjcnlwdG8iLCAiZnMiLCAicGF0aCIsICJwYXRoIiwgImZzIiwgInBhdGgiLCAicHJvY2VzcyIsICJpbXBvcnRfb2JzaWRpYW4iLCAiT2JzaWRpYW5NYXJrZG93blJlbmRlcmVyIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfY2hpbGRfcHJvY2VzcyIsICJvcyIsICJmcyIsICJwYXRoIiwgIldlYlNvY2tldENsaWVudCJdCn0K
